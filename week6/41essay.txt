Factors And Issues That Influence The Behaviour Of Software Engineering Groups
Most presentations on software engineering highlight the historically high failure rates of software projects, of up to eighty percent. Failure under the guise of budget overruns, delivery of solutions not compliant with specifications, late delivery and the like. More often than not, these failure rates are used to motivate the use of software engineering practices. The premise being that if adequate engineering practises were utilised, failure would become more of an exception rather than a rule. Best practise and lifecycles have been proposed and tailored to the various paradigms that the computer and information sciences throw up in rapid succession. There is extensive debate on what works and what does not within academia and without. The consensus being that what is best depends on the problem at hand and the expertise of those working on the problem.

A few software engineering group models have been popular in the history of software development. Earlier groups tended to be hierarchical, along the lines of traditional management teams. The project manager in-charge did not necessarily contribute in a non-managerial capacity and was responsible for putting together teams, had the last word on accepting recommendations and delegation to team members. Later groups worked around one or more chief-programmers or specialists. The specialists took charge of core components themselves and were assisted by other group members in testing, producing documentation and deployment. More recently, collegial groups have become common. Here, people with varied specialisations form groups wherein they organise themselves informally by assuming roles as needs arise.

The advantage of a particular model over the others becomes evident only in the context of specific projects. The hierarchical model is best suited to relatively large projects that are decomposable into sub-goals that can be addressed by near independent teams. This is usually possible for software tasks that are very well defined, that need reliable and quality controlled solutions, particularly those that are mission critical. A large project may inherently require many people working on it to successfully complete it, if it were to be deployed in multiple sites, for instance. Alternatively, a large group may be assembled to expedite delivery. In either case, structured organisation and well-defined roles facilitate coordination at a high level.

A central problem with adding people to expedite delivery, or otherwise, is that the effectiveness of a group does not scale linearly. One person joining another does not mean that they are collectively twice as productive. More importantly, the contribution of the seventh person in a seven-person group is a fraction of the contribution of the second person in a two-person group. This is due to additional overheads in communication and coordination as group size increases and to the dilution of tasks assigned to individual member. As is evident, this is a problem for any group; however, in very large groups the problem is exacerbated.

In hierarchical settings, group members do not have a sense of ownership of the bigger solution. This may be reflected in their productivity. Because of the concentration of decision-making powers to particular individuals according to some hierarchy, the success of processes ultimately lies with them. A lot rides on their ability to pick the best practises and recommendations, delegate effectively and keep track of the bigger picture. In quality-controlled or mission-critical settings, there are not many alternatives to having large hierarchical groups with redundant contributors.

Primarily in non-commercial settings, a single specialist engineers a complete software solution. Invariably, the solution being a prototype is accessible only to other specialists. In addition, it is not designed for general consumption and is put together without going through most recommended processes in software engineering lifecycles. Single programmers tend to practise evolutionary programming. This involves producing a quick working solution followed by repeated reworking of the solution to make it more accessible to the programmer for future review, incremental development and peer review or development. If demand for such a software solution gains momentum, for either its general utility or its commercial viability, the core solution would most likely be adopted for further development by a larger software engineering group. It stands to reason that the core developer, who is most familiar with the solution, retains the last word on further technical development. Other members organise themselves around the chief-programmer.

In general, some form of incremental development and periodic redevelopment from scratch of software solutions are common regardless of group models. The first incrementally developed solution tends to be the least well-engineered solution and is a patchwork of poorly designed and tightly coupled components. This is a reflection of the difficulty involved in producing quick solutions using new tools and techniques and inexperienced software engineers. Supported by a high immediate cost barrier to reworking solutions, incumbents from pervious software development cycles, spend a lot of their post deployment time in supporting and patching what they produced.

In collegial groups formed in smaller organisations or departments, software engineers assume roles as needs arise. Brainstorming may be carried out by all members and design approved by consensus but development may be carried out by a few individual members, while the others gain feedback from end-users, keep track of competitor solutions and the like. In the initial phases of a software development life cycle, the problem definition, feasibility study and system analysis phases, end users of the system and independent specialists may form part of the group. During the design and implementation phases, a disjoint group of outsiders could merge with the team. The external members may then be invited for their feedback post implementation during the quality assurance and maintenance phases. Generally, best practise suggests that groups should be adaptive or loosely structured during the creative phases and become more structured as the design becomes clearer.

Groups with loosely defined structures are the most flexible in adapting to changing user needs. However, the greatest risk to project cancellations and overruns are ill-defined and changing requirements. Adaptiveness to an extent is crucial. Given that users change requirements so compulsively, lacking adaptiveness completely would make an engineering group not viable. If group size is variable, the learning curve of new entrants must be kept in mind. A project manager hiring additional developers late in the software development cycle, after not meeting some deadline say, must factor in delayed contributions from the newcomers as a result of time taken by them to familiarise themselves with the project and time lost in coordinating their joining the group.

Following this, the next most common cause of failure is due to poor planning or management. If the person taking on the role of project manager has poor management or planning skills, the likelihood of which is heightened by the fact that each group member is called upon to serve in diverse capacities, projects are destined to fall over.

A number of reasonable software engineering guidelines are ignored by software engineers commonly. When programming, using descriptive names for variables is a good example. A section of program code will immediately make sense to its author for a reasonably long period, when reviewed. However, if the code were not documented sufficiently, which includes using descriptive variable names, and with the correct intended audience in mind, it would take a considerable amount of time for another programmer to understand what the other had implemented. In the extreme, some programmers obfuscate because they can or to ensure that only they will ever understand what they have written thereby making them indispensable. The potential for doing a half-hearted job of writing code is obvious in that poorly structured and poorly designed code is functionally indistinct from well-structured code and is less demanding a task. If software projects were evaluated only on their functionality, this would not pose a problem but upgrades and patches require someone to review the code and add to it or repair it in the future. The long term cost of maintaining software that is not well designed and documented may rise exponentially as older technologies are phased out and finding people competent to carry out repair and review shrink. In essence, this is an instance of a quality control problem.

Uncontrolled quality problems are the third most common cause of cancellations and overruns of software projects. It is convenient to group documentation along with quality control as they should be reviewed in tandem in a software development lifecycle. The first casualties of a late running project are quality control and documentation. The long-term costs of skimping on either have been illustrated by example above but there are short-term costs as well. In both evolutionary engineering common among specialist-centred groups and component engineering commonly employed by hierarchical groups, the quality of each revision or component affects the quality of subsequent revisions or combined components.

The next most common causes of failure are unrealistic or inaccurate estimates and na&iuml;ve adoption of emerging technologies. The blame for the former rests with both users and planners or project managers. Most engineering groups are unrealistically optimistic about the speed with which they can deliver solutions. Their estimates may be accurate for prototypes. In actual deployment, conformance to specifications, human-computer interfaces, quality control, training and change management are essential and take time. Users have a poor understanding of how descriptive their specifications are and much too often assume that implementers are contextually familiar with the environments in which they work and intend to use the system. Project managers and implementers have an affinity to emerging technologies ignoring their core competencies that are more likely to be established proven technologies.

Success among software engineering groups is a function of planning and execution. The responsibility of planning falls on a project manager. A manager must draw on the best a group has to offer, appreciate software and technical concerns, facilitate communication and coordinate a groups effort. Enforcing quality standards from the beginning by adopting design and programming guidelines, for example, helps formalise expectations. A project manager with a technical background has the advantage of understanding the position of other technical members and is likely to communicate more effectively with them and has the opportunity of leading by example. Given the emphasis on planning, it is worthwhile noting that it can be overdone. Over-engineering is not ideal engineering. It is often convenient for a single developer to take the lead for coding. Other developers and end-users should concurrently test the developing solution for functionality, usability and quality. Execution in isolation is likely to result in solutions that developers are comfortable with and even proud of but that end-users find lacking. The various stakeholders of the project must be simultaneously and consistently involved throughout the development cycle of software projects.

The greater the communication between specialist designers and specialist implementers, the more successful the group would be in terms of quality and ease-of-use of solutions. The technical crowd in a software engineering group sees the problem uniquely in terms of simplifying or making more elegant their contribution. The design crowd balances out this perspective by offering an alternative view, which is more likely to be aligned with that held by end-users, uncurtailed by technical considerations. Ultimately, end-users must be given an opportunity to have their say. The solution is theirs.

Changing requirements and specifications may be an acceptable excuse from the user's perspective for delays in final solution delivery. Many projects are twenty percent complete after eighty percent of the initially estimated time. More people are brought in to expedite the process, budget overruns follow and sub-par solutions are delivered, albeit, late. Given the historical frequency, project managers should factor in possible requirement changes to arrive at estimates that are more realistic before commencing projects.

3. Definitions
For the purposes of POSIX.1-2008, the following terms and definitions apply. The Authoritative Dictionary of IEEE Standards Terms, Seventh Edition should be referenced for terms not defined in this section.

Note:
No shading to denote extensions or options occurs in this chapter. Where the terms and definitions given in this chapter are used elsewhere in text related to extensions and options, they are shaded as appropriate.
3.1 Abortive Release
An abrupt termination of a network connection that may result in the loss of data.

3.2 Absolute Pathname
A pathname beginning with a single or more than two <slash> characters; see also Pathname.

Note:
Pathname Resolution is defined in detail in Pathname Resolution .
3.3 Access Mode
A particular form of access permitted to a file.

3.4 Additional File Access Control Mechanism
An implementation-defined mechanism that is layered upon the access control mechanisms defined here, but which do not grant permissions beyond those defined herein, although they may further restrict them.

Note:
File Access Permissions are defined in detail in File Access Permissions.
3.5 Address Space
The memory locations that can be referenced by a process or the threads of a process.

3.6 Advisory Information
An interface that advises the implementation on (portable) application behavior so that it can optimize the system.

3.7 Affirmative Response
An input string that matches one of the responses acceptable to the LC_MESSAGES category keyword yesexpr, matching an extended regular expression in the current locale.

Note:
The LC_MESSAGES category is defined in detail in LC_MESSAGES.
3.8 Alert
To cause the user's terminal to give some audible or visual indication that an error or some other event has occurred. When the standard output is directed to a terminal device, the method for alerting the terminal user is unspecified. When the standard output is not directed to a terminal device, the alert is accomplished by writing the alert to standard output (unless the utility description indicates that the use of standard output produces undefined results in this case).

3.9 Alert Character (<alert>)
A character that in the output stream should cause a terminal to alert its user via a visual or audible notification. It is the character designated by '\a' in the C language. It is unspecified whether this character is the exact sequence transmitted to an output device by the system to accomplish the alert function.

3.10 Alias Name
In the shell command language, a word consisting solely of underscores, digits, and alphabetics from the portable character set and any of the following characters: '!', '%', ',', '@'.

Implementations may allow other characters within alias names as an extension.

Note:
The Portable Character Set is defined in detail in Portable Character Set.
3.11 Alignment
A requirement that objects of a particular type be located on storage boundaries with addresses that are particular multiples of a byte address.

Note:
See also the ISO C standard, Section B3.
3.12 Alternate File Access Control Mechanism
An implementation-defined mechanism that is independent of the access control mechanisms defined herein, and which if enabled on a file may either restrict or extend the permissions of a given user. POSIX.1-2008 defines when such mechanisms can be enabled and when they are disabled.

Note:
File Access Permissions are defined in detail in File Access Permissions.
3.13 Alternate Signal Stack
Memory associated with a thread, established upon request by the implementation for a thread, separate from the thread signal stack, in which signal handlers responding to signals sent to that thread may be executed.

3.14 Ancillary Data
Protocol-specific, local system-specific, or optional information. The information can be both local or end-to-end significant, header information, part of a data portion, protocol-specific, and implementation or system-specific.

3.15 Angle Brackets
The characters '<' (left-angle-bracket) and '>' (right-angle-bracket). When used in the phrase "enclosed in angle brackets", the symbol '<' immediately precedes the object to be enclosed, and '>' immediately follows it. When describing these characters in the portable character set, the names <less-than-sign> and <greater-than-sign> are used.

3.16 Apostrophe Character (<apostrophe>)
The character designated by '\'' in the C language, also known as the single-quote character.

3.17 Application
A computer program that performs some desired function.

When the User Portability Utilities option is supported, requirements placed on applications relating to the use of standard utilities shall also apply to the actions of a user who is entering shell command language statements into an interactive shell.

3.18 Application Address
Endpoint address of a specific application.

3.19 Application Program Interface (API)
The definition of syntax and semantics for providing computer system services.

3.20 Appropriate Privileges
An implementation-defined means of associating privileges with a process with regard to the function calls, function call options, and the commands that need special privileges. There may be zero or more such means. These means (or lack thereof) are described in the conformance document.

Note:
Function calls are defined in the System Interfaces volume of POSIX.1-2008, and commands are defined in the Shell and Utilities volume of POSIX.1-2008.
3.21 Argument
In the shell command language, a parameter passed to a utility as the equivalent of a single string in the argv array created by one of the exec functions. An argument is one of the options, option-arguments, or operands following the command name.

Note:
The Utility Argument Syntax is defined in detail in Utility Argument Syntax and XCU Command Search and Execution.
In the C language, an expression in a function call expression or a sequence of preprocessing tokens in a function-like macro invocation.

3.22 Arm (a Timer)
To start a timer measuring the passage of time, enabling notifying a process when the specified time or time interval has passed.

3.23 Asterisk Character (<asterisk>)
The character '*'.

3.24 Async-Cancel-Safe Function
A function that may be safely invoked by an application while the asynchronous form of cancellation is enabled. No function is async-cancel-safe unless explicitly described as such.

3.25 Asynchronous Events
Events that occur independently of the execution of the application.

3.26 Asynchronous Input and Output
A functionality enhancement to allow an application process to queue data input and output commands with asynchronous notification of completion.

3.27 Async-Signal-Safe Function
A function that can be called, without restriction, from signal-catching functions. Note that, although there is no restriction on the calls themselves, for certain functions there are restrictions on subsequent behavior after the function is called from a signal-catching function. No function is async-signal-safe unless explicitly described as such.

Note:
Async-signal-safety is defined in detail in XSH Signal Actions .
3.28 Asynchronously-Generated Signal
A signal that is not attributable to a specific thread. Examples are signals sent via kill(), signals sent from the keyboard, and signals delivered to process groups. Being asynchronous is a property of how the signal was generated and not a property of the signal number. All signals may be generated asynchronously.

Note:
The kill() function is defined in detail in the System Interfaces volume of POSIX.1-2008.
3.29 Asynchronous I/O Completion
For an asynchronous read or write operation, when a corresponding synchronous read or write would have completed and when any associated status fields have been updated.

3.30 Asynchronous I/O Operation
An I/O operation that does not of itself cause the thread requesting the I/O to be blocked from further use of the processor.

This implies that the process and the I/O operation may be running concurrently.

3.31 Authentication
The process of validating a user or process to verify that the user or process is not a counterfeit.

3.32 Authorization
The process of verifying that a user or process has permission to use a resource in the manner requested.

To ensure security, the user or process would also need to be authenticated before granting access.

3.33 Background Job
See Background Process Group in Background Process Group (or Background Job).

3.34 Background Process
A process that is a member of a background process group.

3.35 Background Process Group (or Background Job)
Any process group, other than a foreground process group, that is a member of a session that has established a connection with a controlling terminal.

3.36 Backquote Character
The character '`', also known as <grave-accent>.

3.37 Backslash Character (<backslash>)
The character designated by '\\' in the C language, also known as reverse solidus.

3.38 Backspace Character (<backspace>)
A character that, in the output stream, should cause printing (or displaying) to occur one column position previous to the position about to be printed. If the position about to be printed is at the beginning of the current line, the behavior is unspecified. It is the character designated by '\b' in the C language. It is unspecified whether this character is the exact sequence transmitted to an output device by the system to accomplish the backspace function. The backspace defined here is not necessarily the ERASE special character.

Note:
Special Characters are defined in detail in Special Characters .
3.39 Barrier
A synchronization object that allows multiple threads to synchronize at a particular point in their execution.

3.40 Basename
For pathnames containing at least one filename: the final, or only, filename in the pathname. For pathnames consisting only of <slash> characters: either '/' or "//" if the pathname consists of exactly two <slash> characters, and '/' otherwise.

3.41 Basic Regular Expression (BRE)
A regular expression (see Regular Expression) used by the majority of utilities that select strings from a set of character strings.

Note:
Basic Regular Expressions are described in detail in Basic Regular Expressions.
3.42 Batch Access List
A list of user IDs and group IDs of those users and groups authorized to place batch jobs in a batch queue.

A batch access list is associated with a batch queue. A batch server uses the batch access list of a batch queue as one of the criteria in deciding to put a batch job in a batch queue.

3.43 Batch Administrator
A user that is authorized to modify all the attributes of queues and jobs and to change the status of a batch server.

3.44 Batch Client
A computational entity that utilizes batch services by making requests of batch servers.

Batch clients often provide the means by which users access batch services, although a batch server may act as a batch client by virtue of making requests of another batch server.

3.45 Batch Destination
The batch server in a batch system to which a batch job should be sent for processing.

Acceptance of a batch job at a batch destination is the responsibility of a receiving batch server. A batch destination may consist of a batch server-specific portion, a network-wide portion, or both. The batch server-specific portion is referred to as the "batch queue". The network-wide portion is referred to as a "batch server name".

3.46 Batch Destination Identifier
A string that identifies a specific batch destination.

A string of characters in the portable character set used to specify a particular batch destination.

Note:
The Portable Character Set is defined in detail in Portable Character Set.
3.47 Batch Directive
A line from a file that is interpreted by the batch server. The line is usually in the form of a comment and is an additional means of passing options to the qsub utility.

Note:
The qsub utility is defined in detail in the Shell and Utilities volume of POSIX.1-2008.
3.48 Batch Job
A set of computational tasks for a computing system.

Batch jobs are managed by batch servers.

Once created, a batch job may be executing or pending execution. A batch job that is executing has an associated session leader (a process) that initiates and monitors the computational tasks of the batch job.

3.49 Batch Job Attribute
A named data type whose value affects the processing of a batch job.

The values of the attributes of a batch job affect the processing of that job by the batch server that manages the batch job.

3.50 Batch Job Identifier
A unique name for a batch job. A name that is unique among all other batch job identifiers in a batch system and that identifies the batch server to which the batch job was originally submitted.

3.51 Batch Job Name
A label that is an attribute of a batch job. The batch job name is not necessarily unique.

3.52 Batch Job Owner
The username@ hostname of the user submitting the batch job, where username is a user name (see also User Name) and hostname is a network host name.

3.53 Batch Job Priority
A value specified by the user that may be used by an implementation to determine the order in which batch jobs are selected to be executed. Job priority has a numeric value in the range -1024 to 1023.

Note:
The batch job priority is not the execution priority (nice value) of the batch job.
3.54 Batch Job State
An attribute of a batch job which determines the types of requests that the batch server that manages the batch job can accept for the batch job. Valid states include QUEUED, RUNNING, HELD, WAITING, EXITING, and TRANSITING.

3.55 Batch Name Service
A service that assigns batch names that are unique within the batch name space, and that can translate a unique batch name into the location of the named batch entity.

3.56 Batch Name Space
The environment within which a batch name is known to be unique.

3.57 Batch Node
A host containing part or all of a batch system.

A batch node is a host meeting at least one of the following conditions:

Capable of executing a batch client

Contains a routing batch queue

Contains an execution batch queue

3.58 Batch Operator
A user that is authorized to modify some, but not all, of the attributes of jobs and queues, and may change the status of the batch server.

3.59 Batch Queue
A manageable object that represents a set of batch jobs and is managed by a single batch server.

Note:
A set of batch jobs is called a batch queue largely for historical reasons. Jobs are selected from the batch queue for execution based on attributes such as priority, resource requirements, and hold conditions.
See also XCU Batch Queues.

3.60 Batch Queue Attribute
A named data type whose value affects the processing of all batch jobs that are members of the batch queue.

A batch queue has attributes that affect the processing of batch jobs that are members of the batch queue.

3.61 Batch Queue Position
The place, relative to other jobs in the batch queue, occupied by a particular job in a batch queue. This is defined in part by submission time and priority; see also Batch Queue Priority.

3.62 Batch Queue Priority
The maximum job priority allowed for any batch job in a given batch queue.

The batch queue priority is set and may be changed by users with appropriate privileges. The priority is bounded in an implementation-defined manner.

3.63 Batch Rerunability
An attribute of a batch job indicating that it may be rerun after an abnormal termination from the beginning without affecting the validity of the results.

3.64 Batch Restart
The action of resuming the processing of a batch job from the point of the last checkpoint. Typically, this is done if the batch job has been interrupted because of a system failure.

3.65 Batch Server
A computational entity that provides batch services.

3.66 Batch Server Name
A string of characters in the portable character set used to specify a particular server in a network.

Note:
The Portable Character Set is defined in detail in Portable Character Set.
3.67 Batch Service
Computational and organizational services performed by a batch system on behalf of batch jobs.

Batch services are of two types: requested and deferred.

Note:
Batch Services are listed in XCU Batch Services Summary.
3.68 Batch Service Request
A solicitation of services from a batch client to a batch server.

A batch service request may entail the exchange of any number of messages between the batch client and the batch server.

When naming specific types of service requests, the term "request" is qualified by the type of request, as in Queue Batch Job Request and Delete Batch Job Request.

3.69 Batch Submission
The process by which a batch client requests that a batch server create a batch job via a Queue Job Request to perform a specified computational task.

3.70 Batch System
A collection of one or more batch servers.

3.71 Batch Target User
The name of a user on the batch destination batch server.

The target user is the user name under whose account the batch job is to execute on the destination batch server.

3.72 Batch User
A user who is authorized to make use of batch services.

3.73 Bind
The process of assigning a network address to an endpoint.

3.74 Blank Character (<blank>)
One of the characters that belong to the blank character class as defined via the LC_CTYPE category in the current locale. In the POSIX locale, a <blank> character is either a <tab> or a <space>.

3.75 Blank Line
A line consisting solely of zero or more <blank> characters terminated by a <newline>; see also Empty Line.

3.76 Blocked Process (or Thread)
A process (or thread) that is waiting for some condition (other than the availability of a processor) to be satisfied before it can continue execution.

3.77 Blocking
A property of an open file description that causes function calls associated with it to wait for the requested action to be performed before returning.

3.78 Block-Mode Terminal
A terminal device operating in a mode incapable of the character-at-a-time input and output operations described by some of the standard utilities.

Note:
Output Devices and Terminal Types are defined in detail in Output Devices and Terminal Types.
3.79 Block Special File
A file that refers to a device. A block special file is normally distinguished from a character special file by providing access to the device in a manner such that the hardware characteristics of the device are not visible.

3.80 Braces
The characters '{' (left-curly-bracket) and '}' (right-curly-bracket). When used in the phrase "enclosed in (curly) braces" the symbol '{' immediately precedes the object to be enclosed, and '}' immediately follows it. When describing these characters in the portable character set, the names <left-curly-bracket> and <left-brace> are used for '{', and <right-curly-bracket> and <right-brace> are used for '}'.

3.81 Brackets
The characters '[' (left-square-bracket) and ']' (right-square-bracket). When used in the phrase "enclosed in (square) brackets" the symbol '[' immediately precedes the object to be enclosed, and ']' immediately follows it. When describing these characters in the portable character set, the names <left-square-bracket> and <right-square-bracket> are used.

3.82 Broadcast
The transfer of data from one endpoint to several endpoints, as described in RFC 919 and RFC 922.

3.83 Built-In Utility (or Built-In)
A utility implemented within a shell. The utilities referred to as special built-ins have special qualities. Unless qualified, the term "built-in" includes the special built-in utilities. Regular built-ins are not required to be actually built into the shell on the implementation, but they do have special command-search qualities.

Note:
Special Built-In Utilities are defined in detail in XCU Special Built-In Utilities.
Regular Built-In Utilities are defined in detail in XCU Command Search and Execution.

3.84 Byte
An individually addressable unit of data storage that is exactly an octet, used to store a character or a portion of a character; see also Character. A byte is composed of a contiguous sequence of 8 bits. The least significant bit is called the "low-order" bit; the most significant is called the "high-order" bit.

Note:
The definition of byte from the ISO C standard is broader than the above and might accommodate hardware architectures with different sized addressable units than octets.
3.85 Byte Input/Output Functions
The functions that perform byte-oriented input from streams or byte-oriented output to streams: fgetc(), fgets(), fprintf(), fputc(), fputs(), fread(), fscanf(), fwrite(), getc(), getchar(), getdelim(), getline(), gets(), printf(), putc(), putchar(), puts(), scanf(), ungetc(), vfprintf(), and vprintf().

Note:
Functions are defined in detail in the System Interfaces volume of POSIX.1-2008.
3.86 Carriage-Return Character (<carriage-return>)
A character that in the output stream indicates that printing should start at the beginning of the same physical line in which the carriage-return occurred. It is the character designated by '\r' in the C language. It is unspecified whether this character is the exact sequence transmitted to an output device by the system to accomplish the movement to the beginning of the line.

3.87 Character
A sequence of one or more bytes representing a single graphic symbol or control code.

Note:
This term corresponds to the ISO C standard term multi-byte character, where a single-byte character is a special case of a multi-byte character. Unlike the usage in the ISO C standard, character here has no necessary relationship with storage space, and byte is used when storage space is discussed.
See the definition of the portable character set in Portable Character Set for a further explanation of the graphical representations of (abstract) characters, as opposed to character encodings.

3.88 Character Array
An array of elements of type char.

3.89 Character Class
A named set of characters sharing an attribute associated with the name of the class. The classes and the characters that they contain are dependent on the value of the LC_CTYPE category in the current locale.

Note:
The LC_CTYPE category is defined in detail in LC_CTYPE .
3.90 Character Set
A finite set of different characters used for the representation, organization, or control of data.

3.91 Character Special File
A file that refers to a device (such as a terminal device file) or that has special properties (such as /dev/null).

Note:
The General Terminal Interface is defined in detail in General Terminal Interface.
3.92 Character String
A contiguous sequence of characters terminated by and including the first null byte.

3.93 Child Process
A new process created (by fork(), posix_spawn(), or posix_spawnp()) by a given process. A child process remains the child of the creating process as long as both processes continue to exist.

Note:
The fork(), posix_spawn(), and posix_spawnp() functions are defined in detail in the System Interfaces volume of POSIX.1-2008.
3.94 Circumflex Character (<circumflex>)
The character '^'.

3.95 Clock
A software or hardware object that can be used to measure the apparent or actual passage of time.

The current value of the time measured by a clock can be queried and, possibly, set to a value within the legal range of the clock.

3.96 Clock Jump
The difference between two successive distinct values of a clock, as observed from the application via one of the "get time'' operations.

3.97 Clock Tick
An interval of time; an implementation-defined number of these occur each second. Clock ticks are one of the units that may be used to express a value found in type clock_t.

3.98 Coded Character Set
A set of unambiguous rules that establishes a character set and the one-to-one relationship between each character of the set and its bit representation.

3.99 Codeset
The result of applying rules that map a numeric code value to each element of a character set. An element of a character set may be related to more than one numeric code value but the reverse is not true. However, for state-dependent encodings the relationship between numeric code values and elements of a character set may be further controlled by state information. The character set may contain fewer elements than the total number of possible numeric code values; that is, some code values may be unassigned.

Note:
Character Encoding is defined in detail in Character Encoding.
3.100 Collating Element
The smallest entity used to determine the logical ordering of character or wide-character strings; see also Collation Sequence. A collating element consists of either a single character, or two or more characters collating as a single entity. The value of the LC_COLLATE category in the current locale determines the current set of collating elements.

3.101 Collation
The logical ordering of character or wide-character strings according to defined precedence rules. These rules identify a collation sequence between the collating elements, and such additional rules that can be used to order strings consisting of multiple collating elements.

3.102 Collation Sequence
The relative order of collating elements as determined by the setting of the LC_COLLATE category in the current locale. The collation sequence is used for sorting and is determined from the collating weights assigned to each collating element. In the absence of weights, the collation sequence is the order in which collating elements are specified between order_start and order_end keywords in the LC_COLLATE category.

Multi-level sorting is accomplished by assigning elements one or more collation weights, up to the limit {COLL_WEIGHTS_MAX}. On each level, elements may be given the same weight (at the primary level, called an equivalence class; see also Equivalence Class) or be omitted from the sequence. Strings that collate equally using the first assigned weight (primary ordering) are then compared using the next assigned weight (secondary ordering), and so on.

Note:
{COLL_WEIGHTS_MAX} is defined in detail in <limits.h>.
3.103 Column Position
A unit of horizontal measure related to characters in a line.

It is assumed that each character in a character set has an intrinsic column width independent of any output device. Each printable character in the portable character set has a column width of one. The standard utilities, when used as described in POSIX.1-2008, assume that all characters have integral column widths. The column width of a character is not necessarily related to the internal representation of the character (numbers of bits or bytes).

The column position of a character in a line is defined as one plus the sum of the column widths of the preceding characters in the line. Column positions are numbered starting from 1.

3.104 Command
A directive to the shell to perform a particular task.

Note:
Shell Commands are defined in detail in XCU Shell Commands.
3.105 Command Language Interpreter
An interface that interprets sequences of text input as commands. It may operate on an input stream or it may interactively prompt and read commands from a terminal. It is possible for applications to invoke utilities through a number of interfaces, which are collectively considered to act as command interpreters. The most obvious of these are the sh utility and the system() function, although popen() and the various forms of exec may also be considered to behave as interpreters.

Note:
The sh utility is defined in detail in the Shell and Utilities volume of POSIX.1-2008.
The system(), popen(), and exec functions are defined in detail in the System Interfaces volume of POSIX.1-2008.

3.106 Composite Graphic Symbol
A graphic symbol consisting of a combination of two or more other graphic symbols in a single character position, such as a diacritical mark and a base character.

3.107 Condition Variable
A synchronization object which allows a thread to suspend execution, repeatedly, until some associated predicate becomes true. A thread whose execution is suspended on a condition variable is said to be blocked on the condition variable.

3.108 Connected Socket
A connection-mode socket for which a connection has been established, or a connectionless-mode socket for which a peer address has been set. See also Connection, Connection Mode, Connectionless Mode, and Socket.

3.109 Connection
An association established between two or more endpoints for the transfer of data

3.110 Connection Mode
The transfer of data in the context of a connection; see also Connectionless Mode.

3.111 Connectionless Mode
The transfer of data other than in the context of a connection; see also Connection Mode and Datagram.

3.112 Control Character
A character, other than a graphic character, that affects the recording, processing, transmission, or interpretation of text.

3.113 Control Operator
In the shell command language, a token that performs a control function. It is one of the following symbols:

&   &&   (   )   ;   ;;   newline   |   ||

The end-of-input indicator used internally by the shell is also considered a control operator.

Note:
Token Recognition is defined in detail in XCU Token Recognition .
3.114 Controlling Process
The session leader that established the connection to the controlling terminal. If the terminal subsequently ceases to be a controlling terminal for this session, the session leader ceases to be the controlling process.

3.115 Controlling Terminal
A terminal that is associated with a session. Each session may have at most one controlling terminal associated with it, and a controlling terminal is associated with exactly one session. Certain input sequences from the controlling terminal cause signals to be sent to all processes in the foreground process group associated with the controlling terminal.

Note:
The General Terminal Interface is defined in detail in General Terminal Interface.
3.116 Conversion Descriptor
A per-process unique value used to identify an open codeset conversion.

3.117 Core File
A file of unspecified format that may be generated when a process terminates abnormally.

3.118 CPU Time (Execution Time)
The time spent executing a process or thread, including the time spent executing system services on behalf of that process or thread. If the Threads option is supported, then the value of the CPU-time clock for a process is implementation-defined. With this definition the sum of all the execution times of all the threads in a process might not equal the process execution time, even in a single-threaded process, because implementations may differ in how they account for time during context switches or for other reasons.

3.119 CPU-Time Clock
A clock that measures the execution time of a particular process or thread.

3.120 CPU-Time Timer
A timer attached to a CPU-time clock.

3.121 Current Job
In the context of job control, the job that will be used as the default for the fg or bg utilities. There is at most one current job; see also Job Control Job ID.

3.122 Current Working Directory
See Working Directory in Working Directory (or Current Working Directory).

3.123 Cursor Position
The line and column position on the screen denoted by the terminal's cursor.

3.124 Datagram
A unit of data transferred from one endpoint to another in connectionless mode service.

3.125 Data Segment
Memory associated with a process, that can contain dynamically allocated data.

3.126 Deferred Batch Service
A service that is performed as a result of events that are asynchronous with respect to requests.

Note:
Once a batch job has been created, it is subject to deferred services.
3.127 Device
A computer peripheral or an object that appears to the application as such.

3.128 Device ID
A non-negative integer used to identify a device.

3.129 Directory
A file that contains directory entries. No two directory entries in the same directory have the same name.

3.130 Directory Entry (or Link)
An object that associates a filename with a file. Several directory entries can associate names with the same file.

3.131 Directory Stream
A sequence of all the directory entries in a particular directory. An open directory stream may be implemented using a file descriptor.

3.132 Disarm (a Timer)
To stop a timer from measuring the passage of time, disabling any future process notifications (until the timer is armed again).

3.133 Display
To output to the user's terminal. If the output is not directed to a terminal, the results are undefined.

3.134 Display Line
A line of text on a physical device or an emulation thereof. Such a line will have a maximum number of characters which can be presented.

Note:
This may also be written as "line on the display".
3.135 Dollar-Sign Character (<dollar-sign>)
The character '$'.

3.136 Dot
In the context of naming files, the filename consisting of a single <period> character ( '.' ).

Note:
In the context of shell special built-in utilities, see dot in XCU Special Built-In Utilities.
Pathname Resolution is defined in detail in Pathname Resolution.

3.137 Dot-Dot
The filename consisting solely of two <period> characters ( ".." ).

Note:
Pathname Resolution is defined in detail in Pathname Resolution .
3.138 Double-Quote Character
The character '"' also known as <quotation-mark>.

Note:
The "double" adjective in this term refers to the two strokes in the character glyph. POSIX.1-2008 never uses the term "double-quote" to refer to two apostrophes or quotation-marks.
3.139 Downshifting
The conversion of an uppercase character that has a single-character lowercase representation into this lowercase representation.

3.140 Driver
A module that controls data transferred to and received from devices.

Note:
Drivers are traditionally written to be a part of the system implementation, although they are frequently written separately from the writing of the implementation. A driver may contain processor-specific code, and therefore be non-portable.
3.141 Effective Group ID
An attribute of a process that is used in determining various permissions, including file access permissions; see also Group ID.

3.142 Effective User ID
An attribute of a process that is used in determining various permissions, including file access permissions; see also User ID.

3.143 Eight-Bit Transparency
The ability of a software component to process 8-bit characters without modifying or utilizing any part of the character in a way that is inconsistent with the rules of the current coded character set.

3.144 Empty Directory
A directory that contains, at most, directory entries for dot and dot-dot, and has exactly one link to it (other than its own dot entry, if one exists), in dot-dot. No other links to the directory may exist. It is unspecified whether an implementation can ever consider the root directory to be empty.

3.145 Empty Line
A line consisting of only a <newline>; see also Blank Line.

3.146 Empty String (or Null String)
A string whose first byte is a null byte.

3.147 Empty Wide-Character String
A wide-character string whose first element is a null wide-character code.

3.148 Encoding Rule
The rules used to convert between wide-character codes and multi-byte character codes.

Note:
Stream Orientation and Encoding Rules are defined in detail in XSH Stream Orientation and Encoding Rules.
3.149 Entire Regular Expression
The concatenated set of one or more basic regular expressions or extended regular expressions that make up the pattern specified for string selection.

Note:
Regular Expressions are defined in detail in Regular Expressions.
3.150 Epoch
The time zero hours, zero minutes, zero seconds, on January 1, 1970 Coordinated Universal Time (UTC).

Note:
See also Seconds Since the Epoch defined in Seconds Since the Epoch.
3.151 Equivalence Class
A set of collating elements with the same primary collation weight.

Elements in an equivalence class are typically elements that naturally group together, such as all accented letters based on the same base letter.

The collation order of elements within an equivalence class is determined by the weights assigned on any subsequent levels after the primary weight.

3.152 Era
A locale-specific method for counting and displaying years.

Note:
The LC_TIME category is defined in detail in LC_TIME.
3.153 Event Management
The mechanism that enables applications to register for and be made aware of external events such as data becoming available for reading.

3.154 Executable File
A regular file acceptable as a new process image file by the equivalent of the exec family of functions, and thus usable as one form of a utility. The standard utilities described as compilers can produce executable files, but other unspecified methods of producing executable files may also be provided. The internal format of an executable file is unspecified, but a conforming application cannot assume an executable file is a text file.

3.155 Execute
To perform command search and execution actions, as defined in the Shell and Utilities volume of POSIX.1-2008; see also Invoke.

Note:
Command Search and Execution is defined in detail in XCU Command Search and Execution.
3.156 Execution Time
See CPU Time in CPU Time (Execution Time).

3.157 Execution Time Monitoring
A set of execution time monitoring primitives that allow online measuring of thread and process execution times.

3.158 Expand
In the shell command language, when not qualified, the act of applying word expansions.

Note:
Word Expansions are defined in detail in XCU wordexp.
3.159 Extended Regular Expression (ERE)
A regular expression (see also Regular Expression) that is an alternative to the Basic Regular Expression using a more extensive syntax, occasionally used by some utilities.

Note:
Extended Regular Expressions are described in detail in Extended Regular Expressions.
3.160 Extended Security Controls
Implementation-defined security controls allowed by the file access permission and appropriate privileges (see also Appropriate Privileges) mechanisms, through which an implementation can support different security policies from those described in POSIX.1-2008.

Note:
See also Extended Security Controls defined in Extended Security Controls.
File Access Permissions are defined in detail in File Access Permissions.

3.161 Feature Test Macro
A macro used to determine whether a particular set of features is included from a header.

Note:
See also XSH The Compilation Environment.
3.162 Field
In the shell command language, a unit of text that is the result of parameter expansion, arithmetic expansion, command substitution, or field splitting. During command processing, the resulting fields are used as the command name and its arguments.

Note:
Parameter Expansion is defined in detail in XCU Parameter Expansion.
Arithmetic Expansion is defined in detail in XCU Arithmetic Expansion.

Command Substitution is defined in detail in XCU Command Substitution.

Field Splitting is defined in detail in XCU Field Splitting.

For further information on command processing, see XCU Simple Commands.

3.163 FIFO Special File (or FIFO)
A type of file with the property that data written to such a file is read on a first-in-first-out basis.

Note:
Other characteristics of FIFOs are described in the System Interfaces volume of POSIX.1-2008, lseek(), open(), read(), and write().
3.164 File
An object that can be written to, or read from, or both. A file has certain attributes, including access permissions and type. File types include regular file, character special file, block special file, FIFO special file, symbolic link, socket, and directory. Other types of files may be supported by the implementation.

3.165 File Description
See Open File Description in Open File Description.

3.166 File Descriptor
A per-process unique, non-negative integer used to identify an open file for the purpose of file access. The value of a newly-created file descriptor is from zero to {OPEN_MAX}-1. A file descriptor can have a value greater than or equal to {OPEN_MAX} if the value of {OPEN_MAX} has decreased (see sysconf) since the file descriptor was opened. File descriptors may also be used to implement message catalog descriptors and directory streams; see also Open File Description.

Note:
{OPEN_MAX} is defined in detail in <limits.h>.
3.167 File Group Class
The property of a file indicating access permissions for a process related to the group identification of a process. A process is in the file group class of a file if the process is not in the file owner class and if the effective group ID or one of the supplementary group IDs of the process matches the group ID associated with the file. Other members of the class may be implementation-defined.

3.168 File Mode
An object containing the file mode bits and some information about the file type of a file.

Note:
File mode bits and file types are defined in detail in <sys/stat.h> .
3.169 File Mode Bits
A file's file permission bits, set-user-ID-on-execution bit (S_ISUID), set-group-ID-on-execution bit (S_ISGID), and, on directories, the restricted deletion flag bit (S_ISVTX).

Note:
File Mode Bits are defined in detail in <sys/stat.h>.
3.170 Filename
A sequence of bytes consisting of 1 to {NAME_MAX} bytes used to name a file. The bytes composing the name shall not contain the <NUL> or <slash> characters. In the context of a pathname, each filename shall be followed by a <slash> or a <NUL> character; elsewhere, a filename followed by a <NUL> character forms a string (but not necessarily a character string). The filenames dot and dot-dot have special meaning. A filename is sometimes referred to as a "pathname component". See also Pathname.

Note:
Pathname Resolution is defined in detail in Pathname Resolution .
3.171 Filename String
A string consisting of a filename followed by a <NUL> character.

3.172 File Offset
The byte position in the file where the next I/O operation begins. Each open file description associated with a regular file, block special file, or directory has a file offset. A character special file that does not refer to a terminal device may have a file offset. There is no file offset specified for a pipe or FIFO.

3.173 File Other Class
The property of a file indicating access permissions for a process related to the user and group identification of a process. A process is in the file other class of a file if the process is not in the file owner class or file group class.

3.174 File Owner Class
The property of a file indicating access permissions for a process related to the user identification of a process. A process is in the file owner class of a file if the effective user ID of the process matches the user ID of the file.

3.175 File Permission Bits
Information about a file that is used, along with other information, to determine whether a process has read, write, or execute/search permission to a file. The bits are divided into three parts: owner, group, and other. Each part is used with the corresponding file class of processes. These bits are contained in the file mode.

Note:
File modes are defined in detail in <sys/stat.h>.
File Access Permissions are defined in detail in File Access Permissions.

3.176 File Serial Number
A per-file system unique identifier for a file.

3.177 File System
A collection of files and certain of their attributes. It provides a name space for file serial numbers referring to those files.

3.178 File Type
See File in File.

3.179 Filter
A command whose operation consists of reading data from standard input or a list of input files and writing data to standard output. Typically, its function is to perform some transformation on the data stream.

3.180 First Open (of a File)
When a process opens a file that is not currently an open file within any process.

3.181 Flow Control
The mechanism employed by a communications provider that constrains a sending entity to wait until the receiving entities can safely receive additional data without loss.

3.182 Foreground Job
See Foreground Process Group in Foreground Process Group (or Foreground Job).

3.183 Foreground Process
A process that is a member of a foreground process group.

3.184 Foreground Process Group (or Foreground Job)
A process group whose member processes have certain privileges, denied to processes in background process groups, when accessing their controlling terminal. Each session that has established a connection with a controlling terminal has at most one process group of the session as the foreground process group of that controlling terminal.

Note:
The General Terminal Interface is defined in detail in General Terminal Interface.
3.185 Foreground Process Group ID
The process group ID of the foreground process group.

3.186 Form-Feed Character (<form-feed>)
A character that in the output stream indicates that printing should start on the next page of an output device. It is the character designated by '\f' in the C language. If the form-feed is not the first character of an output line, the result is unspecified. It is unspecified whether this character is the exact sequence transmitted to an output device by the system to accomplish the movement to the next page.

3.187 Graphic Character
A member of the graph character class of the current locale.

Note:
The graph character class is defined in detail in LC_CTYPE .
3.188 Group Database
A system database that contains at least the following information for each group ID:

Group name

Numerical group ID

List of users allowed in the group

The list of users allowed in the group is used by the newgrp utility.

Note:
The newgrp utility is defined in detail in the Shell and Utilities volume of POSIX.1-2008.
3.189 Group ID
A non-negative integer, which can be contained in an object of type gid_t, that is used to identify a group of system users. Each system user is a member of at least one group. When the identity of a group is associated with a process, a group ID value is referred to as a real group ID, an effective group ID, one of the supplementary group IDs, or a saved set-group-ID. The value (gid_t)-1 shall not be a valid group ID, but does have a defined use in some interfaces defined in this standard.

3.190 Group Name
A string that is used to identify a group; see also Group Database. To be portable across conforming systems, the value is composed of characters from the portable filename character set. The <hyphen-minus> should not be used as the first character of a portable group name.

3.191 Hard Limit
A system resource limitation that may be reset to a lesser or greater limit by a privileged process. A non-privileged process is restricted to only lowering its hard limit.

3.192 Hard Link
The relationship between two directory entries that represent the same file; see also Directory Entry (or Link). The result of an execution of the ln utility (without the -s option) or the link() function. This term is contrasted against symbolic link; see also Symbolic Link.

3.193 Home Directory
The directory specified by the HOME environment variable.

3.194 Host Byte Order
The arrangement of bytes in any integer type when using a specific machine architecture.

Note:
Two common methods of byte ordering are big-endian and little-endian. Big-endian is a format for storage of binary data in which the most significant byte is placed first, with the rest in descending order. Little-endian is a format for storage or transmission of binary data in which the least significant byte is placed first, with the rest in ascending order. See also Host and Network Byte Orders.
3.195 Incomplete Line
A sequence of one or more non- <newline> characters at the end of the file.

3.196 Inf
A value representing +infinity or a value representing -infinity that can be stored in a floating type. Not all systems support the Inf values.

3.197 Instrumented Application
An application that contains at least one call to the trace point function posix_trace_event(). Each process of an instrumented application has a mapping of trace event names to trace event type identifiers. This mapping is used by the trace stream that is created for that process.

3.198 Interactive Shell
A processing mode of the shell that is suitable for direct user interaction.

3.199 Internationalization
The provision within a computer program of the capability of making itself adaptable to the requirements of different native languages, local customs, and coded character sets.

3.200 Interprocess Communication
A functionality enhancement to add a high-performance, deterministic interprocess communication facility for local communication.

3.201 Invoke
To perform command search and execution actions, except that searching for shell functions and special built-in utilities is suppressed; see also Execute.

Note:
Command Search and Execution is defined in detail in XCU Command Search and Execution.
3.202 Job
A set of processes, comprising a shell pipeline, and any processes descended from it, that are all in the same process group.

Note:
See also XCU Pipelines.
3.203 Job Control
A facility that allows users selectively to stop (suspend) the execution of processes and continue (resume) their execution at a later point. The user typically employs this facility via the interactive interface jointly supplied by the terminal I/O driver and a command interpreter.

3.204 Job Control Job ID
A handle that is used to refer to a job. The job control job ID can be any of the forms shown in the following table:
Table: Job Control Job ID Formats
Job Control

 

Job ID

Meaning

%%

Current job.

%+

Current job.

%-

Previous job.

%n

Job number n.

%string

Job whose command begins with string.

%?string

Job whose command contains string.

3.205 Last Close (of a File)
When a process closes a file, resulting in the file not being an open file within any process.

3.206 Line
A sequence of zero or more non- <newline> characters plus a terminating <newline> character.

3.207 Linger
The period of time before terminating a connection, to allow outstanding data to be transferred.

3.208 Link
See Directory Entry in Directory Entry (or Link).

3.209 Link Count
The number of directory entries that refer to a particular file.

3.210 Live Process
An address space with one or more threads executing within that address space, and the required system resources for those threads.

Note:
Many of the system resources defined by POSIX.1-2008 are shared among all of the threads within a process. These include the process ID, the parent process ID, process group ID, session membership, real, effective, and saved set-user-ID, real, effective, and saved set-group-ID, supplementary group IDs, current working directory, root directory, file mode creation mask, and file descriptors.
3.211 Local Customs
The conventions of a geographical area or territory for such things as date, time, and currency formats.

3.212 Local Interprocess Communication (Local IPC)
The transfer of data between processes in the same system.

3.213 Locale
The definition of the subset of a user's environment that depends on language and cultural conventions.

Note:
Locales are defined in detail in Locale.
3.214 Localization
The process of establishing information within a computer system specific to the operation of particular native languages, local customs, and coded character sets.

3.215 Login
The unspecified activity by which a user gains access to the system. Each login is associated with exactly one login name.

3.216 Login Name
A user name that is associated with a login.

3.217 Map
To create an association between a page-aligned range of the address space of a process and some memory object, such that a reference to an address in that range of the address space results in a reference to the associated memory object. The mapped memory object is not necessarily memory-resident.

3.218 Marked Message
A STREAMs message on which a certain flag is set. Marking a message gives the application protocol-specific information. An application can use ioctl() to determine whether a given message is marked.

Note:
The ioctl() function is defined in detail in the System Interfaces volume of POSIX.1-2008.
3.219 Matched
A state applying to a sequence of zero or more characters when the characters in the sequence correspond to a sequence of characters defined by a basic regular expression or extended regular expression pattern.

Note:
Regular Expressions are defined in detail in Regular Expressions.
3.220 Memory Mapped Files
A facility to allow applications to access files as part of the address space.

3.221 Memory Object
One of:

A file (see File)

A shared memory object (see Shared Memory Object)

A typed memory object (see Typed Memory Object)

When used in conjunction with mmap(), a memory object appears in the address space of the calling process.

Note:
The mmap() function is defined in detail in the System Interfaces volume of POSIX.1-2008.
3.222 Memory-Resident
The process of managing the implementation in such a way as to provide an upper bound on memory access times.

3.223 Message
In the context of programmatic message passing, information that can be transferred between processes or threads by being added to and removed from a message queue. A message consists of a fixed-size message buffer.

3.224 Message Catalog
In the context of providing natural language messages to the user, a file or storage area containing program messages, command prompts, and responses to prompts for a particular native language, territory, and codeset.

3.225 Message Catalog Descriptor
In the context of providing natural language messages to the user, a per-process unique value used to identify an open message catalog. A message catalog descriptor may be implemented using a file descriptor.

3.226 Message Queue
In the context of programmatic message passing, an object to which messages can be added and removed. Messages may be removed in the order in which they were added or in priority order.

3.227 Mode
A collection of attributes that specifies a file's type and its access permissions.

Note:
File Access Permissions are defined in detail in File Access Permissions.
3.228 Monotonic Clock
A clock measuring real time, whose value cannot be set via clock_settime() and which cannot have negative clock jumps.

3.229 Mount Point
Either the system root directory or a directory for which the st_dev field of structure stat differs from that of its parent directory.

Note:
The stat structure is defined in detail in <sys/stat.h>.
3.230 Multi-Character Collating Element
A sequence of two or more characters that collate as an entity. For example, in some coded character sets, an accented character is represented by a non-spacing accent, followed by the letter. Other examples are the Spanish elements ch and ll.

3.231 Multi-Threaded Library
A library containing object files that were produced by compiling with c99 using the flags output by getconf POSIX_V7_THREADS_CFLAGS, or by compiling using a non-standard utility with equivalent flags, and which makes use of interfaces that are only made available by c99 when the -l pthread option is used or makes use of SIGEV_THREAD notifications.

3.232 Multi-Threaded Process
A process that contains more than one thread.

3.233 Multi-Threaded Program
A program whose executable file was produced by compiling with c99 using the flags output by getconf POSIX_V7_THREADS_CFLAGS, and linking with c99 using the flags output by getconf POSIX_V7_THREADS_LDFLAGS and the -l pthread option, or by compiling and linking using a non-standard utility with equivalent flags. Execution of a multi-threaded program initially creates a single-threaded process; the process can create additional threads using pthread_create() or SIGEV_THREAD notifications.

3.234 Mutex
A synchronization object used to allow multiple threads to serialize their access to shared data. The name derives from the capability it provides; namely, mutual-exclusion. The thread that has locked a mutex becomes its owner and remains the owner until that same thread unlocks the mutex.

3.235 Name
In the shell command language, a word consisting solely of underscores, digits, and alphabetics from the portable character set. The first character of a name is not a digit.

Note:
The Portable Character Set is defined in detail in Portable Character Set.
3.236 Named STREAM
A STREAMS-based file descriptor that is attached to a name in the file system name space. All subsequent operations on the named STREAM act on the STREAM that was associated with the file descriptor until the name is disassociated from the STREAM.

3.237 NaN (Not a Number)
A set of values that may be stored in a floating type but that are neither Inf nor valid floating-point numbers. Not all systems support NaN values.

3.238 Native Language
A computer user's spoken or written language, such as American English, British English, Danish, Dutch, French, German, Italian, Japanese, Norwegian, or Swedish.

3.239 Negative Response
An input string that matches one of the responses acceptable to the LC_MESSAGES category keyword noexpr, matching an extended regular expression in the current locale.

Note:
The LC_MESSAGES category is defined in detail in LC_MESSAGES.
3.240 Network
A collection of interconnected hosts.

Note:
The term "network" in POSIX.1-2008 is used to refer to the network of hosts. The term "batch system" is used to refer to the network of batch servers.
3.241 Network Address
A network-visible identifier used to designate specific endpoints in a network. Specific endpoints on host systems have addresses, and host systems may also have addresses.

3.242 Network Byte Order
The way of representing any integer type such that, when transmitted over a network via a network endpoint, the int type is transmitted as an appropriate number of octets with the most significant octet first, followed by any other octets in descending order of significance.

Note:
This order is more commonly known as big-endian ordering. See also Host and Network Byte Orders.
3.243 Newline Character (<newline>)
A character that in the output stream indicates that printing should start at the beginning of the next line. It is the character designated by '\n' in the C language. It is unspecified whether this character is the exact sequence transmitted to an output device by the system to accomplish the movement to the next line.

3.244 Nice Value
A number used as advice to the system to alter process scheduling. Numerically smaller values give a process additional preference when scheduling a process to run. Numerically larger values reduce the preference and make a process less likely to run. Typically, a process with a smaller nice value runs to completion more quickly than an equivalent process with a higher nice value. The symbol {NZERO} specifies the default nice value of the system.

3.245 Non-Blocking
A property of an open file description that causes function calls involving it to return without delay when it is detected that the requested action associated with the function call cannot be completed without unknown delay.

Note:
The exact semantics are dependent on the type of file associated with the open file description. For data reads from devices such as ttys and FIFOs, this property causes the read to return immediately when no data was available. Similarly, for writes, it causes the call to return immediately when the thread would otherwise be delayed in the write operation; for example, because no space was available. For networking, it causes functions not to await protocol events (for example, acknowledgements) to occur. See also XSH Socket I/O Mode.
3.246 Non-Spacing Characters
A character, such as a character representing a diacritical mark in the ISO/IEC 6937:1994 standard coded graphic character set, which is used in combination with other characters to form composite graphic symbols.

3.247 NUL
A character with all bits set to zero.

3.248 Null Byte
A byte with all bits set to zero.

3.249 Null Pointer
A pointer obtained by converting an integer constant expression with the value 0, or such an expression cast to type void *, to a pointer type; for example, (char *)0. The C language guarantees that a null pointer compares unequal to a pointer to any object or function, so it is used by many functions that return pointers to indicate an error.

3.250 Null String
See Empty String in Empty String (or Null String).

3.251 Null Wide-Character Code
A wide-character code with all bits set to zero.

3.252 Number-Sign Character (<number-sign>)
The character '#', also known as hash sign.

3.253 Object File
A regular file containing the output of a compiler, formatted as input to a linkage editor for linking with other object files into an executable form. The methods of linking are unspecified and may involve the dynamic linking of objects at runtime. The internal format of an object file is unspecified, but a conforming application cannot assume an object file is a text file.

3.254 Octet
Unit of data representation that consists of eight contiguous bits.

3.255 Offset Maximum
An attribute of an open file description representing the largest value that can be used as a file offset.

3.256 Opaque Address
An address such that the entity making use of it requires no details about its contents or format.

3.257 Open File
A file that is currently associated with a file descriptor.

3.258 Open File Description
A record of how a process or group of processes is accessing a file. Each file descriptor refers to exactly one open file description, but an open file description can be referred to by more than one file descriptor. The file offset, file status, and file access modes are attributes of an open file description.

3.259 Operand
An argument to a command that is generally used as an object supplying information to a utility necessary to complete its processing. Operands generally follow the options in a command line.

Note:
Utility Argument Syntax is defined in detail in Utility Argument Syntax.
3.260 Operator
In the shell command language, either a control operator or a redirection operator.

3.261 Option
An argument to a command that is generally used to specify changes in the utility's default behavior.

Note:
Utility Argument Syntax is defined in detail in Utility Argument Syntax.
3.262 Option-Argument
A parameter that follows certain options. In some cases an option-argument is included within the same argument string as the option-in most cases it is the next argument.

Note:
Utility Argument Syntax is defined in detail in Utility Argument Syntax.
3.263 Orientation
A stream has one of three orientations: unoriented, byte-oriented, or wide-oriented.

Note:
For further information, see XSH Stream Orientation and Encoding Rules.
3.264 Orphaned Process Group
A process group in which the parent of every member is either itself a member of the group or is not a member of the group's session.

3.265 Page
The granularity of process memory mapping or locking.

Physical memory and memory objects can be mapped into the address space of a process on page boundaries and in integral multiples of pages. Process address space can be locked into memory (made memory-resident) on page boundaries and in integral multiples of pages.

3.266 Page Size
The size, in bytes, of the system unit of memory allocation, protection, and mapping. On systems that have segment rather than page-based memory architectures, the term "page" means a segment.

3.267 Parameter
In the shell command language, an entity that stores values. There are three types of parameters: variables (named parameters), positional parameters, and special parameters. Parameter expansion is accomplished by introducing a parameter with the '$' character.

Note:
See also XCU Parameters and Variables.
In the C language, an object declared as part of a function declaration or definition that acquires a value on entry to the function, or an identifier following the macro name in a function-like macro definition.

3.268 Parent Directory
When discussing a given directory, the directory that both contains a directory entry for the given directory and is represented by the pathname dot-dot in the given directory.

When discussing other types of files, a directory containing a directory entry for the file under discussion.

This concept does not apply to dot and dot-dot.

3.269 Parent Process
The process which created (or inherited) the process under discussion.

3.270 Parent Process ID
An attribute of a new process identifying the parent of the process. The parent process ID of a process is the process ID of its creator, for the lifetime of the creator. After the creator's lifetime has ended, the parent process ID is the process ID of an implementation-defined system process.

3.271 Pathname
A string that is used to identify a file. In the context of POSIX.1-2008, a pathname may be limited to {PATH_MAX} bytes, including the terminating null byte. It has optional beginning <slash> characters, followed by zero or more filenames separated by <slash> characters. A pathname can optionally contain one or more trailing <slash> characters. Multiple successive <slash> characters are considered to be the same as one <slash>, except for the case of exactly two leading <slash> characters.

Note:
If a pathname consists of only bytes corresponding to characters from the portable filename character set (see Portable Filename Character Set), <slash> characters, and a single terminating <NUL> character, the pathname will be usable as a character string in all supported locales; otherwise, the pathname might only be a string (rather than a character string). Additionally, since the single-byte encoding of the <slash> character is required to be the same across all locales and to not occur within a multi-byte character, references to a <slash> character within a pathname are well-defined even when the pathname is not a character string. However, this property does not necessarily hold for the remaining characters within the portable filename character set.
Pathname Resolution is defined in detail in Pathname Resolution.

3.272 Pathname Component
See Filename in Filename.

3.273 Path Prefix
The part of a pathname up to, but not including, the last component and any trailing <slash> characters, unless the pathname consists entirely of <slash> characters, in which case the path prefix is '/' for a pathname containing either a single <slash> or three or more <slash> characters, and '//' for the pathname //. The path prefix of a pathname containing no <slash> characters is empty, but is treated as referring to the current working directory.

Note:
The term is used both in the sense of identifying part of a pathname that forms the prefix and of joining a non-empty path prefix to a filename to form a pathname. In the latter case, the path prefix need not have a trailing <slash> (in which case the joining is done with a <slash> character).
3.274 Pattern
A sequence of characters used either with regular expression notation or for pathname expansion, as a means of selecting various character strings or pathnames, respectively.

Note:
Regular Expressions are defined in detail in Regular Expressions.
See also XCU Pathname Expansion.

The syntaxes of the two types of patterns are similar, but not identical; POSIX.1-2008 always indicates the type of pattern being referred to in the immediate context of the use of the term.

3.275 Period Character (<period>)
The character '.'. The term "period" is contrasted with dot (see also Dot), which is used to describe a specific directory entry.

3.276 Permissions
Attributes of an object that determine the privilege necessary to access or manipulate the object.

Note:
File Access Permissions are defined in detail in File Access Permissions.
3.277 Persistence
A mode for semaphores, shared memory, and message queues requiring that the object and its state (including data, if any) are preserved after the object is no longer referenced by any process.

Persistence of an object does not imply that the state of the object is maintained across a system crash or a system reboot.

3.278 Pipe
An object identical to a FIFO which has no links in the file hierarchy.

Note:
The pipe() function is defined in detail in the System Interfaces volume of POSIX.1-2008.
3.279 Polling
A scheduling scheme whereby the local process periodically checks until the pre-specified events (for example, read, write) have occurred.

3.280 Portable Character Set
The collection of characters that are required to be present in all locales supported by conforming systems.

Note:
The Portable Character Set is defined in detail in Portable Character Set.
This term is contrasted against the smaller portable filename character set; see also Portable Filename Character Set.

3.281 Portable Filename
A filename consisting only of characters from the portable filename character set.

Note:
Applications should avoid using filenames that have the <hyphen-minus> character as the first character since this may cause problems when filenames are passed as command line arguments.
3.282 Portable Filename Character Set
The set of characters from which portable filenames are constructed.

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
a b c d e f g h i j k l m n o p q r s t u v w x y z
0 1 2 3 4 5 6 7 8 9 . _ -

The last three characters are the <period>, <underscore>, and <hyphen-minus> characters, respectively. See also Pathname.

3.283 Positional Parameter
In the shell command language, a parameter denoted by a single digit or one or more digits in curly braces.

Note:
For further information, see XCU Positional Parameters.
3.284 Preallocation
The reservation of resources in a system for a particular use.

Preallocation does not imply that the resources are immediately allocated to that use, but merely indicates that they are guaranteed to be available in bounded time when needed.

3.285 Preempted Process (or Thread)
A running thread whose execution is suspended due to another thread becoming runnable at a higher priority.

3.286 Previous Job
In the context of job control, the job that will be used as the default for the fg or bg utilities if the current job exits. There is at most one previous job; see also Job Control Job ID.

3.287 Printable Character
One of the characters included in the print character classification of the LC_CTYPE category in the current locale.

Note:
The LC_CTYPE category is defined in detail in LC_CTYPE .
3.288 Printable File
A text file consisting only of the characters included in the print and space character classifications of the LC_CTYPE category and the <backspace>, all in the current locale.

Note:
The LC_CTYPE category is defined in detail in LC_CTYPE .
3.289 Priority
A non-negative integer associated with processes or threads whose value is constrained to a range defined by the applicable scheduling policy. Numerically higher values represent higher priorities.

3.290 Priority Band
The queuing order applied to normal priority STREAMS messages. High priority STREAMS messages are not grouped by priority bands. The only differentiation made by the STREAMS mechanism is between zero and non-zero bands, but specific protocol modules may differentiate between priority bands.

3.291 Priority Inversion
A condition in which a thread that is not voluntarily suspended (waiting for an event or time delay) is not running while a lower priority thread is running. Such blocking of the higher priority thread is often caused by contention for a shared resource.

3.292 Priority Scheduling
A performance and determinism improvement facility to allow applications to determine the order in which threads that are ready to run are granted access to processor resources.

3.293 Priority-Based Scheduling
Scheduling in which the selection of a running thread is determined by the priorities of the runnable processes or threads.

3.294 Privilege
See Appropriate Privileges in Appropriate Privileges.

3.295 Process
A live process (see Live Process) or a zombie process (see Zombie Process ). The lifetime of a process is described in Process Lifetime.

3.296 Process Group
A collection of processes that permits the signaling of related processes. Each process in the system is a member of a process group that is identified by a process group ID. A newly created process joins the process group of its creator.

3.297 Process Group ID
The unique positive integer identifier representing a process group during its lifetime.

Note:
See also Process Group ID Reuse defined in Process ID Reuse .
3.298 Process Group Leader
A process whose process ID is the same as its process group ID.

3.299 Process Group Lifetime
The period of time that begins when a process group is created and ends when the last remaining process in the group leaves the group, due either to the end of the lifetime of the last process or to the last remaining process calling the setsid() or setpgid() functions.

Note:
The setsid() and setpgid() functions are defined in detail in the System Interfaces volume of POSIX.1-2008.
3.300 Process ID
The unique positive integer identifier representing a process during its lifetime.

Note:
See also Process ID Reuse defined in Process ID Reuse.
3.301 Process Lifetime
The period of time that begins when a process is created and ends when its process ID is returned to the system.

See also Live Process, Process Termination, and Zombie Process.

Note:
Process creation is defined in detail in the descriptions of the fork(), posix_spawn(), and posix_spawnp() functions in the System Interfaces volume of POSIX.1-2008.
3.302 Process Memory Locking
A performance improvement facility to bind application programs into the high-performance random access memory of a computer system. This avoids potential latencies introduced by the operating system in storing parts of a program that were not recently referenced on secondary memory devices.

3.303 Process Termination
There are two kinds of process termination:

Normal termination occurs by a return from main(), when requested with the exit(), _exit(), or _Exit() functions; or when the last thread in the process terminates by returning from its start function, by calling the pthread_exit() function, or through cancellation.

Abnormal termination occurs when requested by the abort() function or when some signals are received.

Note:
The consequences of process termination can be found in the description of the _Exit() function in the System Interfaces volume of POSIX.1-2008. The _exit(), _Exit(), abort(), and exit() functions are defined in detail in the System Interfaces volume of POSIX.1-2008.
3.304 Process-To-Process Communication
The transfer of data between processes.

3.305 Process Virtual Time
The measurement of time in units elapsed by the system clock while a process is executing.

3.306 Program
A prepared sequence of instructions to the system to accomplish a defined task. The term "program" in POSIX.1-2008 encompasses applications written in the Shell Command Language, complex utility input languages (for example, awk, lex, sed, and so on), and high-level languages.

3.307 Protocol
A set of semantic and syntactic rules for exchanging information.

3.308 Pseudo-Terminal
A facility that provides an interface that is identical to the terminal subsystem, except where noted otherwise in POSIX.1-2008. A pseudo-terminal is composed of two devices: the "master device" and a "slave device". The slave device provides processes with an interface that is identical to the terminal interface, although there need not be hardware behind that interface. Anything written on the master device is presented to the slave as an input and anything written on the slave device is presented as an input on the master side.

3.309 Radix Character
The character that separates the integer part of a number from the fractional part.

3.310 Read-Only File System
A file system that has implementation-defined characteristics restricting modifications.

Note:
File Times Update is described in detail in File Times Update.
3.311 Read-Write Lock
Multiple readers, single writer (read-write) locks allow many threads to have simultaneous read-only access to data while allowing only one thread to have write access at any given time. They are typically used to protect data that is read-only more frequently than it is changed.

Read-write locks can be used to synchronize threads in the current process and other processes if they are allocated in memory that is writable and shared among the cooperating processes and have been initialized for this behavior.

3.312 Real Group ID
The attribute of a process that, at the time of process creation, identifies the group of the user who created the process; see also Group ID.

3.313 Real Time
Time measured as total units elapsed by the system clock without regard to which thread is executing.

3.314 Realtime Signal Extension
A determinism improvement facility to enable asynchronous signal notifications to an application to be queued without impacting compatibility with the existing signal functions.

3.315 Real User ID
The attribute of a process that, at the time of process creation, identifies the user who created the process; see also User ID.

3.316 Record
A collection of related data units or words which is treated as a unit.

3.317 Redirection
In the shell command language, a method of associating files with the input or output of commands.

Note:
For further information, see XCU Redirection.
3.318 Redirection Operator
In the shell command language, a token that performs a redirection function. It is one of the following symbols:

<     >     >|     <<     >>     <&     >&     <<-     <>

3.319 Referenced Shared Memory Object
A shared memory object that is open or has one or more mappings defined on it.

3.320 Refresh
To ensure that the information on the user's terminal screen is up-to-date.

3.321 Regular Expression
A pattern that selects specific strings from a set of character strings.

Note:
Regular Expressions are described in detail in Regular Expressions .
3.322 Region
In the context of the address space of a process, a sequence of addresses.

In the context of a file, a sequence of offsets.

3.323 Regular File
A file that is a randomly accessible sequence of bytes, with no further structure imposed by the system.

3.324 Relative Pathname
A pathname not beginning with a <slash> character.

Note:
Pathname Resolution is defined in detail in Pathname Resolution .
3.325 Relocatable File
A file holding code or data suitable for linking with other object files to create an executable or a shared object file.

3.326 Relocation
The process of connecting symbolic references with symbolic definitions. For example, when a program calls a function, the associated call instruction transfers control to the proper destination address at execution.

3.327 Requested Batch Service
A service that is either rejected or performed prior to a response from the service to the requester.

3.328 (Time) Resolution
The minimum time interval that a clock can measure or whose passage a timer can detect.

3.329 Robust Mutex
A mutex with the robust attribute set.

Note:
The robust attribute is defined in detail by the pthread_mutexattr_getrobust() function.
3.330 Root Directory
A directory, associated with a process, that is used in pathname resolution for pathnames that begin with a <slash> character.

3.331 Runnable Process (or Thread)
A thread that is capable of being a running thread, but for which no processor is available.

3.332 Running Process (or Thread)
A thread currently executing on a processor. On multi-processor systems there may be more than one such thread in a system at a time.

3.333 Saved Resource Limits
An attribute of a process that provides some flexibility in the handling of unrepresentable resource limits, as described in the exec family of functions and setrlimit().

Note:
The exec and setrlimit() functions are defined in detail in the System Interfaces volume of POSIX.1-2008.
3.334 Saved Set-Group-ID
An attribute of a process that allows some flexibility in the assignment of the effective group ID attribute, as described in the exec family of functions and setgid().

Note:
The exec and setgid() functions are defined in detail in the System Interfaces volume of POSIX.1-2008.
3.335 Saved Set-User-ID
An attribute of a process that allows some flexibility in the assignment of the effective user ID attribute, as described in the exec family of functions and setuid().

Note:
The exec and setuid() functions are defined in detail in the System Interfaces volume of POSIX.1-2008.
3.336 Scheduling
The application of a policy to select a runnable process or thread to become a running process or thread, or to alter one or more of the thread lists.

3.337 Scheduling Allocation Domain
The set of processors on which an individual thread can be scheduled at any given time.

3.338 Scheduling Contention Scope
A property of a thread that defines the set of threads against which that thread competes for resources.

For example, in a scheduling decision, threads sharing scheduling contention scope compete for processor resources. In POSIX.1-2008, a thread has scheduling contention scope of either PTHREAD_SCOPE_SYSTEM or PTHREAD_SCOPE_PROCESS.

3.339 Scheduling Policy
A set of rules that is used to determine the order of execution of processes or threads to achieve some goal.

Note:
Scheduling Policy is defined in detail in Scheduling Policy.
3.340 Screen
A rectangular region of columns and lines on a terminal display. A screen may be a portion of a physical display device or may occupy the entire physical area of the display device.

3.341 Scroll
To move the representation of data vertically or horizontally relative to the terminal screen. There are two types of scrolling:

The cursor moves with the data.

The cursor remains stationary while the data moves.

3.342 Semaphore
A minimum synchronization primitive to serve as a basis for more complex synchronization mechanisms to be defined by the application program.

Note:
Semaphores are defined in detail in Semaphore.
3.343 Session
A collection of process groups established for job control purposes. Each process group is a member of a session. A process is considered to be a member of the session of which its process group is a member. A newly created process joins the session of its creator. A process can alter its session membership; see setsid(). There can be multiple process groups in the same session.

Note:
The setsid() function is defined in detail in the System Interfaces volume of POSIX.1-2008.
3.344 Session Leader
A process that has created a session.

Note:
For further information, see the setsid() function defined in the System Interfaces volume of POSIX.1-2008.
3.345 Session Lifetime
The period between when a session is created and the end of the lifetime of all the process groups that remain as members of the session.

3.346 Shared Memory Object
An object that represents memory that can be mapped concurrently into the address space of more than one process.

3.347 Shell
A program that interprets sequences of text input as commands. It may operate on an input stream or it may interactively prompt and read commands from a terminal.

3.348 Shell, the
The Shell Command Language Interpreter; a specific instance of a shell.

Note:
For further information, see the sh utility defined in the Shell and Utilities volume of POSIX.1-2008.
3.349 Shell Script
A file containing shell commands. If the file is made executable, it can be executed by specifying its name as a simple command. Execution of a shell script causes a shell to execute the commands within the script. Alternatively, a shell can be requested to execute the commands in a shell script by specifying the name of the shell script as the operand to the sh utility.

Note:
Simple Commands are defined in detail in XCU Simple Commands.
The sh utility is defined in detail in the Shell and Utilities volume of POSIX.1-2008.

3.350 Signal
A mechanism by which a process or thread may be notified of, or affected by, an event occurring in the system. Examples of such events include hardware exceptions and specific actions by processes. The term signal is also used to refer to the event itself.

3.351 Signal Stack
Memory established for a thread, in which signal handlers catching signals sent to that thread are executed.

3.352 Single-Quote Character
The character designated by '\'' in the C language, also known as <apostrophe>.

3.353 Single-Threaded Process
A process that contains a single thread.

3.354 Single-Threaded Program
A program whose executable file was produced by compiling with c99 without using the flags output by getconf POSIX_V7_THREADS_CFLAGS and linking with c99 using neither the flags output by getconf POSIX_V7_THREADS_LDFLAGS nor the -l pthread option, or by compiling and linking using a non-standard utility with equivalent flags. Execution of a single-threaded program creates a single-threaded process; if the process attempts to create additional threads using pthread_create() or SIGEV_THREAD notifications, the behavior is undefined. If the process uses dlopen() to load a multi-threaded library, the behavior is undefined.

3.355 Slash Character (<slash>)
The character '/', also known as solidus.

3.356 Socket
A file of a particular type that is used as a communications endpoint for process-to-process communication as described in the System Interfaces volume of POSIX.1-2008.

3.357 Socket Address
An address associated with a socket or remote endpoint, including an address family identifier and addressing information specific to that address family. The address may include multiple parts, such as a network address associated with a host system and an identifier for a specific endpoint.

3.358 Soft Limit
A resource limitation established for each process that the process may set to any value less than or equal to the hard limit.

3.359 Source Code
When dealing with the Shell Command Language, input to the command language interpreter. The term "shell script" is synonymous with this meaning.

When dealing with an ISO/IEC-conforming programming language, source code is input to a compiler conforming to that ISO/IEC standard.

Source code also refers to the input statements prepared for the following standard utilities: awk, bc, ed, ex, lex, localedef, make, sed, and yacc.

Source code can also refer to a collection of sources meeting any or all of these meanings.

Note:
The awk, bc, ed, ex, lex, localedef, make, sed, and yacc utilities are defined in detail in the Shell and Utilities volume of POSIX.1-2008.
3.360 Space Character (<space>)
The character defined in the portable character set as <space>. The <space> character is a member of the space character class of the current locale, but represents the single character, and not all of the possible members of the class; see also White Space.

3.361 Spawn
A process creation primitive useful for systems that have difficulty with fork() and as an efficient replacement for fork()/ exec.

3.362 Special Built-In
See Built-In Utility in Built-In Utility (or Built-In).

3.363 Special Parameter
In the shell command language, a parameter named by a single character from the following list:

*   @   #   ?   !   -   $   0

Note:
For further information, see XCU Special Parameters.
3.364 Spin Lock
A synchronization object used to allow multiple threads to serialize their access to shared data.

3.365 Sporadic Server
A scheduling policy for threads and processes that reserves a certain amount of execution capacity for processing aperiodic events at a given priority level.

3.366 Standard Error
An output stream usually intended to be used for diagnostic messages.

3.367 Standard Input
An input stream usually intended to be used for primary data input.

3.368 Standard Output
An output stream usually intended to be used for primary data output.

3.369 Standard Utilities
The utilities described in the Shell and Utilities volume of POSIX.1-2008.

3.370 Stream
Appearing in lowercase, a stream is a file access object that allows access to an ordered sequence of characters, as described by the ISO C standard. Such objects can be created by the fdopen(), fmemopen(), fopen(), open_memstream(), or popen() functions, and are associated with a file descriptor. A stream provides the additional services of user-selectable buffering and formatted input and output; see also STREAM.

Note:
For further information, see XSH Standard I/O Streams.
The fdopen(), fmemopen(), fopen(), open_memstream(), and popen() functions are defined in detail in the System Interfaces volume of POSIX.1-2008.

3.371 STREAM
Appearing in uppercase, STREAM refers to a full-duplex connection between a process and an open device or pseudo-device. It optionally includes one or more intermediate processing modules that are interposed between the process end of the STREAM and the device driver (or pseudo-device driver) end of the STREAM; see also Stream.

Note:
For further information, see XSH STREAMS.
3.372 STREAM End
The STREAM end is the driver end of the STREAM and is also known as the downstream end of the STREAM.

3.373 STREAM Head
The STREAM head is the beginning of the STREAM and is at the boundary between the system and the application process. This is also known as the upstream end of the STREAM.

3.374 STREAMS Multiplexor
A driver with multiple STREAMS connected to it. Multiplexing with STREAMS connected above is referred to as N-to-1, or "upper multiplexing". Multiplexing with STREAMS connected below is referred to as 1-to-N or "lower multiplexing".

3.375 String
A contiguous sequence of bytes terminated by and including the first null byte.

3.376 Subshell
A shell execution environment, distinguished from the main or current shell execution environment.

Note:
For further information, see XCU Shell Execution Environment.
3.377 Successfully Transferred
For a write operation to a regular file, when the system ensures that all data written is readable on any subsequent open of the file (even one that follows a system or power failure) in the absence of a failure of the physical storage medium.

For a read operation, when an image of the data on the physical storage medium is available to the requesting process.

3.378 Supplementary Group ID
An attribute of a process used in determining file access permissions. A process has up to {NGROUPS_MAX} supplementary group IDs in addition to the effective group ID. The supplementary group IDs of a process are set to the supplementary group IDs of the parent process when the process is created.

3.379 Suspended Job
A job that has received a SIGSTOP, SIGTSTP, SIGTTIN, or SIGTTOU signal that caused the process group to stop. A suspended job is a background job, but a background job is not necessarily a suspended job.

3.380 Symbolic Constant
An object-like macro defined with a constant value.

Unless stated otherwise, the following shall apply to every symbolic constant:

It expands to a compile-time constant expression with an integer type.

It may be defined as another type of constant-e.g., an enumeration constant-as well as being a macro.

It need not be usable in #if preprocessing directives.

3.381 Symbolic Link
A type of file with the property that when the file is encountered during pathname resolution, a string stored by the file is used to modify the pathname resolution. The stored string has a length of {SYMLINK_MAX} bytes or fewer.

Note:
Pathname Resolution is defined in detail in Pathname Resolution .
3.382 Synchronized Input and Output
A determinism and robustness improvement mechanism to enhance the data input and output mechanisms, so that an application can ensure that the data being manipulated is physically present on secondary mass storage devices.

3.383 Synchronized I/O Completion
The state of an I/O operation that has either been successfully transferred or diagnosed as unsuccessful.

3.384 Synchronized I/O Data Integrity Completion
For read, when the operation has been completed or diagnosed if unsuccessful. The read is complete only when an image of the data has been successfully transferred to the requesting process. If there were any pending write requests affecting the data to be read at the time that the synchronized read operation was requested, these write requests are successfully transferred prior to reading the data.

For write, when the operation has been completed or diagnosed if unsuccessful. The write is complete only when the data specified in the write request is successfully transferred and all file system information required to retrieve the data is successfully transferred.

File attributes that are not necessary for data retrieval (access time, modification time, status change time) need not be successfully transferred prior to returning to the calling process.

3.385 Synchronized I/O File Integrity Completion
Identical to a synchronized I/O data integrity completion with the addition that all file attributes relative to the I/O operation (including access time, modification time, status change time) are successfully transferred prior to returning to the calling process.

3.386 Synchronized I/O Operation
An I/O operation performed on a file that provides the application assurance of the integrity of its data and files.

3.387 Synchronous I/O Operation
An I/O operation that causes the thread requesting the I/O to be blocked from further use of the processor until that I/O operation completes.

Note:
A synchronous I/O operation does not imply synchronized I/O data integrity completion or synchronized I/O file integrity completion.
3.388 Synchronously-Generated Signal
A signal that is attributable to a specific thread.

For example, a thread executing an illegal instruction or touching invalid memory causes a synchronously-generated signal. Being synchronous is a property of how the signal was generated and not a property of the signal number.

3.389 System
An implementation of POSIX.1-2008.

3.390 System Boot
An unspecified sequence of events that may result in the loss of transitory data; that is, data that is not saved in permanent storage. For example, message queues, shared memory, semaphores, and processes.

3.391 System Clock
A clock with at least one second resolution that contains seconds since the Epoch.

3.392 System Console
A device that receives messages sent by the syslog() function, and the fmtmsg() function when the MM_CONSOLE flag is set.

Note:
The syslog() and fmtmsg() functions are defined in detail in the System Interfaces volume of POSIX.1-2008.
3.393 System Crash
An interval initiated by an unspecified circumstance that causes all processes (possibly other than special system processes) to be terminated in an undefined manner, after which any changes to the state and contents of files created or written to by an application prior to the interval are undefined, except as required elsewhere in POSIX.1-2008.

3.394 System Databases
An implementation provides two system databases: the "group database" (see also Group Database) and the "user database" (see also User Database).

3.395 System Documentation
All documentation provided with an implementation except for the conformance document. Electronically distributed documents for an implementation are considered part of the system documentation.

3.396 System Process
An object other than a process executing an application, that is provided by the system and has a process ID.

3.397 System Reboot
See System Boot defined in System Boot.

3.398 System Trace Event
A trace event that is generated by the implementation, in response either to a system-initiated action or to an application-requested action, except for a call to posix_trace_event(). When supported by the implementation, a system-initiated action generates a process-independent system trace event and an application-requested action generates a process-dependent system trace event. For a system trace event not defined by POSIX.1-2008, the associated trace event type identifier is derived from the implementation-defined name for this trace event, and the associated data is of implementation-defined content and length.

3.399 System-Wide
Pertaining to events occurring in all processes existing in an implementation at a given point in time.

3.400 Tab Character (<tab>)
A character that in the output stream indicates that printing or displaying should start at the next horizontal tabulation position on the current line. It is the character designated by '\t' in the C language. If the current position is at or past the last defined horizontal tabulation position, the behavior is unspecified. It is unspecified whether this character is the exact sequence transmitted to an output device by the system to accomplish the tabulation.

3.401 Terminal (or Terminal Device)
A character special file that obeys the specifications of the general terminal interface.

Note:
The General Terminal Interface is defined in detail in General Terminal Interface.
3.402 Text Column
A roughly rectangular block of characters capable of being laid out side-by-side next to other text columns on an output page or terminal screen. The widths of text columns are measured in column positions.

3.403 Text File
A file that contains characters organized into zero or more lines. The lines do not contain NUL characters and none can exceed {LINE_MAX} bytes in length, including the <newline> character. Although POSIX.1-2008 does not distinguish between text files and binary files (see the ISO C standard), many utilities only produce predictable or meaningful output when operating on text files. The standard utilities that have such restrictions always specify "text files" in their STDIN or INPUT FILES sections.

3.404 Thread
A single flow of control within a process. Each thread has its own thread ID, scheduling priority and policy, errno value, floating point environment, thread-specific key/value bindings, and the required system resources to support a flow of control. Anything whose address may be determined by a thread, including but not limited to static variables, storage obtained via malloc(), directly addressable storage obtained through implementation-defined functions, and automatic variables, are accessible to all threads in the same process.

Note:
The malloc() function is defined in detail in the System Interfaces volume of POSIX.1-2008.
3.405 Thread ID
Each thread in a process is uniquely identified during its lifetime by a value of type pthread_t called a thread ID.

3.406 Thread List
An ordered set of runnable threads that all have the same ordinal value for their priority.

The ordering of threads on the list is determined by a scheduling policy or policies. The set of thread lists includes all runnable threads in the system.

3.407 Thread-Safe
A thread-safe function can be safely invoked concurrently with other calls to the same function, or with calls to any other thread-safe functions, by multiple threads. Each function defined in the System Interfaces volume of POSIX.1-2008 is thread-safe unless explicitly stated otherwise. Examples are any "pure" function, a function which holds a mutex locked while it is accessing static storage, or objects shared among threads.

3.408 Thread-Specific Data Key
A process global handle of type pthread_key_t which is used for naming thread-specific data.

Although the same key value may be used by different threads, the values bound to the key by pthread_setspecific() and accessed by pthread_getspecific() are maintained on a per-thread basis and persist for the life of the calling thread.

Note:
The pthread_getspecific() and pthread_setspecific() functions are defined in detail in the System Interfaces volume of POSIX.1-2008.
3.409 Tilde Character (<tilde>)
The character ''.

3.410 Timeouts
A method of limiting the length of time an interface will block; see also Blocked Process (or Thread) .

3.411 Timer
A mechanism that can notify a thread when the time as measured by a particular clock has reached or passed a specified value, or when a specified amount of time has passed.

3.412 Timer Overrun
A condition that occurs each time a timer, for which there is already an expiration signal queued to the process, expires.

3.413 Token
In the shell command language, a sequence of characters that the shell considers as a single unit when reading input. A token is either an operator or a word.

Note:
The rules for reading input are defined in detail in XCU Token Recognition.
3.414 Trace Analyzer Process
A process that extracts trace events from a trace stream to retrieve information about the behavior of an application.

3.415 Trace Controller Process
A process that creates a trace stream for tracing a process.

3.416 Trace Event
A data object that represents an action executed by the system, and that is recorded in a trace stream.

3.417 Trace Event Type
A data object type that defines a class of trace event.

3.418 Trace Event Type Mapping
A one-to-one mapping between trace event types and trace event names.

3.419 Trace Filter
A filter that allows the trace controller process to specify those trace event types that are to be ignored; that is, not generated.

3.420 Trace Generation Version
A data object that is an implementation-defined character string, generated by the trace system and describing the origin and version of the trace system.

3.421 Trace Log
The flushed image of a trace stream, if the trace stream is created with a trace log.

3.422 Trace Point
An action that may cause a trace event to be generated.

3.423 Trace Stream
An opaque object that contains trace events plus internal data needed to interpret those trace events.

3.424 Trace Stream Identifier
A handle to manage tracing operations in a trace stream.

3.425 Trace System
A system that allows both system and user trace events to be generated into a trace stream. These trace events can be retrieved later.

3.426 Traced Process
A process for which at least one trace stream has been created. A traced process is also called a target process.

3.427 Tracing Status of a Trace Stream
A status that describes the state of an active trace stream. The tracing status of a trace stream can be retrieved from the trace stream attributes. An active trace stream can be in one of two states: running or suspended.

3.428 Typed Memory Name Space
A system-wide name space that contains the names of the typed memory objects present in the system. It is configurable for a given implementation.

3.429 Typed Memory Object
A combination of a typed memory pool and a typed memory port. The entire contents of the pool are accessible from the port. The typed memory object is identified through a name that belongs to the typed memory name space.

3.430 Typed Memory Pool
An extent of memory with the same operational characteristics. Typed memory pools may be contained within each other.

3.431 Typed Memory Port
A hardware access path to one or more typed memory pools.

3.432 Unbind
Remove the association between a network address and an endpoint.

3.433 Unit Data
See Datagram in Datagram.

3.434 Upshifting
The conversion of a lowercase character that has a single-character uppercase representation into this uppercase representation.

3.435 User Database
A system database that contains at least the following information for each user ID:

User name

Numerical user ID

Initial numerical group ID

Initial working directory

Initial user program

The initial numerical group ID is used by the newgrp utility. Any other circumstances under which the initial values are operative are implementation-defined.

If the initial user program field is null, an implementation-defined program is used.

If the initial working directory field is null, the interpretation of that field is implementation-defined.

Note:
The newgrp utility is defined in detail in the Shell and Utilities volume of POSIX.1-2008.
3.436 User ID
A non-negative integer that is used to identify a system user. When the identity of a user is associated with a process, a user ID value is referred to as a real user ID, an effective user ID, or a saved set-user-ID. The value (uid_t)-1 shall not be a valid user ID, but does have a defined use in some interfaces defined in this standard.

3.437 User Name
A string that is used to identify a user; see also User Database. To be portable across systems conforming to POSIX.1-2008, the value is composed of characters from the portable filename character set. The <hyphen-minus> character should not be used as the first character of a portable user name.

3.438 User Trace Event
A trace event that is generated explicitly by the application as a result of a call to posix_trace_event().

3.439 Utility
A program, excluding special built-in utilities provided as part of the Shell Command Language, that can be called by name from a shell to perform a specific task, or related set of tasks.

Note:
For further information on special built-in utilities, see XCU Special Built-In Utilities.
3.440 Variable
In the shell command language, a named parameter.

Note:
For further information, see XCU Parameters and Variables.
3.441 Vertical-Tab Character (<vertical-tab>)
A character that in the output stream indicates that printing should start at the next vertical tabulation position. It is the character designated by '\v' in the C language. If the current position is at or past the last defined vertical tabulation position, the behavior is unspecified. It is unspecified whether this character is the exact sequence transmitted to an output device by the system to accomplish the tabulation.

3.442 White Space
A sequence of one or more characters that belong to the space character class as defined via the LC_CTYPE category in the current locale.

In the POSIX locale, white space consists of one or more <blank> ( <space> and <tab> characters), <newline>, <carriage-return>, <form-feed>, and <vertical-tab> characters.

3.443 Wide-Character Code (C Language)
An integer value corresponding to a single graphic symbol or control code.

Note:
C Language Wide-Character Codes are defined in detail in C Language Wide-Character Codes.
3.444 Wide-Character Input/Output Functions
The functions that perform wide-oriented input from streams or wide-oriented output to streams: fgetwc(), fgetws(), fputwc(), fputws(), fwprintf(), fwscanf(), getwc(), getwchar(), putwc(), putwchar(), ungetwc(), vfwprintf(), vfwscanf(), vwprintf(), vwscanf(), wprintf(), and wscanf().

Note:
These functions are defined in detail in the System Interfaces volume of POSIX.1-2008.
3.445 Wide-Character String
A contiguous sequence of wide-character codes terminated by and including the first null wide-character code.

3.446 Word
In the shell command language, a token other than an operator. In some cases a word is also a portion of a word token: in the various forms of parameter expansion, such as ${name-word}, and variable assignment, such as name=word, the word is the portion of the token depicted by word. The concept of a word is no longer applicable following word expansions-only fields remain.

Note:
For further information, see XCU Parameter Expansion and wordexp.
3.447 Working Directory (or Current Working Directory)
A directory, associated with a process, that is used in pathname resolution for pathnames that do not begin with a <slash> character.

3.448 Worldwide Portability Interface
Functions for handling characters in a codeset-independent manner.

3.449 Write
To output characters to a file, such as standard output or standard error. Unless otherwise stated, standard output is the default output destination for all uses of the term "write''; see the distinction between display and write in Display.

3.450 XSI
The X/Open System Interfaces (XSI) option is the core application programming interface for C and sh programming for systems conforming to the Single UNIX Specification. This is a superset of the mandatory requirements for conformance to POSIX.1-2008.

3.451 XSI-Conformant
A system which allows an application to be built using a set of services that are consistent across all systems that conform to POSIX.1-2008 and that support the XSI option.

Note:
See also Conformance.
3.452 Zombie Process
The remains of a live process (see Live Process) after it terminates (see Process Termination) and before its status information (see XSH Status Information) is consumed by its parent process.

3.453 0
The algebraic sign provides additional information about any variable that has the value zero when the representation allows the sign to be determined.


<<< Previous	Home	Next >>>
The Open Group Base Specifications Issue 7
IEEE Std 1003.1-2008, 2016 Edition
Copyright  2001-2016 The IEEE and The Open Group
2. Shell Command Language
This chapter contains the definition of the Shell Command Language.

2.1 Shell Introduction
The shell is a command language interpreter. This chapter describes the syntax of that command language as it is used by the sh utility and the system() and popen() functions defined in the System Interfaces volume of POSIX.1-2008.

The shell operates according to the following general overview of operations. The specific details are included in the cited sections of this chapter.

The shell reads its input from a file (see sh), from the -c option or from the system() and popen() functions defined in the System Interfaces volume of POSIX.1-2008. If the first line of a file of shell commands starts with the characters "#!", the results are unspecified.

The shell breaks the input into tokens: words and operators; see Token Recognition.

The shell parses the input into simple commands (see Simple Commands) and compound commands (see Compound Commands).

The shell performs various expansions (separately) on different parts of each command, resulting in a list of pathnames and fields to be treated as a command and arguments; see wordexp.

The shell performs redirection (see Redirection) and removes redirection operators and their operands from the parameter list.

The shell executes a function (see Function Definition Command), built-in (see Special Built-In Utilities), executable file, or script, giving the names of the arguments as positional parameters numbered 1 to n, and the name of the command (or in the case of a function within a script, the name of the script) as the positional parameter numbered 0 (see Command Search and Execution).

The shell optionally waits for the command to complete and collects the exit status (see Exit Status for Commands).

2.2 Quoting
Quoting is used to remove the special meaning of certain characters or words to the shell. Quoting can be used to preserve the literal meaning of the special characters in the next paragraph, prevent reserved words from being recognized as such, and prevent parameter expansion and command substitution within here-document processing (see Here-Document).

The application shall quote the following characters if they are to represent themselves:

|  &  ;  <  >  (  )  $  `  \  "  '  <space>  <tab>  <newline>

and the following may need to be quoted under certain circumstances. That is, these characters may be special depending on conditions described elsewhere in this volume of POSIX.1-2008:

*   ?   [   #      =   %

The various quoting mechanisms are the escape character, single-quotes, and double-quotes. The here-document represents another form of quoting; see Here-Document.

2.2.1 Escape Character (Backslash)
A <backslash> that is not quoted shall preserve the literal value of the following character, with the exception of a <newline>. If a <newline> follows the <backslash>, the shell shall interpret this as line continuation. The <backslash> and <newline> shall be removed before splitting the input into tokens. Since the escaped <newline> is removed entirely from the input and is not replaced by any white space, it cannot serve as a token separator.

2.2.2 Single-Quotes
Enclosing characters in single-quotes ( '' ) shall preserve the literal value of each character within the single-quotes. A single-quote cannot occur within single-quotes.

2.2.3 Double-Quotes
Enclosing characters in double-quotes ( "" ) shall preserve the literal value of all characters within the double-quotes, with the exception of the characters backquote, <dollar-sign>, and <backslash>, as follows:

$
The <dollar-sign> shall retain its special meaning introducing parameter expansion (see Parameter Expansion), a form of command substitution (see Command Substitution), and arithmetic expansion (see Arithmetic Expansion).
The input characters within the quoted string that are also enclosed between "$(" and the matching ')' shall not be affected by the double-quotes, but rather shall define that command whose output replaces the "$(...)" when the word is expanded. The tokenizing rules in Token Recognition, not including the alias substitutions in Alias Substitution, shall be applied recursively to find the matching ')'.

Within the string of characters from an enclosed "${" to the matching '}', an even number of unescaped double-quotes or single-quotes, if any, shall occur. A preceding <backslash> character shall be used to escape a literal '{' or '}'. The rule in Parameter Expansion shall be used to determine the matching '}'.

`
The backquote shall retain its special meaning introducing the other form of command substitution (see Command Substitution). The portion of the quoted string from the initial backquote and the characters up to the next backquote that is not preceded by a <backslash>, having escape characters removed, defines that command whose output replaces "`...`" when the word is expanded. Either of the following cases produces undefined results:
A single-quoted or double-quoted string that begins, but does not end, within the "`...`" sequence

A "`...`" sequence that begins, but does not end, within the same double-quoted string

\
The <backslash> shall retain its special meaning as an escape character (see Escape Character (Backslash)) only when followed by one of the following characters when considered special:
$   `   "   \   <newline>

The application shall ensure that a double-quote is preceded by a <backslash> to be included within double-quotes. The parameter '@' has special meaning inside double-quotes and is described in Special Parameters .

2.3 Token Recognition
The shell shall read its input in terms of lines. (For details about how the shell reads its input, see the description of sh.) The input lines can be of unlimited length. These lines shall be parsed using two major modes: ordinary token recognition and processing of here-documents.

When an io_here token has been recognized by the grammar (see Shell Grammar), one or more of the subsequent lines immediately following the next NEWLINE token form the body of one or more here-documents and shall be parsed according to the rules of Here-Document.

When it is not processing an io_here, the shell shall break its input into tokens by applying the first applicable rule below to the next character in its input. The token shall be from the current position in the input until a token is delimited according to one of the rules below; the characters forming the token are exactly those in the input, including any quoting characters. If it is indicated that a token is delimited, and no characters have been included in a token, processing shall continue until an actual token is delimited.

If the end of input is recognized, the current token (if any) shall be delimited.

If the previous character was used as part of an operator and the current character is not quoted and can be used with the previous characters to form an operator, it shall be used as part of that (operator) token.

If the previous character was used as part of an operator and the current character cannot be used with the previous characters to form an operator, the operator containing the previous character shall be delimited.

If the current character is <backslash>, single-quote, or double-quote and it is not quoted, it shall affect quoting for subsequent characters up to the end of the quoted text. The rules for quoting are as described in Quoting . During token recognition no substitutions shall be actually performed, and the result token shall contain exactly the characters that appear in the input (except for <newline> joining), unmodified, including any embedded or enclosing quotes or substitution operators, between the <quotation-mark> and the end of the quoted text. The token shall not be delimited by the end of the quoted field.

If the current character is an unquoted '$' or '`', the shell shall identify the start of any candidates for parameter expansion (Parameter Expansion), command substitution (Command Substitution), or arithmetic expansion (Arithmetic Expansion) from their introductory unquoted character sequences: '$' or "${", "$(" or '`', and "$((", respectively. The shell shall read sufficient input to determine the end of the unit to be expanded (as explained in the cited sections). While processing the characters, if instances of expansions or quoting are found nested within the substitution, the shell shall recursively process them in the manner specified for the construct that is found. The characters found from the beginning of the substitution to its end, allowing for any recursion necessary to recognize embedded constructs, shall be included unmodified in the result token, including any embedded or enclosing substitution operators or quotes. The token shall not be delimited by the end of the substitution.

If the current character is not quoted and can be used as the first character of a new operator, the current token (if any) shall be delimited. The current character shall be used as the beginning of the next (operator) token.

If the current character is an unquoted <blank>, any token containing the previous character is delimited and the current character shall be discarded.

If the previous character was part of a word, the current character shall be appended to that word.

If the current character is a '#', it and all subsequent characters up to, but excluding, the next <newline> shall be discarded as a comment. The <newline> that ends the line is not considered part of the comment.

The current character is used as the start of a new word.

Once a token is delimited, it is categorized as required by the grammar in Shell Grammar.

2.3.1 Alias Substitution
After a token has been delimited, but before applying the grammatical rules in Shell Grammar, a resulting word that is identified to be the command name word of a simple command shall be examined to determine whether it is an unquoted, valid alias name. However, reserved words in correct grammatical context shall not be candidates for alias substitution. A valid alias name (see XBD Alias Name) shall be one that has been defined by the alias utility and not subsequently undefined using unalias. Implementations also may provide predefined valid aliases that are in effect when the shell is invoked. To prevent infinite loops in recursive aliasing, if the shell is not currently processing an alias of the same name, the word shall be replaced by the value of the alias; otherwise, it shall not be replaced.

If the value of the alias replacing the word ends in a <blank>, the shell shall check the next command word for alias substitution; this process shall continue until a word is found that is not a valid alias or an alias value does not end in a <blank>.

When used as specified by this volume of POSIX.1-2008, alias definitions shall not be inherited by separate invocations of the shell or by the utility execution environments invoked by the shell; see Shell Execution Environment.

2.4 Reserved Words
Reserved words are words that have special meaning to the shell; see Shell Commands. The following words shall be recognized as reserved words:


!
{
}
case


do
done
elif
else


esac
fi
for
if


in
then
until
while

This recognition shall only occur when none of the characters is quoted and when the word is used as:

The first word of a command

The first word following one of the reserved words other than case, for, or in

The third word in a case command (only in is valid in this case)

The third word in a for command (only in and do are valid in this case)

See the grammar in Shell Grammar.

The following words may be recognized as reserved words on some implementations (when none of the characters are quoted), causing unspecified results:

[[

]]

function

select

Words that are the concatenation of a name and a <colon> ( ':' ) are reserved; their use produces unspecified results.

2.5 Parameters and Variables
A parameter can be denoted by a name, a number, or one of the special characters listed in Special Parameters. A variable is a parameter denoted by a name.

A parameter is set if it has an assigned value (null is a valid value). Once a variable is set, it can only be unset by using the unset special built-in command.

2.5.1 Positional Parameters
A positional parameter is a parameter denoted by the decimal value represented by one or more digits, other than the single digit 0. The digits denoting the positional parameters shall always be interpreted as a decimal value, even if there is a leading zero. When a positional parameter with more than one digit is specified, the application shall enclose the digits in braces (see Parameter Expansion). Positional parameters are initially assigned when the shell is invoked (see sh), temporarily replaced when a shell function is invoked (see Function Definition Command), and can be reassigned with the set special built-in command.

2.5.2 Special Parameters
Listed below are the special parameters and the values to which they shall expand. Only the values of the special parameters are listed; see wordexp for a detailed summary of all the stages involved in expanding words.

@
Expands to the positional parameters, starting from one, initially producing one field for each positional parameter that is set. When the expansion occurs in a context where field splitting will be performed, any empty fields may be discarded and each of the non-empty fields shall be further split as described in Field Splitting. When the expansion occurs within double-quotes, the behavior is unspecified unless one of the following is true:
Field splitting as described in Field Splitting would be performed if the expansion were not within double-quotes (regardless of whether field splitting would have any effect; for example, if IFS is null).

The double-quotes are within the word of a ${parameter:-word} or a ${parameter:+word} expansion (with or without the <colon>; see Parameter Expansion) which would have been subject to field splitting if parameter had been expanded instead of word.

If one of these conditions is true, the initial fields shall be retained as separate fields, except that if the parameter being expanded was embedded within a word, the first field shall be joined with the beginning part of the original word and the last field shall be joined with the end part of the original word. In all other contexts the results of the expansion are unspecified. If there are no positional parameters, the expansion of '@' shall generate zero fields, even when '@' is within double-quotes; however, if the expansion is embedded within a word which contains one or more other parts that expand to a quoted null string, these null string(s) shall still produce an empty field, except that if the other parts are all within the same double-quotes as the '@', it is unspecified whether the result is zero fields or one empty field.

*
Expands to the positional parameters, starting from one, initially producing one field for each positional parameter that is set. When the expansion occurs in a context where field splitting will be performed, any empty fields may be discarded and each of the non-empty fields shall be further split as described in Field Splitting. When the expansion occurs in a context where field splitting will not be performed, the initial fields shall be joined to form a single field with the value of each parameter separated by the first character of the IFS variable if IFS contains at least one character, or separated by a <space> if IFS is unset, or with no separation if IFS is set to a null string.
#
Expands to the decimal number of positional parameters. The command name (parameter 0) shall not be counted in the number given by '#' because it is a special parameter, not a positional parameter.
?
Expands to the decimal exit status of the most recent pipeline (see Pipelines).
-
(Hyphen.) Expands to the current option flags (the single-letter option names concatenated into a string) as specified on invocation, by the set special built-in command, or implicitly by the shell.
$
Expands to the decimal process ID of the invoked shell. In a subshell (see Shell Execution Environment ), '$' shall expand to the same value as that of the current shell.
!
Expands to the decimal process ID of the most recent background command (see Lists) executed from the current shell. (For example, background commands executed from subshells do not affect the value of "$!" in the current shell environment.) For a pipeline, the process ID is that of the last command in the pipeline.
0
(Zero.) Expands to the name of the shell or shell script. See sh for a detailed description of how this name is derived.
See the description of the IFS variable in Shell Variables.

2.5.3 Shell Variables
Variables shall be initialized from the environment (as defined by XBD Environment Variables and the exec function in the System Interfaces volume of POSIX.1-2008) and can be given new values with variable assignment commands. If a variable is initialized from the environment, it shall be marked for export immediately; see the export special built-in. New variables can be defined and initialized with variable assignments, with the read or getopts utilities, with the name parameter in a for loop, with the ${ name= word} expansion, or with other mechanisms provided as implementation extensions.
The following variables shall affect the execution of the shell:

ENV
[UP] [Option Start] The processing of the ENV shell variable shall be supported if the system supports the User Portability Utilities option. [Option End]
This variable, when and only when an interactive shell is invoked, shall be subjected to parameter expansion (see Parameter Expansion) by the shell and the resulting value shall be used as a pathname of a file containing shell commands to execute in the current environment. The file need not be executable. If the expanded value of ENV is not an absolute pathname, the results are unspecified. ENV shall be ignored if the user's real and effective user IDs or real and effective group IDs are different.

HOME
The pathname of the user's home directory. The contents of HOME are used in tilde expansion (see Tilde Expansion).
IFS
A string treated as a list of characters that is used for field splitting, expansion of the '*' special parameter, and to split lines into fields with the read utility. If the value of IFS includes any bytes that do not form part of a valid character, the results of field splitting, expansion of '*', and use of the read utility are unspecified.
If IFS is not set, it shall behave as normal for an unset variable, except that field splitting by the shell and line splitting by the read utility shall be performed as if the value of IFS is <space> <tab> <newline>; see Field Splitting.

The shell shall set IFS to <space> <tab> <newline> when it is invoked.

LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD Internationalization Variables for the precedence of internationalization variables used to determine the values of locale categories.)
LC_ALL
The value of this variable overrides the LC_* variables and LANG, as described in XBD Environment Variables.
LC_COLLATE
Determine the behavior of range expressions, equivalence classes, and multi-character collating elements within pattern matching.
LC_CTYPE
Determine the interpretation of sequences of bytes of text data as characters (for example, single-byte as opposed to multi-byte characters), which characters are defined as letters (character class alpha) and <blank> characters (character class blank), and the behavior of character classes within pattern matching. Changing the value of LC_CTYPE after the shell has started shall not affect the lexical processing of shell commands in the current shell execution environment or its subshells. Invoking a shell script or performing exec sh subjects the new shell to the changes in LC_CTYPE.
LC_MESSAGES
Determine the language in which messages should be written.
LINENO
Set by the shell to a decimal number representing the current sequential line number (numbered starting with 1) within a script or function before it executes each command. If the user unsets or resets LINENO, the variable may lose its special meaning for the life of the shell. If the shell is not currently executing a script or function, the value of LINENO is unspecified. This volume of POSIX.1-2008 specifies the effects of the variable only for systems supporting the User Portability Utilities option.
NLSPATH
[XSI] [Option Start] Determine the location of message catalogs for the processing of LC_MESSAGES. [Option End]
PATH
A string formatted as described in XBD Environment Variables, used to effect command interpretation; see Command Search and Execution.
PPID
Set by the shell to the decimal value of its parent process ID during initialization of the shell. In a subshell (see Shell Execution Environment), PPID shall be set to the same value as that of the parent of the current shell. For example, echo $ PPID and (echo $ PPID) would produce the same value.
PS1
Each time an interactive shell is ready to read a command, the value of this variable shall be subjected to parameter expansion and written to standard error. The default value shall be "$ ". For users who have specific additional implementation-defined privileges, the default may be another, implementation-defined value. The shell shall replace each instance of the character '!' in PS1 with the history file number of the next command to be typed. Escaping the '!' with another '!' (that is, "!!" ) shall place the literal character '!' in the prompt. This volume of POSIX.1-2008 specifies the effects of the variable only for systems supporting the User Portability Utilities option.
PS2
Each time the user enters a <newline> prior to completing a command line in an interactive shell, the value of this variable shall be subjected to parameter expansion and written to standard error. The default value is "> ". This volume of POSIX.1-2008 specifies the effects of the variable only for systems supporting the User Portability Utilities option.
PS4
When an execution trace (set -x) is being performed in an interactive shell, before each line in the execution trace, the value of this variable shall be subjected to parameter expansion and written to standard error. The default value is "+ ". This volume of POSIX.1-2008 specifies the effects of the variable only for systems supporting the User Portability Utilities option.
PWD
Set by the shell and by the cd utility. In the shell the value shall be initialized from the environment as follows. If a value for PWD is passed to the shell in the environment when it is executed, the value is an absolute pathname of the current working directory that is no longer than {PATH_MAX} bytes including the terminating null byte, and the value does not contain any components that are dot or dot-dot, then the shell shall set PWD to the value from the environment. Otherwise, if a value for PWD is passed to the shell in the environment when it is executed, the value is an absolute pathname of the current working directory, and the value does not contain any components that are dot or dot-dot, then it is unspecified whether the shell sets PWD to the value from the environment or sets PWD to the pathname that would be output by pwd -P. Otherwise, the sh utility sets PWD to the pathname that would be output by pwd -P. In cases where PWD is set to the value from the environment, the value can contain components that refer to files of type symbolic link. In cases where PWD is set to the pathname that would be output by pwd -P, if there is insufficient permission on the current working directory, or on any parent of that directory, to determine what that pathname would be, the value of PWD is unspecified. Assignments to this variable may be ignored. If an application sets or unsets the value of PWD, the behaviors of the cd and pwd utilities are unspecified.
2.6 Word Expansions
This section describes the various expansions that are performed on words. Not all expansions are performed on every word, as explained in the following sections.

Tilde expansions, parameter expansions, command substitutions, arithmetic expansions, and quote removals that occur within a single word expand to a single field. It is only field splitting or pathname expansion that can create multiple fields from a single word. The single exception to this rule is the expansion of the special parameter '@' within double-quotes, as described in Special Parameters.

The order of word expansion shall be as follows:

Tilde expansion (see Tilde Expansion), parameter expansion (see Parameter Expansion), command substitution (see Command Substitution), and arithmetic expansion (see Arithmetic Expansion) shall be performed, beginning to end. See item 5 in Token Recognition.

Field splitting (see Field Splitting) shall be performed on the portions of the fields generated by step 1, unless IFS is null.

Pathname expansion (see Pathname Expansion) shall be performed, unless set -f is in effect.

Quote removal (see Quote Removal) shall always be performed last.

The expansions described in this section shall occur in the same shell environment as that in which the command is executed.

If the complete expansion appropriate for a word results in an empty field, that empty field shall be deleted from the list of fields that form the completely expanded command, unless the original word contained single-quote or double-quote characters.

The '$' character is used to introduce parameter expansion, command substitution, or arithmetic evaluation. If an unquoted '$' is followed by a character that is not one of the following:

A numeric character

The name of one of the special parameters (see Special Parameters)

A valid first character of a variable name

A <left-curly-bracket> ( '{' )

A <left-parenthesis>

the result is unspecified.

2.6.1 Tilde Expansion
A "tilde-prefix" consists of an unquoted <tilde> character at the beginning of a word, followed by all of the characters preceding the first unquoted <slash> in the word, or all the characters in the word if there is no <slash>. In an assignment (see XBD Variable Assignment), multiple tilde-prefixes can be used: at the beginning of the word (that is, following the <equals-sign> of the assignment), following any unquoted <colon>, or both. A tilde-prefix in an assignment is terminated by the first unquoted <colon> or <slash>. If none of the characters in the tilde-prefix are quoted, the characters in the tilde-prefix following the <tilde> are treated as a possible login name from the user database. A portable login name cannot contain characters outside the set given in the description of the LOGNAME environment variable in XBD Other Environment Variables. If the login name is null (that is, the tilde-prefix contains only the tilde), the tilde-prefix is replaced by the value of the variable HOME. If HOME is unset, the results are unspecified. Otherwise, the tilde-prefix shall be replaced by a pathname of the initial working directory associated with the login name obtained using the getpwnam() function as defined in the System Interfaces volume of POSIX.1-2008. If the system does not recognize the login name, the results are undefined.

The pathname resulting from tilde expansion shall be treated as if quoted to prevent it being altered by field splitting and pathname expansion.

2.6.2 Parameter Expansion
The format for parameter expansion is as follows:

${expression}

where expression consists of all characters until the matching '}'. Any '}' escaped by a <backslash> or within a quoted string, and characters in embedded arithmetic expansions, command substitutions, and variable expansions, shall not be examined in determining the matching '}'.

The simplest form for parameter expansion is:

${parameter}

The value, if any, of parameter shall be substituted.

The parameter name or symbol can be enclosed in braces, which are optional except for positional parameters with more than one digit or when parameter is a name and is followed by a character that could be interpreted as part of the name. The matching closing brace shall be determined by counting brace levels, skipping over enclosed quoted strings, and command substitutions.

If the parameter is not enclosed in braces, and is a name, the expansion shall use the longest valid name (see XBD Name), whether or not the variable represented by that name exists. Otherwise, the parameter is a single-character symbol, and behavior is unspecified if that character is neither a digit nor one of the special parameters (see Special Parameters).

If a parameter expansion occurs inside double-quotes:

Pathname expansion shall not be performed on the results of the expansion.

Field splitting shall not be performed on the results of the expansion.

In addition, a parameter expansion can be modified by using one of the following formats. In each case that a value of word is needed (based on the state of parameter, as described below), word shall be subjected to tilde expansion, parameter expansion, command substitution, and arithmetic expansion. If word is not needed, it shall not be expanded. The '}' character that delimits the following parameter expansion modifications shall be determined as described previously in this section and in Double-Quotes.

${parameter:-[word]}
Use Default Values. If parameter is unset or null, the expansion of word (or an empty string if word is omitted) shall be substituted; otherwise, the value of parameter shall be substituted.
${parameter:=[word]}
Assign Default Values. If parameter is unset or null, the expansion of word (or an empty string if word is omitted) shall be assigned to parameter. In all cases, the final value of parameter shall be substituted. Only variables, not positional parameters or special parameters, can be assigned in this way.
${parameter:?[word]}
Indicate Error if Null or Unset. If parameter is unset or null, the expansion of word (or a message indicating it is unset if word is omitted) shall be written to standard error and the shell exits with a non-zero exit status. Otherwise, the value of parameter shall be substituted. An interactive shell need not exit.
${parameter:+[word]}
Use Alternative Value. If parameter is unset or null, null shall be substituted; otherwise, the expansion of word (or an empty string if word is omitted) shall be substituted.
In the parameter expansions shown previously, use of the <colon> in the format shall result in a test for a parameter that is unset or null; omission of the <colon> shall result in a test for a parameter that is only unset. If parameter is '#' and the colon is omitted, the application shall ensure that word is specified (this is necessary to avoid ambiguity with the string length expansion). The following table summarizes the effect of the <colon>:

 

parameter
Set and Not Null

parameter
Set But Null

parameter
Unset

${parameter:-word}

substitute parameter

substitute word

substitute word

${parameter-word}

substitute parameter

substitute null

substitute word

${parameter:=word}

substitute parameter

assign word

assign word

${parameter=word}

substitute parameter

substitute null

assign word

${parameter:?word}

substitute parameter

error, exit

error, exit

${parameter?word}

substitute parameter

substitute null

error, exit

${parameter:+word}

substitute word

substitute null

substitute null

${parameter+word}

substitute word

substitute word

substitute null

In all cases shown with "substitute", the expression is replaced with the value shown. In all cases shown with "assign", parameter is assigned that value, which also replaces the expression.

${#parameter}
String Length. The length in characters of the value of parameter shall be substituted. If parameter is '*' or '@', the result of the expansion is unspecified. If parameter is unset and set -u is in effect, the expansion shall fail.
The following four varieties of parameter expansion provide for substring processing. In each case, pattern matching notation (see Pattern Matching Notation), rather than regular expression notation, shall be used to evaluate the patterns. If parameter is '#', '*', or '@', the result of the expansion is unspecified. If parameter is unset and set -u is in effect, the expansion shall fail. Enclosing the full parameter expansion string in double-quotes shall not cause the following four varieties of pattern characters to be quoted, whereas quoting characters within the braces shall have this effect. In each variety, if word is omitted, the empty pattern shall be used.

${parameter%[word]}
Remove Smallest Suffix Pattern. The word shall be expanded to produce a pattern. The parameter expansion shall then result in parameter, with the smallest portion of the suffix matched by the pattern deleted. If present, word shall not begin with an unquoted '%'.
${parameter%%[word]}
Remove Largest Suffix Pattern. The word shall be expanded to produce a pattern. The parameter expansion shall then result in parameter, with the largest portion of the suffix matched by the pattern deleted.
${parameter#[word]}
Remove Smallest Prefix Pattern. The word shall be expanded to produce a pattern. The parameter expansion shall then result in parameter, with the smallest portion of the prefix matched by the pattern deleted. If present, word shall not begin with an unquoted '#'.
${parameter##[word]}
Remove Largest Prefix Pattern. The word shall be expanded to produce a pattern. The parameter expansion shall then result in parameter, with the largest portion of the prefix matched by the pattern deleted.
The following sections are informative.
Examples
${parameter}
In this example, the effects of omitting braces are demonstrated.
a=1
set 2
echo ${a}b-$ab-${1}0-${10}-$10
1b--20--20
${parameter-word}
This example demonstrates the difference between unset and set to the empty string, as well as the rules for finding the delimiting close brace.
foo=asdf
echo ${foo-bar}xyz}
asdfxyz}foo=
echo ${foo-bar}xyz}
xyz}unset foo
echo ${foo-bar}xyz}
barxyz}
${parameter:-word}
In this example, ls is executed only if x is null or unset. (The $(ls) command substitution notation is explained in Command Substitution.)
${x:-$(ls)}

${parameter:=word}
unset X
echo ${X:=abc}
abc
${parameter:?word}
unset posix
echo ${posix:?}
sh: posix: parameter null or not set
${parameter:+word}
set a b c
echo ${3:+posix}
posix
${#parameter}
HOME=/usr/posix
echo ${#HOME}
10
${parameter%word}
x=file.c
echo ${x%.c}.o
file.o
${parameter%%word}
x=posix/src/std
echo ${x%%/*}
posix
${parameter#word}
x=$HOME/src/cmd
echo ${x#$HOME}
/src/cmd
${parameter##word}
x=/one/two/three
echo ${x##*/}
three
The double-quoting of patterns is different depending on where the double-quotes are placed:

"${x#*}"
The <asterisk> is a pattern character.
${x#"*"}
The literal <asterisk> is quoted and not special.
End of informative text.
2.6.3 Command Substitution
Command substitution allows the output of a command to be substituted in place of the command name itself. Command substitution shall occur when the command is enclosed as follows:

$(command)

or (backquoted version):

`command`

The shell shall expand the command substitution by executing command in a subshell environment (see Shell Execution Environment) and replacing the command substitution (the text of command plus the enclosing "$()" or backquotes) with the standard output of the command, removing sequences of one or more <newline> characters at the end of the substitution. Embedded <newline> characters before the end of the output shall not be removed; however, they may be treated as field delimiters and eliminated during field splitting, depending on the value of IFS and quoting that is in effect. If the output contains any null bytes, the behavior is unspecified.

Within the backquoted style of command substitution, <backslash> shall retain its literal meaning, except when followed by: '$', '`', or <backslash>. The search for the matching backquote shall be satisfied by the first unquoted non-escaped backquote; during this search, if a non-escaped backquote is encountered within a shell comment, a here-document, an embedded command substitution of the $(command) form, or a quoted string, undefined results occur. A single-quoted or double-quoted string that begins, but does not end, within the "`...`" sequence produces undefined results.

With the $(command) form, all characters following the open parenthesis to the matching closing parenthesis constitute the command. Any valid shell script can be used for command, except a script consisting solely of redirections which produces unspecified results.

The results of command substitution shall not be processed for further tilde expansion, parameter expansion, command substitution, or arithmetic expansion. If a command substitution occurs inside double-quotes, field splitting and pathname expansion shall not be performed on the results of the substitution.

Command substitution can be nested. To specify nesting within the backquoted version, the application shall precede the inner backquotes with <backslash> characters; for example:

\`command\`

The syntax of the shell command language has an ambiguity for expansions beginning with "$((", which can introduce an arithmetic expansion or a command substitution that starts with a subshell. Arithmetic expansion has precedence; that is, the shell shall first determine whether it can parse the expansion as an arithmetic expansion and shall only parse the expansion as a command substitution if it determines that it cannot parse the expansion as an arithmetic expansion. The shell need not evaluate nested expansions when performing this determination. If it encounters the end of input without already having determined that it cannot parse the expansion as an arithmetic expansion, the shell shall treat the expansion as an incomplete arithmetic expansion and report a syntax error. A conforming application shall ensure that it separates the "$(" and '(' into two tokens (that is, separate them with white space) in a command substitution that starts with a subshell. For example, a command substitution containing a single subshell could be written as:

$( (command) )

2.6.4 Arithmetic Expansion
Arithmetic expansion provides a mechanism for evaluating an arithmetic expression and substituting its value. The format for arithmetic expansion shall be as follows:

$((expression))

The expression shall be treated as if it were in double-quotes, except that a double-quote inside the expression is not treated specially. The shell shall expand all tokens in the expression for parameter expansion, command substitution, and quote removal.

Next, the shell shall treat this as an arithmetic expression and substitute the value of the expression. The arithmetic expression shall be processed according to the rules given in Arithmetic Precision and Operations, with the following exceptions:

Only signed long integer arithmetic is required.

Only the decimal-constant, octal-constant, and hexadecimal-constant constants specified in the ISO C standard, Section 6.4.4.1 are required to be recognized as constants.

The sizeof() operator and the prefix and postfix "++" and "--" operators are not required.

Selection, iteration, and jump statements are not supported.

All changes to variables in an arithmetic expression shall be in effect after the arithmetic expansion, as in the parameter expansion "${x=value}".

If the shell variable x contains a value that forms a valid integer constant, optionally including a leading <plus-sign> or <hyphen-minus>, then the arithmetic expansions "$((x))" and "$(($x))" shall return the same value.

As an extension, the shell may recognize arithmetic expressions beyond those listed. The shell may use a signed integer type with a rank larger than the rank of signed long. The shell may use a real-floating type instead of signed long as long as it does not affect the results in cases where there is no overflow. If the expression is invalid, or the contents of a shell variable used in the expression are not recognized by the shell, the expansion fails and the shell shall write a diagnostic message to standard error indicating the failure.

The following sections are informative.
Examples
A simple example using arithmetic expansion:

# repeat a command 100 times
x=100
while [ $x -gt 0 ]
do
    command    x=$(($x-1))
done

End of informative text.
2.6.5 Field Splitting
After parameter expansion (Parameter Expansion), command substitution (Command Substitution), and arithmetic expansion (Arithmetic Expansion), the shell shall scan the results of expansions and substitutions that did not occur in double-quotes for field splitting and multiple fields can result.

The shell shall treat each character of the IFS as a delimiter and use the delimiters as field terminators to split the results of parameter expansion, command substitution, and arithmetic expansion into fields.

If the value of IFS is a <space>, <tab>, and <newline>, or if it is unset, any sequence of <space>, <tab>, or <newline> characters at the beginning or end of the input shall be ignored and any sequence of those characters within the input shall delimit a field. For example, the input:

<newline><space><tab>foo<tab><tab>bar<space>

yields two fields, foo and bar.

If the value of IFS is null, no field splitting shall be performed.

Otherwise, the following rules shall be applied in sequence. The term " IFS white space" is used to mean any sequence (zero or more instances) of white-space characters that are in the IFS value (for example, if IFS contains <space>/ <comma>/ <tab>, any sequence of <space> and <tab> characters is considered IFS white space).

IFS white space shall be ignored at the beginning and end of the input.

Each occurrence in the input of an IFS character that is not IFS white space, along with any adjacent IFS white space, shall delimit a field, as described previously.

Non-zero-length IFS white space shall delimit a field.

2.6.6 Pathname Expansion
After field splitting, if set -f is not in effect, each field in the resulting command line shall be expanded using the algorithm described in Pattern Matching Notation, qualified by the rules in Patterns Used for Filename Expansion.

2.6.7 Quote Removal
The quote characters ( <backslash>, single-quote, and double-quote) that were present in the original word shall be removed unless they have themselves been quoted.

2.7 Redirection
Redirection is used to open and close files for the current shell execution environment (see Shell Execution Environment) or for any command. Redirection operators can be used with numbers representing file descriptors (see XBD File Descriptor) as described below.

The overall format used for redirection is:

[n]redir-op word
The number n is an optional decimal number designating the file descriptor number; the application shall ensure it is delimited from any preceding text and immediately precede the redirection operator redir-op. If n is quoted, the number shall not be recognized as part of the redirection expression. For example:

echo \2>a

writes the character 2 into file a. If any part of redir-op is quoted, no redirection expression is recognized. For example:

echo 2\>a

writes the characters 2>a to standard output. The optional number, redirection operator, and word shall not appear in the arguments provided to the command to be executed (if any).

Open files are represented by decimal numbers starting with zero. The largest possible value is implementation-defined; however, all implementations shall support at least 0 to 9, inclusive, for use by the application. These numbers are called "file descriptors". The values 0, 1, and 2 have special meaning and conventional uses and are implied by certain redirection operations; they are referred to as standard input, standard output, and standard error, respectively. Programs usually take their input from standard input, and write output on standard output. Error messages are usually written on standard error. The redirection operators can be preceded by one or more digits (with no intervening <blank> characters allowed) to designate the file descriptor number.

If the redirection operator is "<<" or "<<-", the word that follows the redirection operator shall be subjected to quote removal; it is unspecified whether any of the other expansions occur. For the other redirection operators, the word that follows the redirection operator shall be subjected to tilde expansion, parameter expansion, command substitution, arithmetic expansion, and quote removal. Pathname expansion shall not be performed on the word by a non-interactive shell; an interactive shell may perform it, but shall do so only when the expansion would result in one word.

If more than one redirection operator is specified with a command, the order of evaluation is from beginning to end.

A failure to open or create a file shall cause a redirection to fail.

2.7.1 Redirecting Input
Input redirection shall cause the file whose name results from the expansion of word to be opened for reading on the designated file descriptor, or standard input if the file descriptor is not specified.

The general format for redirecting input is:

[n]<word
where the optional n represents the file descriptor number. If the number is omitted, the redirection shall refer to standard input (file descriptor 0).

2.7.2 Redirecting Output
The two general formats for redirecting output are:

[n]>word
[n]>|word
where the optional n represents the file descriptor number. If the number is omitted, the redirection shall refer to standard output (file descriptor 1).

Output redirection using the '>' format shall fail if the noclobber option is set (see the description of set -C) and the file named by the expansion of word exists and is a regular file. Otherwise, redirection using the '>' or ">|" formats shall cause the file whose name results from the expansion of word to be created and opened for output on the designated file descriptor, or standard output if none is specified. If the file does not exist, it shall be created; otherwise, it shall be truncated to be an empty file after being opened.

2.7.3 Appending Redirected Output
Appended output redirection shall cause the file whose name results from the expansion of word to be opened for output on the designated file descriptor. The file is opened as if the open() function as defined in the System Interfaces volume of POSIX.1-2008 was called with the O_APPEND flag. If the file does not exist, it shall be created.

The general format for appending redirected output is as follows:

[n]>>word
where the optional n represents the file descriptor number. If the number is omitted, the redirection refers to standard output (file descriptor 1).

2.7.4 Here-Document
The redirection operators "<<" and "<<-" both allow redirection of subsequent lines read by the shell to the input of a command. The redirected lines are known as a "here-document".

The here-document shall be treated as a single word that begins after the next <newline> and continues until there is a line containing only the delimiter and a <newline>, with no <blank> characters in between. Then the next here-document starts, if there is one. The format is as follows:

[n]<<word
    here-document
delimiter
where the optional n represents the file descriptor number. If the number is omitted, the here-document refers to standard input (file descriptor 0). It is unspecified whether the file descriptor is opened as a regular file, a special file, or a pipe. Portable applications cannot rely on the file descriptor being seekable (see XSH lseek).

If any part of word is quoted, the delimiter shall be formed by performing quote removal on word, and the here-document lines shall not be expanded. Otherwise, the delimiter shall be the word itself.

If no part of word is quoted, all lines of the here-document shall be expanded for parameter expansion, command substitution, and arithmetic expansion. In this case, the <backslash> in the input behaves as the <backslash> inside double-quotes (see Double-Quotes). However, the double-quote character ( ' )' shall not be treated specially within a here-document, except when the double-quote appears within "$()", "``", or "${}".

If the redirection operator is "<<-", all leading <tab> characters shall be stripped from input lines and the line containing the trailing delimiter. If more than one "<<" or "<<-" operator is specified on a line, the here-document associated with the first operator shall be supplied first by the application and shall be read first by the shell.

When a here-document is read from a terminal device and the shell is interactive, it shall write the contents of the variable PS2, processed as described in Shell Variables, to standard error before reading each line of input until the delimiter has been recognized.

The following sections are informative.
Examples
An example of a here-document follows:

cat <<eof1; cat <<eof2
Hi,
eof1
Helene.
eof2

End of informative text.
2.7.5 Duplicating an Input File Descriptor
The redirection operator:

[n]<&word
shall duplicate one input file descriptor from another, or shall close one. If word evaluates to one or more digits, the file descriptor denoted by n, or standard input if n is not specified, shall be made to be a copy of the file descriptor denoted by word; if the digits in word do not represent a file descriptor already open for input, a redirection error shall result; see Consequences of Shell Errors. If word evaluates to '-', file descriptor n, or standard input if n is not specified, shall be closed. Attempts to close a file descriptor that is not open shall not constitute an error. If word evaluates to something else, the behavior is unspecified.

2.7.6 Duplicating an Output File Descriptor
The redirection operator:

[n]>&word
shall duplicate one output file descriptor from another, or shall close one. If word evaluates to one or more digits, the file descriptor denoted by n, or standard output if n is not specified, shall be made to be a copy of the file descriptor denoted by word; if the digits in word do not represent a file descriptor already open for output, a redirection error shall result; see Consequences of Shell Errors. If word evaluates to '-', file descriptor n, or standard output if n is not specified, is closed. Attempts to close a file descriptor that is not open shall not constitute an error. If word evaluates to something else, the behavior is unspecified.

2.7.7 Open File Descriptors for Reading and Writing
The redirection operator:

[n]<>word
shall cause the file whose name is the expansion of word to be opened for both reading and writing on the file descriptor denoted by n, or standard input if n is not specified. If the file does not exist, it shall be created.

2.8 Exit Status and Errors
2.8.1 Consequences of Shell Errors
Certain errors shall cause the shell to write a diagnostic message to standard error and exit as shown in the following table:

Error

Non-Interactive
Shell

Interactive Shell

Shell Diagnostic
Message Required

Shell language syntax error

shall exit

shall not exit

yes

Special built-in utility error

shall exit

shall not exit

no1

Other utility (not a special
built-in) error

shall not exit

shall not exit

no2

Redirection error with
special built-in utilities

shall exit

shall not exit

yes

Redirection error with
compound commands

may exit3

shall not exit

yes

Redirection error with
function execution

may exit3

shall not exit

yes

Redirection error with other
utilities (not special built-ins)

shall not exit

shall not exit

yes

Variable assignment error

shall exit

shall not exit

yes

Expansion error

shall exit

shall not exit

yes

Command not found

may exit

shall not exit

yes

Notes:
Although special built-ins are part of the shell, a diagnostic message written by a special built-in is not considered to be a shell diagnostic message, and can be redirected like any other utility.

The shell is not required to write a diagnostic message, but the utility itself shall write a diagnostic message if required to do so.

A future version of this standard may require the shell to not exit in this condition.

An expansion error is one that occurs when the shell expansions define in wordexp are carried out (for example, "${x!y}", because '!' is not a valid operator); an implementation may treat these as syntax errors if it is able to detect them during tokenization, rather than during expansion.

If any of the errors shown as "shall exit" or "may exit" occur in a subshell environment, the shell shall (respectively, may) exit from the subshell environment with a non-zero status and continue in the environment from which that subshell environment was invoked.

In all of the cases shown in the table where an interactive shell is required not to exit, the shell shall not perform any further processing of the command in which the error occurred.

2.8.2 Exit Status for Commands
Each command has an exit status that can influence the behavior of other shell commands. The exit status of commands that are not utilities is documented in this section. The exit status of the standard utilities is documented in their respective sections.

If a command is not found, the exit status shall be 127. If the command name is found, but it is not an executable utility, the exit status shall be 126. Applications that invoke utilities without using the shell should use these exit status values to report similar errors.

If a command fails during word expansion or redirection, its exit status shall be between 1 and 125 inclusive.

Internally, for purposes of deciding whether a command exits with a non-zero exit status, the shell shall recognize the entire status value retrieved for the command by the equivalent of the wait() function WEXITSTATUS macro (as defined in the System Interfaces volume of POSIX.1-2008). When reporting the exit status with the special parameter '?', the shell shall report the full eight bits of exit status available. The exit status of a command that terminated because it received a signal shall be reported as greater than 128.

2.9 Shell Commands
This section describes the basic structure of shell commands. The following command descriptions each describe a format of the command that is only used to aid the reader in recognizing the command type, and does not formally represent the syntax. In particular, the representations include spacing between tokens in some places where <blank>s would not be necessary (when one of the tokens is an operator). Each description discusses the semantics of the command; for a formal definition of the command language, consult Shell Grammar.

A command is one of the following:

Simple command (see Simple Commands)

Pipeline (see Pipelines)

List compound-list (see Lists)

Compound command (see Compound Commands)

Function definition (see Function Definition Command)

Unless otherwise stated, the exit status of a command shall be that of the last simple command executed by the command. There shall be no limit on the size of any shell command other than that imposed by the underlying system (memory constraints, {ARG_MAX}, and so on).

2.9.1 Simple Commands
A "simple command" is a sequence of optional variable assignments and redirections, in any sequence, optionally followed by words and redirections, terminated by a control operator.

When a given simple command is required to be executed (that is, when any conditional construct such as an AND-OR list or a case statement has not bypassed the simple command), the following expansions, assignments, and redirections shall all be performed from the beginning of the command text to the end:

The words that are recognized as variable assignments or redirections according to Shell Grammar Rules are saved for processing in steps 3 and 4.

The words that are not variable assignments or redirections shall be expanded. If any fields remain following their expansion, the first field shall be considered the command name and remaining fields are the arguments for the command.

Redirections shall be performed as described in Redirection.

Each variable assignment shall be expanded for tilde expansion, parameter expansion, command substitution, arithmetic expansion, and quote removal prior to assigning the value.

In the preceding list, the order of steps 3 and 4 may be reversed if no command name results from step 2 or if the command name matches the name of a special built-in utility; see Special Built-In Utilities.

Variable assignments shall be performed as follows:

If no command name results, variable assignments shall affect the current execution environment.

If the command name is not a special built-in utility or function, the variable assignments shall be exported for the execution environment of the command and shall not affect the current execution environment except as a side-effect of the expansions performed in step 4. In this case it is unspecified:

Whether or not the assignments are visible for subsequent expansions in step 4

Whether variable assignments made as side-effects of these expansions are visible for subsequent expansions in step 4, or in the current shell execution environment, or both

If the command name is a standard utility implemented as a function (see XBD Utility), the effect of variable assignments shall be as if the utility was not implemented as a function.

If the command name is a special built-in utility, variable assignments shall affect the current execution environment. Unless the set -a option is on (see set), it is unspecified:

Whether or not the variables gain the export attribute during the execution of the special built-in utility

Whether or not export attributes gained as a result of the variable assignments persist after the completion of the special built-in utility

If the command name is a function that is not a standard utility implemented as a function, variable assignments shall affect the current execution environment during the execution of the function. It is unspecified:

Whether or not the variable assignments persist after the completion of the function

Whether or not the variables gain the export attribute during the execution of the function

Whether or not export attributes gained as a result of the variable assignments persist after the completion of the function (if variable assignments persist after the completion of the function)

If any of the variable assignments attempt to assign a value to a variable for which the readonly attribute is set in the current shell environment (regardless of whether the assignment is made in that environment), a variable assignment error shall occur. See Consequences of Shell Errors for the consequences of these errors.

If there is no command name, any redirections shall be performed in a subshell environment; it is unspecified whether this subshell environment is the same one as that used for a command substitution within the command. (To affect the current execution environment, see the exec special built-in.) If any of the redirections performed in the current shell execution environment fail, the command shall immediately fail with an exit status greater than zero, and the shell shall write an error message indicating the failure. See Consequences of Shell Errors for the consequences of these failures on interactive and non-interactive shells.

If there is a command name, execution shall continue as described in Command Search and Execution . If there is no command name, but the command contained a command substitution, the command shall complete with the exit status of the last command substitution performed. Otherwise, the command shall complete with a zero exit status.

Command Search and Execution
If a simple command results in a command name and an optional list of arguments, the following actions shall be performed:

If the command name does not contain any <slash> characters, the first successful step in the following sequence shall occur:

If the command name matches the name of a special built-in utility, that special built-in utility shall be invoked.

If the command name matches the name of a utility listed in the following table, the results are unspecified.


alloc
autoload
bind
bindkey
builtin
bye
caller
cap
chdir
clone
 


comparguments
compcall
compctl
compdescribe
compfiles
compgen
compgroups
complete
compquote
comptags
 


comptry
compvalues
declare
dirs
disable
disown
dosh
echotc
echoti
help
 


history
hist
let
local
login
logout
map
mapfile
popd
print
 


pushd
readarray
repeat
savehistory
source
shopt
stop
suspend
typeset
whence
 

If the command name matches the name of a function known to this shell, the function shall be invoked as described in Function Definition Command. If the implementation has provided a standard utility in the form of a function, it shall not be recognized at this point. It shall be invoked in conjunction with the path search in step 1e.

If the command name matches the name [XSI] [Option Start]  of the type or ulimit utility, or [Option End]  of a utility listed in the following table, that utility shall be invoked.


alias
bg
cd
command
 


false
fc
fg
getopts
 


hash
jobs
kill
newgrp
 


pwd
read
true
umask
 


unalias
wait
 

Otherwise, the command shall be searched for using the PATH environment variable as described in XBD Environment Variables :

If the search is successful:

If the system has implemented the utility as a regular built-in or as a shell function, it shall be invoked at this point in the path search.

Otherwise, the shell executes the utility in a separate utility environment (see Shell Execution Environment) with actions equivalent to calling the execl() function as defined in the System Interfaces volume of POSIX.1-2008 with the path argument set to the pathname resulting from the search, arg0 set to the command name, and the remaining execl() arguments set to the command arguments (if any) and the null terminator.

If the execl() function fails due to an error equivalent to the [ENOEXEC] error defined in the System Interfaces volume of POSIX.1-2008, the shell shall execute a command equivalent to having a shell invoked with the pathname resulting from the search as its first operand, with any remaining arguments passed to the new shell, except that the value of "$0" in the new shell may be set to the command name. If the executable file is not a text file, the shell may bypass this command execution. In this case, it shall write an error message, and shall return an exit status of 126.

It is unspecified whether environment variables that were passed to the shell when it was invoked, but were not used to initialize shell variables (see Shell Variables) because they had invalid names, are included in the environment passed to execl() and (if execl() fails as described above) to the new shell.

Once a utility has been searched for and found (either as a result of this specific search or as part of an unspecified shell start-up activity), an implementation may remember its location and need not search for the utility again unless the PATH variable has been the subject of an assignment. If the remembered location fails for a subsequent invocation, the shell shall repeat the search to find the new location for the utility, if any.

If the search is unsuccessful, the command shall fail with an exit status of 127 and the shell shall write an error message.

If the command name contains at least one <slash>, the shell shall execute the utility in a separate utility environment with actions equivalent to calling the execl() function defined in the System Interfaces volume of POSIX.1-2008 with the path and arg0 arguments set to the command name, and the remaining execl() arguments set to the command arguments (if any) and the null terminator.

If the execl() function fails due to an error equivalent to the [ENOEXEC] error, the shell shall execute a command equivalent to having a shell invoked with the command name as its first operand, with any remaining arguments passed to the new shell. If the executable file is not a text file, the shell may bypass this command execution. In this case, it shall write an error message and shall return an exit status of 126.

It is unspecified whether environment variables that were passed to the shell when it was invoked, but were not used to initialize shell variables (see Shell Variables) because they had invalid names, are included in the environment passed to execl() and (if execl() fails as described above) to the new shell.

If the utility would be executed with file descriptor 0, 1, or 2 closed, implementations may execute the utility with the file descriptor open to an unspecified file. If a standard utility or a conforming application is executed with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for writing, the environment in which the utility or application is executed shall be deemed non-conforming, and consequently the utility or application might not behave as described in this standard.

2.9.2 Pipelines
A pipeline is a sequence of one or more commands separated by the control operator '|'. For each command but the last, the shell shall connect the standard output of the command to the standard input of the next command as if by creating a pipe and passing the write end of the pipe as the standard output of the command and the read end of the pipe as the standard input of the next command.

The format for a pipeline is:

[!] command1 [ | command2 ...]
If the pipeline begins with the reserved word ! and command1 is a subshell command, the application shall ensure that the ( operator at the beginning of command1 is separated from the ! by one or more <blank> characters. The behavior of the reserved word ! immediately followed by the ( operator is unspecified.

The standard output of command1 shall be connected to the standard input of command2. The standard input, standard output, or both of a command shall be considered to be assigned by the pipeline before any redirection specified by redirection operators that are part of the command (see Redirection).

If the pipeline is not in the background (see Asynchronous Lists), the shell shall wait for the last command specified in the pipeline to complete, and may also wait for all commands to complete.

Exit Status
If the pipeline does not begin with the ! reserved word, the exit status shall be the exit status of the last command specified in the pipeline. Otherwise, the exit status shall be the logical NOT of the exit status of the last command. That is, if the last command returns zero, the exit status shall be 1; if the last command returns greater than zero, the exit status shall be zero.

2.9.3 Lists
An AND-OR list is a sequence of one or more pipelines separated by the operators "&&" and "||" .

A list is a sequence of one or more AND-OR lists separated by the operators ';' and '&'.

The operators "&&" and "||" shall have equal precedence and shall be evaluated with left associativity. For example, both of the following commands write solely bar to standard output:

false && echo foo || echo bar
true || echo foo && echo bar

A ';' separator or a ';' or <newline> terminator shall cause the preceding AND-OR list to be executed sequentially; an '&' separator or terminator shall cause asynchronous execution of the preceding AND-OR list.

The term "compound-list" is derived from the grammar in Shell Grammar; it is equivalent to a sequence of lists, separated by <newline> characters, that can be preceded or followed by an arbitrary number of <newline> characters.

The following sections are informative.
Examples
The following is an example that illustrates <newline> characters in compound-lists:

while
    # a couple of <newline>s


    # a list
    date && who || ls; cat file
    # a couple of <newline>s


    # another list
    wc file > output & true


do
    # 2 lists
    ls
    cat file
done

End of informative text.
Asynchronous Lists
If a command is terminated by the control operator <ampersand> ( '&' ), the shell shall execute the command asynchronously in a subshell. This means that the shell shall not wait for the command to finish before executing the next command.

The format for running a command in the background is:

command1 & [command2 & ... ]
If job control is disabled (see set, -m), the standard input for an asynchronous list, before any explicit redirections are performed, shall be considered to be assigned to a file that has the same properties as /dev/null. This shall not happen if job control is enabled. In all cases, explicit redirection of standard input shall override this activity.

When an element of an asynchronous list (the portion of the list ended by an <ampersand>, such as command1, above) is started by the shell, the process ID of the last command in the asynchronous list element shall become known in the current shell execution environment; see Shell Execution Environment. This process ID shall remain known until:

The command terminates and the application waits for the process ID.

Another asynchronous list is invoked before "$!" (corresponding to the previous asynchronous list) is expanded in the current execution environment.

The implementation need not retain more than the {CHILD_MAX} most recent entries in its list of known process IDs in the current shell execution environment.

Exit Status
The exit status of an asynchronous list shall be zero.

Sequential Lists
Commands that are separated by a <semicolon> ( ';' ) shall be executed sequentially.

The format for executing commands sequentially shall be:

command1 [; command2] ...

Each command shall be expanded and executed in the order specified.

Exit Status
The exit status of a sequential list shall be the exit status of the last command in the list.

AND Lists
The control operator "&&" denotes an AND list. The format shall be:

command1 [ && command2] ...

First command1 shall be executed. If its exit status is zero, command2 shall be executed, and so on, until a command has a non-zero exit status or there are no more commands left to execute. The commands are expanded only if they are executed.

Exit Status
The exit status of an AND list shall be the exit status of the last command that is executed in the list.

OR Lists
The control operator "||" denotes an OR List. The format shall be:

command1 [ || command2] ...

First, command1 shall be executed. If its exit status is non-zero, command2 shall be executed, and so on, until a command has a zero exit status or there are no more commands left to execute.

Exit Status
The exit status of an OR list shall be the exit status of the last command that is executed in the list.

2.9.4 Compound Commands
The shell has several programming constructs that are "compound commands", which provide control flow for commands. Each of these compound commands has a reserved word or control operator at the beginning, and a corresponding terminator reserved word or operator at the end. In addition, each can be followed by redirections on the same line as the terminator. Each redirection shall apply to all the commands within the compound command that do not explicitly override that redirection.

Grouping Commands
The format for grouping commands is as follows:

( compound-list )
Execute compound-list in a subshell environment; see Shell Execution Environment. Variable assignments and built-in commands that affect the environment shall not remain in effect after the list finishes.
If a character sequence beginning with "((" would be parsed by the shell as an arithmetic expansion if preceded by a '$', shells which implement an extension whereby "((expression))" is evaluated as an arithmetic expression may treat the "((" as introducing as an arithmetic evaluation instead of a grouping command. A conforming application shall ensure that it separates the two leading '(' characters with white space to prevent the shell from performing an arithmetic evaluation.

{ compound-list ; }
Execute compound-list in the current process environment. The semicolon shown here is an example of a control operator delimiting the } reserved word. Other delimiters are possible, as shown in Shell Grammar; a <newline> is frequently used.
Exit Status
The exit status of a grouping command shall be the exit status of compound-list.

The for Loop
The for loop shall execute a sequence of commands for each member in a list of items. The for loop requires that the reserved words do and done be used to delimit the sequence of commands.

The format for the for loop is as follows:

for name [ in [word ... ]]
do
    compound-list
done

First, the list of words following in shall be expanded to generate a list of items. Then, the variable name shall be set to each item, in turn, and the compound-list executed each time. If no items result from the expansion, the compound-list shall not be executed. Omitting:

in word...
shall be equivalent to:

in "$@"

Exit Status
The exit status of a for command shall be the exit status of the last command that executes. If there are no items, the exit status shall be zero.

Case Conditional Construct
The conditional construct case shall execute the compound-list corresponding to the first one of several patterns (see Pattern Matching Notation) that is matched by the string resulting from the tilde expansion, parameter expansion, command substitution, arithmetic expansion, and quote removal of the given word. The reserved word in shall denote the beginning of the patterns to be matched. Multiple patterns with the same compound-list shall be delimited by the '|' symbol. The control operator ')' terminates a list of patterns corresponding to a given action. The compound-list for each list of patterns, with the possible exception of the last, shall be terminated with ";;". The case construct terminates with the reserved word esac (case reversed).
The format for the case construct is as follows:

case word in
    [(] pattern1 ) compound-list ;;
    [[(] pattern[ | pattern] ... ) compound-list ;;] ...
    [[(] pattern[ | pattern] ... ) compound-list]
esac

The ";;" is optional for the last compound-list.

In order from the beginning to the end of the case statement, each pattern that labels a compound-list shall be subjected to tilde expansion, parameter expansion, command substitution, and arithmetic expansion, and the result of these expansions shall be compared against the expansion of word, according to the rules described in Pattern Matching Notation (which also describes the effect of quoting parts of the pattern). After the first match, no more patterns shall be expanded, and the compound-list shall be executed. The order of expansion and comparison of multiple patterns that label a compound-list statement is unspecified.

Exit Status
The exit status of case shall be zero if no patterns are matched. Otherwise, the exit status shall be the exit status of the last command executed in the compound-list.

The if Conditional Construct
The if command shall execute a compound-list and use its exit status to determine whether to execute another compound-list.

The format for the if construct is as follows:

if compound-list
then
    compound-list
[elif compound-list
then
    compound-list] ...
[else
    compound-list]
fi

The if compound-list shall be executed; if its exit status is zero, the then compound-list shall be executed and the command shall complete. Otherwise, each elif compound-list shall be executed, in turn, and if its exit status is zero, the then compound-list shall be executed and the command shall complete. Otherwise, the else compound-list shall be executed.

Exit Status
The exit status of the if command shall be the exit status of the then or else compound-list that was executed, or zero, if none was executed.

The while Loop
The while loop shall continuously execute one compound-list as long as another compound-list has a zero exit status.

The format of the while loop is as follows:

while compound-list-1
do
    compound-list-2
done

The compound-list-1 shall be executed, and if it has a non-zero exit status, the while command shall complete. Otherwise, the compound-list-2 shall be executed, and the process shall repeat.

Exit Status
The exit status of the while loop shall be the exit status of the last compound-list-2 executed, or zero if none was executed.

The until Loop
The until loop shall continuously execute one compound-list as long as another compound-list has a non-zero exit status.

The format of the until loop is as follows:

until compound-list-1
do
    compound-list-2
done

The compound-list-1 shall be executed, and if it has a zero exit status, the until command completes. Otherwise, the compound-list-2 shall be executed, and the process repeats.

Exit Status
The exit status of the until loop shall be the exit status of the last compound-list-2 executed, or zero if none was executed.

2.9.5 Function Definition Command
A function is a user-defined name that is used as a simple command to call a compound command with new positional parameters. A function is defined with a "function definition command".

The format of a function definition command is as follows:

fname ( ) compound-command [io-redirect ...]
The function is named fname; the application shall ensure that it is a name (see XBD Name) and that it is not the name of a special built-in utility. An implementation may allow other characters in a function name as an extension. The implementation shall maintain separate name spaces for functions and variables.

The argument compound-command represents a compound command, as described in Compound Commands.

When the function is declared, none of the expansions in wordexp shall be performed on the text in compound-command or io-redirect; all expansions shall be performed as normal each time the function is called. Similarly, the optional io-redirect redirections and any variable assignments within compound-command shall be performed during the execution of the function itself, not the function definition. See Consequences of Shell Errors for the consequences of failures of these operations on interactive and non-interactive shells.

When a function is executed, it shall have the syntax-error properties described for special built-in utilities in the first item in the enumerated list at the beginning of Special Built-In Utilities.

The compound-command shall be executed whenever the function name is specified as the name of a simple command (see Command Search and Execution). The operands to the command temporarily shall become the positional parameters during the execution of the compound-command; the special parameter '#' also shall be changed to reflect the number of operands. The special parameter 0 shall be unchanged. When the function completes, the values of the positional parameters and the special parameter '#' shall be restored to the values they had before the function was executed. If the special built-in return (see return) is executed in the compound-command, the function completes and execution shall resume with the next command after the function call.

Exit Status
The exit status of a function definition shall be zero if the function was declared successfully; otherwise, it shall be greater than zero. The exit status of a function invocation shall be the exit status of the last command executed by the function.

2.10. Shell Grammar
The following grammar defines the Shell Command Language. This formal syntax shall take precedence over the preceding text syntax description.

2.10.1 Shell Grammar Lexical Conventions
The input language to the shell must be first recognized at the character level. The resulting tokens shall be classified by their immediate context according to the following rules (applied in order). These rules shall be used to determine what a "token" is that is subject to parsing at the token level. The rules for token recognition in Token Recognition shall apply.

If the token is an operator, the token identifier for that operator shall result.

If the string consists solely of digits and the delimiter character is one of '<' or '>', the token identifier IO_NUMBER shall be returned.

Otherwise, the token identifier TOKEN results.

Further distinction on TOKEN is context-dependent. It may be that the same TOKEN yields WORD, a NAME, an ASSIGNMENT_WORD, or one of the reserved words below, dependent upon the context. Some of the productions in the grammar below are annotated with a rule number from the following list. When a TOKEN is seen where one of those annotated productions could be used to reduce the symbol, the applicable rule shall be applied to convert the token identifier type of the TOKEN to a token identifier acceptable at that point in the grammar. The reduction shall then proceed based upon the token identifier type yielded by the rule applied. When more than one rule applies, the highest numbered rule shall apply (which in turn may refer to another rule). (Note that except in rule 7, the presence of an '=' in the token has no effect.)

The WORD tokens shall have the word expansion rules applied to them immediately before the associated command is executed, not at the time the command is parsed.

2.10.2 Shell Grammar Rules
[Command Name]

When the TOKEN is exactly a reserved word, the token identifier for that reserved word shall result. Otherwise, the token WORD shall be returned. Also, if the parser is in any state where only a reserved word could be the next correct token, proceed as above.

Note:
Because at this point <quotation-mark> characters are retained in the token, quoted strings cannot be recognized as reserved words. This rule also implies that reserved words are not recognized except in certain positions in the input, such as after a <newline> or <semicolon>; the grammar presumes that if the reserved word is intended, it is properly delimited by the user, and does not attempt to reflect that requirement directly. Also note that line joining is done before tokenization, as described in Escape Character (Backslash), so escaped <newline> characters are already removed at this point.
Rule 1 is not directly referenced in the grammar, but is referred to by other rules, or applies globally.

[Redirection to or from filename]

The expansions specified in Redirection shall occur. As specified there, exactly one field can result (or the result is unspecified), and there are additional requirements on pathname expansion.

[Redirection from here-document]

Quote removal shall be applied to the word to determine the delimiter that is used to find the end of the here-document that begins after the next <newline>.

[Case statement termination]

When the TOKEN is exactly the reserved word esac, the token identifier for esac shall result. Otherwise, the token WORD shall be returned.

[ NAME in for]

When the TOKEN meets the requirements for a name (see XBD Name ), the token identifier NAME shall result. Otherwise, the token WORD shall be returned.

[Third word of for and case]

[ case only]

When the TOKEN is exactly the reserved word in, the token identifier for in shall result. Otherwise, the token WORD shall be returned.

[ for only]

When the TOKEN is exactly the reserved word in or do, the token identifier for in or do shall result, respectively. Otherwise, the token WORD shall be returned.

(For a. and b.: As indicated in the grammar, a linebreak precedes the tokens in and do. If <newline> characters are present at the indicated location, it is the token after them that is treated in this fashion.)

[Assignment preceding command name]

[When the first word]

If the TOKEN does not contain the character '=', rule 1 is applied. Otherwise, 7b shall be applied.

[Not the first word]

If the TOKEN contains an unquoted (as determined while applying rule 4 from Token Recognition) <equals-sign> character that is not part of an embedded parameter expansion, command substitution, or arithmetic expansion construct (as determined while applying rule 5 from Token Recognition):

If the TOKEN begins with '=', then rule 1 shall be applied.

If all the characters in the TOKEN preceding the first such <equals-sign> form a valid name (see XBD Name), the token ASSIGNMENT_WORD shall be returned.

Otherwise, it is unspecified whether rule 1 is applied or ASSIGNMENT_WORD is returned.

Otherwise, rule 1 shall be applied.

Assignment to the name within a returned ASSIGNMENT_WORD token shall occur as specified in Simple Commands.

[ NAME in function]

When the TOKEN is exactly a reserved word, the token identifier for that reserved word shall result. Otherwise, when the TOKEN meets the requirements for a name, the token identifier NAME shall result. Otherwise, rule 7 applies.

[Body of function]

Word expansion and assignment shall never occur, even when required by the rules above, when this rule is being parsed. Each TOKEN that might either be expanded or have assignment applied to it shall instead be returned as a single WORD consisting only of characters that are exactly the token described in Token Recognition.


/* -------------------------------------------------------
   The grammar symbols
   ------------------------------------------------------- */
%token  WORD
%token  ASSIGNMENT_WORD
%token  NAME
%token  NEWLINE
%token  IO_NUMBER


/* The following are the operators (see XBD Operator)
   containing more than one character. */



%token  AND_IF    OR_IF    DSEMI
/*      '&&'      '||'     ';;'    */


%token  DLESS  DGREAT  LESSAND  GREATAND  LESSGREAT  DLESSDASH
/*      '<<'   '>>'    '<&'     '>&'      '<>'       '<<-'   */


%token  CLOBBER
/*      '>|'   */


/* The following are the reserved words. */


%token  If    Then    Else    Elif    Fi    Do    Done
/*      'if'  'then'  'else'  'elif'  'fi'  'do'  'done'   */


%token  Case    Esac    While    Until    For
/*      'case'  'esac'  'while'  'until'  'for'   */


/* These are reserved words, not operator tokens, and are
   recognized when reserved words are recognized. */


%token  Lbrace    Rbrace    Bang
/*      '{'       '}'       '!'   */


%token  In
/*      'in'   */


/* -------------------------------------------------------
   The Grammar
   ------------------------------------------------------- */
%start program
%%
program          : linebreak complete_commands linebreak
                 | linebreak
                 ;
complete_commands: complete_commands newline_list complete_command
                 |                                complete_command
                 ;
complete_command : list separator_op
                 | list
                 ;
list             : list separator_op and_or
                 |                   and_or
                 ;
and_or           :                         pipeline
                 | and_or AND_IF linebreak pipeline
                 | and_or OR_IF  linebreak pipeline
                 ;
pipeline         :      pipe_sequence
                 | Bang pipe_sequence
                 ;
pipe_sequence    :                             command
                 | pipe_sequence '|' linebreak command
                 ;
command          : simple_command
                 | compound_command
                 | compound_command redirect_list
                 | function_definition
                 ;
compound_command : brace_group
                 | subshell
                 | for_clause
                 | case_clause
                 | if_clause
                 | while_clause
                 | until_clause
                 ;
subshell         : '(' compound_list ')'
                 ;
compound_list    : linebreak term
                 | linebreak term separator
                 ;
term             : term separator and_or
                 |                and_or
                 ;
for_clause       : For name                                      do_group
                 | For name                       sequential_sep do_group
                 | For name linebreak in          sequential_sep do_group
                 | For name linebreak in wordlist sequential_sep do_group
                 ;
name             : NAME                     /* Apply rule 5 */
                 ;
in               : In                       /* Apply rule 6 */
                 ;
wordlist         : wordlist WORD
                 |          WORD
                 ;
case_clause      : Case WORD linebreak in linebreak case_list    Esac
                 | Case WORD linebreak in linebreak case_list_ns Esac
                 | Case WORD linebreak in linebreak              Esac
                 ;
case_list_ns     : case_list case_item_ns
                 |           case_item_ns
                 ;
case_list        : case_list case_item
                 |           case_item
                 ;
case_item_ns     :     pattern ')' linebreak
                 |     pattern ')' compound_list
                 | '(' pattern ')' linebreak
                 | '(' pattern ')' compound_list
                 ;
case_item        :     pattern ')' linebreak     DSEMI linebreak
                 |     pattern ')' compound_list DSEMI linebreak
                 | '(' pattern ')' linebreak     DSEMI linebreak
                 | '(' pattern ')' compound_list DSEMI linebreak
                 ;
pattern          :             WORD         /* Apply rule 4 */
                 | pattern '|' WORD         /* Do not apply rule 4 */
                 ;
if_clause        : If compound_list Then compound_list else_part Fi
                 | If compound_list Then compound_list           Fi
                 ;
else_part        : Elif compound_list Then compound_list
                 | Elif compound_list Then compound_list else_part
                 | Else compound_list
                 ;
while_clause     : While compound_list do_group
                 ;
until_clause     : Until compound_list do_group
                 ;
function_definition : fname '(' ')' linebreak function_body
                 ;
function_body    : compound_command                /* Apply rule 9 */
                 | compound_command redirect_list  /* Apply rule 9 */
                 ;
fname            : NAME                            /* Apply rule 8 */
                 ;
brace_group      : Lbrace compound_list Rbrace
                 ;
do_group         : Do compound_list Done           /* Apply rule 6 */
                 ;
simple_command   : cmd_prefix cmd_word cmd_suffix
                 | cmd_prefix cmd_word
                 | cmd_prefix
                 | cmd_name cmd_suffix
                 | cmd_name
                 ;
cmd_name         : WORD                   /* Apply rule 7a */
                 ;
cmd_word         : WORD                   /* Apply rule 7b */
                 ;
cmd_prefix       :            io_redirect
                 | cmd_prefix io_redirect
                 |            ASSIGNMENT_WORD
                 | cmd_prefix ASSIGNMENT_WORD
                 ;
cmd_suffix       :            io_redirect
                 | cmd_suffix io_redirect
                 |            WORD
                 | cmd_suffix WORD
                 ;
redirect_list    :               io_redirect
                 | redirect_list io_redirect
                 ;
io_redirect      :           io_file
                 | IO_NUMBER io_file
                 |           io_here
                 | IO_NUMBER io_here
                 ;
io_file          : '<'       filename
                 | LESSAND   filename
                 | '>'       filename
                 | GREATAND  filename
                 | DGREAT    filename
                 | LESSGREAT filename
                 | CLOBBER   filename
                 ;
filename         : WORD                      /* Apply rule 2 */
                 ;
io_here          : DLESS     here_end
                 | DLESSDASH here_end
                 ;
here_end         : WORD                      /* Apply rule 3 */
                 ;
newline_list     :              NEWLINE
                 | newline_list NEWLINE
                 ;
linebreak        : newline_list
                 | /* empty */
                 ;
separator_op     : '&'
                 | ';'
                 ;
separator        : separator_op linebreak
                 | newline_list
                 ;
sequential_sep   : ';' linebreak
                 | newline_list
                 ;

2.11. Signals and Error Handling
If job control is disabled (see the description of set -m) when the shell executes an asynchronous list, the commands in the list shall inherit from the shell a signal action of ignored (SIG_IGN) for the SIGINT and SIGQUIT signals. In all other cases, commands executed by the shell shall inherit the same signal actions as those inherited by the shell from its parent unless a signal action is modified by the trap special built-in (see trap)

When a signal for which a trap has been set is received while the shell is waiting for the completion of a utility executing a foreground command, the trap associated with that signal shall not be executed until after the foreground command has completed. When the shell is waiting, by means of the wait utility, for asynchronous commands to complete, the reception of a signal for which a trap has been set shall cause the wait utility to return immediately with an exit status >128, immediately after which the trap associated with that signal shall be taken.

If multiple signals are pending for the shell for which there are associated trap actions, the order of execution of trap actions is unspecified.

2.12. Shell Execution Environment
A shell execution environment consists of the following:

Open files inherited upon invocation of the shell, plus open files controlled by exec

Working directory as set by cd

File creation mask set by umask

[XSI] [Option Start] File size limit as set by ulimit [Option End]

Current traps set by trap

Shell parameters that are set by variable assignment (see the set special built-in) or from the System Interfaces volume of POSIX.1-2008 environment inherited by the shell when it begins (see the export special built-in)

Shell functions; see Function Definition Command

Options turned on at invocation or by set

Process IDs of the last commands in asynchronous lists known to this shell environment; see Asynchronous Lists

Shell aliases; see Alias Substitution

Utilities other than the special built-ins (see Special Built-In Utilities) shall be invoked in a separate environment that consists of the following. The initial value of these objects shall be the same as that for the parent shell, except as noted below.

Open files inherited on invocation of the shell, open files controlled by the exec special built-in plus any modifications, and additions specified by any redirections to the utility

Current working directory

File creation mask

If the utility is a shell script, traps caught by the shell shall be set to the default values and traps ignored by the shell shall be set to be ignored by the utility; if the utility is not a shell script, the trap actions (default or ignore) shall be mapped into the appropriate signal handling actions for the utility

Variables with the export attribute, along with those explicitly exported for the duration of the command, shall be passed to the utility environment variables

The environment of the shell process shall not be changed by the utility unless explicitly specified by the utility description (for example, cd and umask).

A subshell environment shall be created as a duplicate of the shell environment, except that signal traps that are not being ignored shall be set to the default action. Changes made to the subshell environment shall not affect the shell environment. Command substitution, commands that are grouped with parentheses, and asynchronous lists shall be executed in a subshell environment. Additionally, each command of a multi-command pipeline is in a subshell environment; as an extension, however, any or all commands in a pipeline may be executed in the current environment. All other commands shall be executed in the current shell environment.

2.13. Pattern Matching Notation
The pattern matching notation described in this section is used to specify patterns for matching strings in the shell. Historically, pattern matching notation is related to, but slightly different from, the regular expression notation described in XBD Regular Expressions. For this reason, the description of the rules for this pattern matching notation are based on the description of regular expression notation, modified to account for the differences.

2.13.1 Patterns Matching a Single Character
The following patterns matching a single character shall match a single character: ordinary characters, special pattern characters, and pattern bracket expressions. The pattern bracket expression also shall match a single collating element. A <backslash> character shall escape the following character. The escaping <backslash> shall be discarded. If a pattern ends with an unescaped <backslash>, it is unspecified whether the pattern does not match anything or the pattern is treated as invalid.

An ordinary character is a pattern that shall match itself. It can be any character in the supported character set except for NUL, those special shell characters in Quoting that require quoting, and the following three special pattern characters. Matching shall be based on the bit pattern used for encoding the character, not on the graphic representation of the character. If any character (ordinary, shell special, or pattern special) is quoted, that pattern shall match the character itself. The shell special characters always require quoting.

When unquoted and outside a bracket expression, the following three characters shall have special meaning in the specification of patterns:

?
A <question-mark> is a pattern that shall match any character.
*
An <asterisk> is a pattern that shall match multiple characters, as described in Patterns Matching Multiple Characters.
[
If an open bracket introduces a bracket expression as in XBD RE Bracket Expression, except that the <exclamation-mark> character ( '!' ) shall replace the <circumflex> character ( '^' ) in its role in a non-matching list in the regular expression notation, it shall introduce a pattern bracket expression. A bracket expression starting with an unquoted <circumflex> character produces unspecified results. Otherwise, '[' shall match the character itself.
When pattern matching is used where shell quote removal is not performed (such as in the argument to the find - name primary when find is being called using one of the exec functions as defined in the System Interfaces volume of POSIX.1-2008, or in the pattern argument to the fnmatch() function), special characters can be escaped to remove their special meaning by preceding them with a <backslash> character. This escaping <backslash> is discarded. The sequence "\\" represents one literal <backslash>. All of the requirements and effects of quoting on ordinary, shell special, and special pattern characters shall apply to escaping in this context.

2.13.2 Patterns Matching Multiple Characters
The following rules are used to construct patterns matching multiple characters from patterns matching a single character:

The <asterisk> ( '*' ) is a pattern that shall match any string, including the null string.

The concatenation of patterns matching a single character is a valid pattern that shall match the concatenation of the single characters or collating elements matched by each of the concatenated patterns.

The concatenation of one or more patterns matching a single character with one or more <asterisk> characters is a valid pattern. In such patterns, each <asterisk> shall match a string of zero or more characters, matching the greatest possible number of characters that still allows the remainder of the pattern to match the string.

2.13.3 Patterns Used for Filename Expansion
The rules described so far in Patterns Matching a Single Character and Patterns Matching Multiple Characters are qualified by the following rules that apply when pattern matching notation is used for filename expansion:

The <slash> character in a pathname shall be explicitly matched by using one or more <slash> characters in the pattern; it shall neither be matched by the <asterisk> or <question-mark> special characters nor by a bracket expression. <slash> characters in the pattern shall be identified before bracket expressions; thus, a <slash> cannot be included in a pattern bracket expression used for filename expansion. If a <slash> character is found following an unescaped <left-square-bracket> character before a corresponding <right-square-bracket> is found, the open bracket shall be treated as an ordinary character. For example, the pattern "a[b/c]d" does not match such pathnames as abd or a/d. It only matches a pathname of literally a[b/c]d.

If a filename begins with a <period> ( '.' ), the <period> shall be explicitly matched by using a <period> as the first character of the pattern or immediately following a <slash> character. The leading <period> shall not be matched by:

The <asterisk> or <question-mark> special characters

A bracket expression containing a non-matching list, such as "[!a]", a range expression, such as "[%-0]", or a character class expression, such as "[[:punct:]]"

It is unspecified whether an explicit <period> in a bracket expression matching list, such as "[.abc]", can match a leading <period> in a filename.

Specified patterns shall be matched against existing filenames and pathnames, as appropriate. Each component that contains a pattern character shall require read permission in the directory containing that component. Any component, except the last, that does not contain a pattern character shall require search permission. For example, given the pattern:

/foo/bar/x*/bam

search permission is needed for directories / and foo, search and read permissions are needed for directory bar, and search permission is needed for each x* directory. If the pattern matches any existing filenames or pathnames, the pattern shall be replaced with those filenames and pathnames, sorted according to the collating sequence in effect in the current locale. If this collating sequence does not have a total ordering of all characters (see XBD LC_COLLATE), any filenames or pathnames that collate equally should be further compared byte-by-byte using the collating sequence for the POSIX locale.

Note:
A future version of this standard may require the byte-by-byte further comparison described above.
If the pattern contains an open bracket ( '[' ) that does not introduce a bracket expression as in XBD RE Bracket Expression, it is unspecified whether other unquoted pattern matching characters within the same slash-delimited component of the pattern retain their special meanings or are treated as ordinary characters. For example, the pattern "a*[/b*" may match all filenames beginning with 'b' in the directory "a*[" or it may match all filenames beginning with 'b' in all directories with names beginning with 'a' and ending with '['.

If the pattern does not match any existing filenames or pathnames, the pattern string shall be left unchanged.

2.14. Special Built-In Utilities
The following "special built-in" utilities shall be supported in the shell command language. The output of each command, if any, shall be written to standard output, subject to the normal redirection and piping possible with all commands.

The term "built-in" implies that the shell can execute the utility directly and does not need to search for it. An implementation may choose to make any utility a built-in; however, the special built-in utilities described here differ from regular built-in utilities in two respects:

An error in a special built-in utility may cause a shell executing that utility to abort, while an error in a regular built-in utility shall not cause a shell executing that utility to abort. (See Consequences of Shell Errors for the consequences of errors on interactive and non-interactive shells.) If a special built-in utility encountering an error does not abort the shell, its exit value shall be non-zero.

As described in Simple Commands, variable assignments preceding the invocation of a special built-in utility remain in effect after the built-in completes; this shall not be the case with a regular built-in or other utility.

The special built-in utilities in this section need not be provided in a manner accessible via the exec family of functions defined in the System Interfaces volume of POSIX.1-2008.

Some of the special built-ins are described as conforming to XBD Utility Syntax Guidelines. For those that are not, the requirement in Utility Description Defaults that "--" be recognized as a first argument to be discarded does not apply and a conforming application shall not use that argument.

<<< Previous	Home	Next >>>
 

return to top of page
UNIX  is a registered Trademark of The Open Group.
POSIX  is a registered Trademark of The IEEE.
Copyright  2001-2016 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT ]
NAME
break - exit from for, while, or until loop
SYNOPSIS
break [n]

DESCRIPTION
If n is specified, the break utility shall exit from the nth enclosing for, while, or until loop. If n is not specified, break shall behave as if n was specified as 1. Execution shall continue with the command immediately following the exited loop. The value of n is a positive decimal integer. If n is greater than the number of enclosing loops, the outermost enclosing loop shall be exited. If there is no enclosing loop, the behavior is unspecified.

A loop shall enclose a break or continue command if the loop lexically encloses the command. A loop lexically encloses a break or continue command if the command is:

Executing in the same execution environment (see Shell Execution Environment) as the compound-list of the loop's do-group (see Shell Grammar Rules), and

Contained in a compound-list associated with the loop (either in the compound-list of the loop's do-group or, if the loop is a while or until loop, in the compound-list following the while or until reserved word), and

Not in the body of a function whose function definition command (see Function Definition Command) is contained in a compound-list associated with the loop.

If n is greater than the number of lexically enclosing loops and there is a non-lexically enclosing loop in progress in the same execution environment as the break or continue command, it is unspecified whether that loop encloses the command.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
Successful completion.
>0
The n value was not an unsigned decimal integer greater than or equal to 1.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
for i in *
do
    if test -d "$i"
    then break
    fi
done

The results of running the following example are unspecified: there are two loops in progress when the break command is executed, and they are in the same execution environment, but neither loop is lexically enclosing the break command. (There are no loops lexically enclosing the continue commands, either.)

foo() {
    for j in 1 2; do
        echo 'break 2' >/tmp/do_break
        echo "  sourcing /tmp/do_break ($j)..."
        # the behavior of the break from running the following command
        # results in unspecified behavior:
        . /tmp/do_break


        do_continue() { continue 2; }
        echo "  running do_continue ($j)..."
        # the behavior of the continue in the following function call
        # results in unspecified behavior (if execution reaches this
        # point):
        do_continue


        trap 'continue 2' USR1
        echo "  sending SIGUSR1 to self ($j)..."
        # the behavior of the continue in the trap invoked from the
        # following signal results in unspecified behavior (if
        # execution reaches this point):
        kill -s USR1 $$
        sleep 1
    done
}
for i in 1 2; do
    echo "running foo ($i)..."
    foo
done

RATIONALE
In early proposals, consideration was given to expanding the syntax of break and continue to refer to a label associated with the appropriate loop as a preferable alternative to the n method. However, this volume of POSIX.1-2008 does reserve the name space of command names ending with a <colon>. It is anticipated that a future implementation could take advantage of this and provide something like:

outofloop: for i in a b c d e
do
    for j in 0 1 2 3 4 5 6 7 8 9
    do
        if test -r "${i}${j}"
        then break outofloop
        fi
    done
done

and that this might be standardized after implementation experience is achieved.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0046 [842] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
colon - null utility
SYNOPSIS
: [argument...]

DESCRIPTION
This utility shall only expand command arguments. It is used when a command is needed, as in the then condition of an if command, but nothing is to be done by the command.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
Zero.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
: ${X=abc}
if     false
then   :
else   echo $X
fi
abc

As with any of the special built-ins, the null utility can also have variable assignments and redirections associated with it, such as:

x=y : > z

which sets variable x to the value y (so that it persists after the null utility completes) and creates or truncates file z.

RATIONALE
None.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

End of informative text.
<<< Previous	Home	Next >>>
NAME
continue - continue for, while, or until loop
SYNOPSIS
continue [n]

DESCRIPTION
If n is specified, the continue utility shall return to the top of the nth enclosing for, while, or until loop. If n is not specified, continue shall behave as if n was specified as 1. Returning to the top of the loop involves repeating the condition list of a while or until loop or performing the next assignment of a for loop, and re-executing the loop if appropriate.

The value of n is a positive decimal integer. If n is greater than the number of enclosing loops, the outermost enclosing loop shall be used. If there is no enclosing loop, the behavior is unspecified.

The meaning of "enclosing" shall be as specified in the description of the break utility.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
Successful completion.
>0
The n value was not an unsigned decimal integer greater than or equal to 1.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
for i in *
do
    if test -d "$i"
    then continue
    fi
    printf '"%s" is not a directory.\n' "$i"
done

RATIONALE
None.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
The example is changed to use the printf utility rather than echo.

POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0046 [842] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
dot - execute commands in the current environment
SYNOPSIS
. file

DESCRIPTION
The shell shall execute commands from the file in the current environment.

If file does not contain a <slash>, the shell shall use the search path specified by PATH to find the directory containing file. Unlike normal command search, however, the file searched for by the dot utility need not be executable. If no readable file is found, a non-interactive shell shall abort; an interactive shell shall write a diagnostic message to standard error, but this condition shall not be considered a syntax error.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
See the DESCRIPTION.

ENVIRONMENT VARIABLES
See the DESCRIPTION.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
If no readable file was found or if the commands in the file could not be parsed, and the shell is interactive (and therefore does not abort; see Consequences of Shell Errors), the exit status shall be non-zero. Otherwise, return the value of the last command executed, or a zero exit status if no command is executed.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
cat foobar
foo=hello bar=world
. ./foobar
echo $foo $bar
hello world

RATIONALE
Some older implementations searched the current directory for the file, even if the value of PATH disallowed it. This behavior was omitted from this volume of POSIX.1-2008 due to concerns about introducing the susceptibility to trojan horses that the user might be trying to avoid by leaving dot out of PATH.

The KornShell version of dot takes optional arguments that are set to the positional parameters. This is a valid extension that allows a dot script to behave identically to a function.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities, return

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-164 is applied.

POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0038 [114] and XCU/TC1-2008/0039 [214] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
eval - construct command by concatenating arguments
SYNOPSIS
eval [argument...]

DESCRIPTION
The eval utility shall construct a command by concatenating arguments together, separating each with a <space> character. The constructed command shall be read and executed by the shell.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
If there are no arguments, or only null arguments, eval shall return a zero exit status; otherwise, it shall return the exit status of the command defined by the string of concatenated arguments separated by <space> characters, or a non-zero exit status if the concatenation could not be parsed as a command and the shell is interactive (and therefore did not abort).

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
Since eval is not required to recognize the "--" end of options delimiter, in cases where the argument(s) to eval might begin with '-' it is recommended that the first argument is prefixed by a string that will not alter the commands to be executed, such as a <space> character:

eval " $commands"

or:

eval " $(some_command)"

EXAMPLES
foo=10 x=foo
y='$'$x
echo $y
$foo
eval y='$'$x
echo $y
10

RATIONALE
This standard allows, but does not require, eval to recognize "--". Although this means applications cannot use "--" to protect against options supported as an extension (or errors reported for unsupported options), the nature of the eval utility is such that other means can be used to provide this protection (see APPLICATION USAGE above).

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0040 [114], XCU/TC1-2008/0041 [163], and XCU/TC1-2008/0042 [163] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
exec - execute commands and open, close, or copy file descriptors
SYNOPSIS
exec [command [argument...]]

DESCRIPTION
The exec utility shall open, close, and/or copy file descriptors as specified by any redirections as part of the command.

If exec is specified without command or arguments, and any file descriptors with numbers greater than 2 are opened with associated redirection statements, it is unspecified whether those file descriptors remain open when the shell invokes another utility. Scripts concerned that child shells could misuse open file descriptors can always close them explicitly, as shown in one of the following examples.

If exec is specified with command, it shall replace the shell with command without creating a new process. If arguments are specified, they shall be arguments to command. Redirection affects the current shell execution environment.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
If command is specified, exec shall not return to the shell; rather, the exit status of the process shall be the exit status of the program implementing command, which overlaid the shell. If command is not found, the exit status shall be 127. If command is found, but it is not an executable utility, the exit status shall be 126. If a redirection error occurs (see Consequences of Shell Errors), the shell shall exit with a value in the range 1-125. Otherwise, exec shall return a zero exit status.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
Open readfile as file descriptor 3 for reading:

exec 3< readfile

Open writefile as file descriptor 4 for writing:

exec 4> writefile

Make file descriptor 5 a copy of file descriptor 0:

exec 5<&0

Close file descriptor 3:

exec 3<&-

Cat the file maggie by replacing the current shell with the cat utility:

exec cat maggie

RATIONALE
Most historical implementations were not conformant in that:

foo=bar exec cmd

did not pass foo to cmd.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

End of informative text.
<<< Previous	Home	Next >>>
NAME
exit - cause the shell to exit
SYNOPSIS
exit [n]

DESCRIPTION
The exit utility shall cause the shell to exit from its current execution environment with the exit status specified by the unsigned decimal integer n. If the current execution environment is a subshell environment, the shell shall exit from the subshell environment with the specified exit status and continue in the environment from which that subshell environment was invoked; otherwise, the shell utility shall terminate with the specified exit status. If n is specified, but its value is not between 0 and 255 inclusively, the exit status is undefined.

A trap on EXIT shall be executed before the shell terminates, except when the exit utility is invoked in that trap itself, in which case the shell shall exit immediately.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
The exit status shall be n, if specified, except that the behavior is unspecified if n is not an unsigned decimal integer or is greater than 255. Otherwise, the value shall be the exit value of the last command executed, or zero if no command was executed. When exit is executed in a trap action, the last command is considered to be the command that executed immediately preceding the trap action.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
Exit with a true value:

exit 0

Exit with a false value:

exit 1

Propagate error handling from within a subshell:

(
    command1 || exit 1
    command2 || exit 1
    exec command3
) > outputfile || exit 1
echo "outputfile created successfully"

RATIONALE
As explained in other sections, certain exit status values have been reserved for special uses and should be used by applications only for those purposes:

 126
A file to be executed was found, but it was not an executable utility.
 127
A utility to be executed was not found.
>128
A command was interrupted by a signal.
The behavior of exit when given an invalid argument or unknown option is unspecified, because of differing practices in the various historical implementations. A value larger than 255 might be truncated by the shell, and be unavailable even to a parent process that uses waitid() to get the full exit value. It is recommended that implementations that detect any usage error should cause a non-zero exit status (or, if the shell is interactive and the error does not cause the shell to abort, store a non-zero value in "$?" ), but even this was not done historically in all shells.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0047 [717], XCU/TC2-2008/0048 [960], XCU/TC2-2008/0049 [717], and XCU/TC2-2008/0050 [960] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
export - set the export attribute for variables
SYNOPSIS
export name[=word]...
 
export -p

DESCRIPTION
The shell shall give the export attribute to the variables corresponding to the specified names, which shall cause them to be in the environment of subsequently executed commands. If the name of a variable is followed by = word, then the value of that variable shall be set to word.

The export special built-in shall support XBD Utility Syntax Guidelines.

When -p is specified, export shall write to the standard output the names and values of all exported variables, in the following format:

"export %s=%s\n", <name>, <value>

if name is set, and:

"export %s\n", <name>

if name is unset.

The shell shall format the output, including the proper use of quoting, so that it is suitable for reinput to the shell as commands that achieve the same exporting results, except:

Read-only variables with values cannot be reset.

Variables that were unset at the time they were output need not be reset to the unset state if a value is assigned to the variable between the time the state was saved and the time at which the saved output is reinput to the shell.

When no arguments are given, the results are unspecified.

OPTIONS
See the DESCRIPTION.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
See the DESCRIPTION.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
All name operands were successfully exported.
>0
At least one name could not be exported, or the -p option was specified and an error occurred.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
Note that, unless X was previously marked readonly, the value of "$?" after:

export X=$(false)

will be 0 (because export successfully set X to the empty string) and that execution continues, even if set -e is in effect. In order to detect command substitution failures, a user must separate the assignment from the export, as in:

X=$(false)
export X

EXAMPLES
Export PWD and HOME variables:

export PWD HOME

Set and export the PATH variable:

export PATH=/local/bin:$PATH

Save and restore all exported variables:

export -p > temp-file
unset a lot of variables
... processing
. temp-file

RATIONALE
Some historical shells use the no-argument case as the functional equivalent of what is required here with -p. This feature was left unspecified because it is not historical practice in all shells, and some scripts may rely on the now-unspecified results on their implementations. Attempts to specify the -p output as the default case were unsuccessful in achieving consensus. The -p option was added to allow portable access to the values that can be saved and then later restored using; for example, a dot script.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

XBD Utility Syntax Guidelines

CHANGE HISTORY
Issue 6
IEEE PASC Interpretation 1003.2 #203 is applied, clarifying the format when a variable is unset.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/6 is applied, adding the following text to the end of the first paragraph of the DESCRIPTION: "If the name of a variable is followed by = word, then the value of that variable shall be set to word.". The reason for this change is that the SYNOPSIS for export includes:

export name[=word]...

but the meaning of the optional "= word" is never explained in the text.

Issue 7
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0043 [352] is applied.

POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0051 [654] and XCU/TC2-2008/0052 [960] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
readonly - set the readonly attribute for variables
SYNOPSIS
readonly name[=word]...
 
readonly -p

DESCRIPTION
The variables whose names are specified shall be given the readonly attribute. The values of variables with the readonly attribute cannot be changed by subsequent assignment, nor can those variables be unset by the unset utility. If the name of a variable is followed by = word, then the value of that variable shall be set to word.

The readonly special built-in shall support XBD Utility Syntax Guidelines.

When -p is specified, readonly writes to the standard output the names and values of all read-only variables, in the following format:

"readonly %s=%s\n", <name>, <value>

if name is set, and

"readonly %s\n", <name>

if name is unset.

The shell shall format the output, including the proper use of quoting, so that it is suitable for reinput to the shell as commands that achieve the same value and readonly attribute-setting results in a shell execution environment in which:

Variables with values at the time they were output do not have the readonly attribute set.

Variables that were unset at the time they were output do not have a value at the time at which the saved output is reinput to the shell.

When no arguments are given, the results are unspecified.

OPTIONS
See the DESCRIPTION.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
See the DESCRIPTION.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
All name operands were successfully marked readonly.
>0
At least one name could not be marked readonly, or the -p option was specified and an error occurred.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
readonly HOME PWD

RATIONALE
Some historical shells preserve the readonly attribute across separate invocations. This volume of POSIX.1-2008 allows this behavior, but does not require it.

The -p option allows portable access to the values that can be saved and then later restored using, for example, a dot script. Also see the RATIONALE for export for a description of the no-argument and -p output cases and a related example.

Read-only functions were considered, but they were omitted as not being historical practice or particularly useful. Furthermore, functions must not be read-only across invocations to preclude "spoofing" (spoofing is the term for the practice of creating a program that acts like a well-known utility with the intent of subverting the real intent of the user) of administrative or security-relevant (or security-conscious) shell scripts.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

XBD Utility Syntax Guidelines

CHANGE HISTORY
Issue 6
IEEE PASC Interpretation 1003.2 #203 is applied, clarifying the format when a variable is unset.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/7 is applied, adding the following text to the end of the first paragraph of the DESCRIPTION: "If the name of a variable is followed by = word, then the value of that variable shall be set to word.". The reason for this change is that the SYNOPSIS for readonly includes:
readonly name[=word]...

but the meaning of the optional "= word" is never explained in the text.

Issue 7
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0052 [960] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
return - return from a function or dot script
SYNOPSIS
return [n]

DESCRIPTION
The return utility shall cause the shell to stop executing the current function or dot script. If the shell is not currently executing a function or dot script, the results are unspecified.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
The value of the special parameter '?' shall be set to n, an unsigned decimal integer, or to the exit status of the last command executed if n is not specified. If n is not an unsigned decimal integer, or is greater than 255, the results are unspecified. When return is executed in a trap action, the last command is considered to be the command that executed immediately preceding the trap action.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
None.

RATIONALE
The behavior of return when not in a function or dot script differs between the System V shell and the KornShell. In the System V shell this is an error, whereas in the KornShell, the effect is the same as exit.

The results of returning a number greater than 255 are undefined because of differing practices in the various historical implementations. Some shells AND out all but the low-order 8 bits; others allow larger values, but not of unlimited size.

See the discussion of appropriate exit status values under exit.

FUTURE DIRECTIONS
None.

SEE ALSO
Function Definition Command, Special Built-In Utilities, dot

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0044 [214] and XCU/TC1-2008/0045 [214] are applied.

POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0052 [960] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
set - set or unset options and positional parameters
SYNOPSIS
set [-abCefhmnuvx] [-o option] [argument...]
 
set [+abCefhmnuvx] [+o option] [argument...]
 
set -- [argument...]
 
set -o
 
set +o

DESCRIPTION
If no options or arguments are specified, set shall write the names and values of all shell variables in the collation sequence of the current locale. Each name shall start on a separate line, using the format:

"%s=%s\n", <name>, <value>

The value string shall be written with appropriate quoting; see the description of shell quoting in Quoting. The output shall be suitable for reinput to the shell, setting or resetting, as far as possible, the variables that are currently set; read-only variables cannot be reset.

When options are specified, they shall set or unset attributes of the shell, as described below. When arguments are specified, they cause positional parameters to be set or unset, as described below. Setting or unsetting attributes and positional parameters are not necessarily related actions, but they can be combined in a single invocation of set.

The set special built-in shall support XBD Utility Syntax Guidelines except that options can be specified with either a leading <hyphen-minus> (meaning enable the option) or <plus-sign> (meaning disable it) unless otherwise specified.

Implementations shall support the options in the following list in both their <hyphen-minus> and <plus-sign> forms. These options can also be specified as options to sh.

-a
When this option is on, the export attribute shall be set for each variable to which an assignment is performed; see XBD Variable Assignment. If the assignment precedes a utility name in a command, the export attribute shall not persist in the current execution environment after the utility completes, with the exception that preceding one of the special built-in utilities causes the export attribute to persist after the built-in has completed. If the assignment does not precede a utility name in the command, or if the assignment is a result of the operation of the getopts or read utilities, the export attribute shall persist until the variable is unset.
-b
This option shall be supported if the implementation supports the User Portability Utilities option. It shall cause the shell to notify the user asynchronously of background job completions. The following message is written to standard error:
"[%d]%c %s%s\n", <job-number>, <current>, <status>, <job-name>

where the fields shall be as follows:

<current>
The character '+' identifies the job that would be used as a default for the fg or bg utilities; this job can also be specified using the job_id "%+" or "%%". The character '-' identifies the job that would become the default if the current default job were to exit; this job can also be specified using the job_id "%-". For other jobs, this field is a <space>. At most one job can be identified with '+' and at most one job can be identified with '-'. If there is any suspended job, then the current job shall be a suspended job. If there are at least two suspended jobs, then the previous job also shall be a suspended job.
<job-number>
A number that can be used to identify the process group to the wait, fg, bg, and kill utilities. Using these utilities, the job can be identified by prefixing the job number with '%'.
<status>
Unspecified.
<job-name>
Unspecified.
When the shell notifies the user a job has been completed, it may remove the job's process ID from the list of those known in the current shell execution environment; see Asynchronous Lists. Asynchronous notification shall not be enabled by default.

-C
(Uppercase C.) Prevent existing files from being overwritten by the shell's '>' redirection operator (see Redirecting Output); the ">|" redirection operator shall override this noclobber option for an individual file.
-e
When this option is on, when any command fails (for any of the reasons listed in Consequences of Shell Errors or by returning an exit status greater than zero), the shell immediately shall exit, as if by executing the exit special built-in utility with no arguments, with the following exceptions:
The failure of any individual command in a multi-command pipeline shall not cause the shell to exit. Only the failure of the pipeline itself shall be considered.

The -e setting shall be ignored when executing the compound list following the while, until, if, or elif reserved word, a pipeline beginning with the ! reserved word, or any command of an AND-OR list other than the last.

If the exit status of a compound command other than a subshell command was the result of a failure while -e was being ignored, then -e shall not apply to this command.

This requirement applies to the shell environment and each subshell environment separately. For example, in:

set -e; (false; echo one) | cat; echo two

the false command causes the subshell to exit without executing echo one; however, echo two is executed because the exit status of the pipeline (false; echo one) | cat is zero.

-f
The shell shall disable pathname expansion.
-h
Locate and remember utilities invoked by functions as those functions are defined (the utilities are normally located when the function is executed).
-m
This option shall be supported if the implementation supports the User Portability Utilities option. All jobs shall be run in their own process groups. Immediately before the shell issues a prompt after completion of the background job, a message reporting the exit status of the background job shall be written to standard error. If a foreground job stops, the shell shall write a message to standard error to that effect, formatted as described by the jobs utility. In addition, if a job changes status other than exiting (for example, if it stops for input or output or is stopped by a SIGSTOP signal), the shell shall write a similar message immediately prior to writing the next prompt. This option is enabled by default for interactive shells.
-n
The shell shall read commands but does not execute them; this can be used to check for shell script syntax errors. An interactive shell may ignore this option.
-o
Write the current settings of the options to standard output in an unspecified format.
+o
Write the current option settings to standard output in a format that is suitable for reinput to the shell as commands that achieve the same options settings.
-o  option
This option is supported if the system supports the User Portability Utilities option. It shall set various options, many of which shall be equivalent to the single option letters. The following values of option shall be supported:
allexport
Equivalent to -a.
errexit
Equivalent to -e.
ignoreeof
Prevent an interactive shell from exiting on end-of-file. This setting prevents accidental logouts when <control>-D is entered. A user shall explicitly exit to leave the interactive shell.
monitor
Equivalent to -m. This option is supported if the system supports the User Portability Utilities option.
noclobber
Equivalent to -C (uppercase C).
noglob
Equivalent to -f.
noexec
Equivalent to -n.
nolog
Prevent the entry of function definitions into the command history; see Command History List.
notify
Equivalent to -b.
nounset
Equivalent to -u.
verbose
Equivalent to -v.
vi
Allow shell command line editing using the built-in vi editor. Enabling vi mode shall disable any other command line editing mode provided as an implementation extension.
It need not be possible to set vi mode on for certain block-mode terminals.

xtrace
Equivalent to -x.
-u
When the shell tries to expand an unset parameter other than the '@' and '*' special parameters, it shall write a message to standard error and the expansion shall fail with the consequences specified in Consequences of Shell Errors.
-v
The shell shall write its input to standard error as it is read.
-x
The shell shall write to standard error a trace for each command after it expands the command and before it executes it. It is unspecified whether the command that turns tracing off is traced.
The default for all these options shall be off (unset) unless stated otherwise in the description of the option or unless the shell was invoked with them on; see sh.

The remaining arguments shall be assigned in order to the positional parameters. The special parameter '#' shall be set to reflect the number of positional parameters. All positional parameters shall be unset before any new values are assigned.

If the first argument is '-', the results are unspecified.

The special argument "--" immediately following the set command name can be used to delimit the arguments if the first argument begins with '+' or '-', or to prevent inadvertent listing of all shell variables when there are no arguments. The command set -- without argument shall unset all positional parameters and set the special parameter '#' to zero.

OPTIONS
See the DESCRIPTION.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
See the DESCRIPTION.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
Successful completion.
>0
An invalid option was specified, or an error occurred.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
Application writers should avoid relying on set -e within functions. For example, in the following script:

set -e
start() {
    some_server
    echo some_server started successfully
}
start || echo >&2 some_server failed

the -e setting is ignored within the function body (because the function is a command in an AND-OR list other than the last). Therefore, if some_server fails, the function carries on to echo "some_server started successfully", and the exit status of the function is zero (which means "some_server failed" is not output).

EXAMPLES
Write out all variables and their values:

set

Set $1, $2, and $3 and set "$#" to 3:

set c a b

Turn on the -x and -v options:

set -xv

Unset all positional parameters:

set --

Set $1 to the value of x, even if it begins with '-' or '+' :

set -- "$x"

Set the positional parameters to the expansion of x, even if x expands with a leading '-' or '+' :

set -- $x

RATIONALE
The set -- form is listed specifically in the SYNOPSIS even though this usage is implied by the Utility Syntax Guidelines. The explanation of this feature removes any ambiguity about whether the set -- form might be misinterpreted as being equivalent to set without any options or arguments. The functionality of this form has been adopted from the KornShell. In System V, set -- only unsets parameters if there is at least one argument; the only way to unset all parameters is to use shift. Using the KornShell version should not affect System V scripts because there should be no reason to issue it without arguments deliberately; if it were issued as, for example:

set -- "$@"

and there were in fact no arguments resulting from "$@", unsetting the parameters would have no result.

The set + form in early proposals was omitted as being an unnecessary duplication of set alone and not widespread historical practice.

The noclobber option was changed to allow set -C as well as the set -o noclobber option. The single-letter version was added so that the historical "$-" paradigm would not be broken; see Special Parameters.

The description of the -e option is intended to match the behavior of the 1988 version of the KornShell.

The -h flag is related to command name hashing. See hash.

The following set flags were omitted intentionally with the following rationale:

-k
The -k flag was originally added by the author of the Bourne shell to make it easier for users of pre-release versions of the shell. In early versions of the Bourne shell the construct set name= value had to be used to assign values to shell variables. The problem with -k is that the behavior affects parsing, virtually precluding writing any compilers. To explain the behavior of -k, it is necessary to describe the parsing algorithm, which is implementation-defined. For example:
set -k; echo name=value
and:

set -k
echo name=value
behave differently. The interaction with functions is even more complex. What is more, the -k flag is never needed, since the command line could have been reordered.

-t
The -t flag is hard to specify and almost never used. The only known use could be done with here-documents. Moreover, the behavior with ksh and sh differs. The reference page says that it exits after reading and executing one command. What is one command? If the input is date; date, sh executes both date commands while ksh does only the first.
Consideration was given to rewriting set to simplify its confusing syntax. A specific suggestion was that the unset utility should be used to unset options instead of using the non- getopt() -able + option syntax. However, the conclusion was reached that the historical practice of using + option was satisfactory and that there was no compelling reason to modify such widespread historical practice.

The -o option was adopted from the KornShell to address user needs. In addition to its generally friendly interface, -o is needed to provide the vi command line editing mode, for which historical practice yields no single-letter option name. (Although it might have been possible to invent such a letter, it was recognized that other editing modes would be developed and -o provides ample name space for describing such extensions.)

Historical implementations are inconsistent in the format used for -o option status reporting. The +o format without an option-argument was added to allow portable access to the options that can be saved and then later restored using, for instance, a dot script.

Historically, sh did trace the command set +x, but ksh did not.

The ignoreeof setting prevents accidental logouts when the end-of-file character (typically <control>-D) is entered. A user shall explicitly exit to leave the interactive shell.

The set -m option was added to apply only to the UPE because it applies primarily to interactive use, not shell script applications.

The ability to do asynchronous notification became available in the 1988 version of the KornShell. To have it occur, the user had to issue the command:

trap "jobs -n" CLD

The C shell provides two different levels of an asynchronous notification capability. The environment variable notify is analogous to what is done in set -b or set -o notify. When set, it notifies the user immediately of background job completions. When unset, this capability is turned off.

The other notification ability comes through the built-in utility notify. The syntax is:

notify [%job ... ]
By issuing notify with no operands, it causes the C shell to notify the user asynchronously when the state of the current job changes. If given operands, notify asynchronously informs the user of changes in the states of the specified jobs.

To add asynchronous notification to the POSIX shell, neither the KornShell extensions to trap, nor the C shell notify environment variable seemed appropriate (notify is not a proper POSIX environment variable name).

The set -b option was selected as a compromise.

The notify built-in was considered to have more functionality than was required for simple asynchronous notification.

Historically, some shells applied the -u option to all parameters including $@ and $*. The standard developers felt that this was a misfeature since it is normal and common for $@ and $* to be used in shell scripts regardless of whether they were passed any arguments. Treating these uses as an error when no arguments are passed reduces the value of -u for its intended purpose of finding spelling mistakes in variable names and uses of unset positional parameters.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities, hash

XBD Variable Assignment, Utility Syntax Guidelines

CHANGE HISTORY
Issue 6
The obsolescent set command name followed by '-' has been removed.

The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:

The nolog option is added to set -o.

IEEE PASC Interpretation 1003.2 #167 is applied, clarifying that the options default also takes into account the description of the option.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/8 is applied, changing the square brackets in the example in RATIONALE to be in bold, which is the typeface used for optional items.

Issue 7
Austin Group Interpretation 1003.1-2001 #027 is applied, clarifying the behavior if the first argument is '-'.

SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

XSI shading is removed from the -h functionality.

POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0046 [52], XCU/TC1-2008/0047 [155,280], XCU/TC1-2008/0048 [52], XCU/TC1-2008/0049 [52], and XCU/TC1-2008/0050 [155,430] are applied.

POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0053 [584], XCU/TC2-2008/0054 [717], XCU/TC2-2008/0055 [717], and XCU/TC2-2008/0056 [960] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
shift - shift positional parameters
SYNOPSIS
shift [n]

DESCRIPTION
The positional parameters shall be shifted. Positional parameter 1 shall be assigned the value of parameter (1+n), parameter 2 shall be assigned the value of parameter (2+n), and so on. The parameters represented by the numbers "$#" down to "$#-n+1" shall be unset, and the parameter '#' is updated to reflect the new number of positional parameters.

The value n shall be an unsigned decimal integer less than or equal to the value of the special parameter '#'. If n is not given, it shall be assumed to be 1. If n is 0, the positional and special parameters are not changed.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
If the n operand is invalid or is greater than "$#", this may be considered a syntax error and a non-interactive shell may exit; if the shell does not exit in this case, a non-zero exit status shall be returned. Otherwise, zero shall be returned.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
$ set a b c d e
$ shift 2
$ echo $*
c d e

RATIONALE
None.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0051 [459] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
times - write process times
SYNOPSIS
times

DESCRIPTION
The times utility shall write the accumulated user and system times for the shell and for all of its child processes, in the following POSIX locale format:

"%dm%fs %dm%fs\n%dm%fs %dm%fs\n", <shell user minutes>,
    <shell user seconds>, <shell system minutes>,
    <shell system seconds>, <children user minutes>,
    <children user seconds>, <children system minutes>,
    <children system seconds>

The four pairs of times shall correspond to the members of the <sys/times.h> tms structure (defined in XBD Headers) as returned by times(): tms_utime, tms_stime, tms_cutime, and tms_cstime, respectively.

OPTIONS
None.

OPERANDS
None.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
See the DESCRIPTION.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
$ times
0m0.43s 0m1.11s
8m44.18s 1m43.23s

RATIONALE
The times special built-in from the Single UNIX Specification is now required for all conforming shells.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

XBD <sys/times.h>

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/9 is applied, changing text in the DESCRIPTION from: "Write the accumulated user and system times for the shell and for all of its child processes ..." to: "The times utility shall write the accumulated user and system times for the shell and for all of its child processes ...".

Issue 7
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0056 [960] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
trap - trap signals
SYNOPSIS
trap n [condition...]trap [action condition...]

DESCRIPTION
If the first operand is an unsigned decimal integer, the shell shall treat all operands as conditions, and shall reset each condition to the default value. Otherwise, if there are operands, the first is treated as an action and the remaining as conditions.

If action is '-', the shell shall reset each condition to the default value. If action is null ( "" ), the shell shall ignore each specified condition if it arises. Otherwise, the argument action shall be read and executed by the shell when one of the corresponding conditions arises. The action of trap shall override a previous action (either default action or one explicitly set). The value of "$?" after the trap action completes shall be the value it had before trap was invoked.

The condition can be EXIT, 0 (equivalent to EXIT), or a signal specified using a symbolic name, without the SIG prefix, as listed in the tables of signal names in the <signal.h> header defined in XBD Headers; for example, HUP, INT, QUIT, TERM. Implementations may permit names with the SIG prefix or ignore case in signal names as an extension. Setting a trap for SIGKILL or SIGSTOP produces undefined results.

The environment in which the shell executes a trap on EXIT shall be identical to the environment immediately after the last command executed before the trap on EXIT was taken.

Each time trap is invoked, the action argument shall be processed in a manner equivalent to:

eval action
Signals that were ignored on entry to a non-interactive shell cannot be trapped or reset, although no error need be reported when attempting to do so. An interactive shell may reset or catch signals ignored on entry. Traps shall remain in place for a given shell until explicitly changed with another trap command.

When a subshell is entered, traps that are not being ignored shall be set to the default actions, except in the case of a command substitution containing only a single trap command, when the traps need not be altered. Implementations may check for this case using only lexical analysis; for example, if `trap` and $( trap -- ) do not alter the traps in the subshell, cases such as assigning var=trap and then using $($var) may still alter them. This does not imply that the trap command cannot be used within the subshell to set new traps.

The trap command with no operands shall write to standard output a list of commands associated with each condition. If the command is executed in a subshell, the implementation does not perform the optional check described above for a command substitution containing only a single trap command, and no trap commands with operands have been executed since entry to the subshell, the list shall contain the commands that were associated with each condition immediately before the subshell environment was entered. Otherwise, the list shall contain the commands currently associated with each condition. The format shall be:

"trap -- %s %s ...\n", <action>, <condition> ...

The shell shall format the output, including the proper use of quoting, so that it is suitable for reinput to the shell as commands that achieve the same trapping results. For example:

save_traps=$(trap)
...
eval "$save_traps"

[XSI] [Option Start] XSI-conformant systems also allow numeric signal numbers for the conditions corresponding to the following signal names:

1
SIGHUP
2
SIGINT
3
SIGQUIT
6
SIGABRT
9
SIGKILL
14
SIGALRM
15
SIGTERM
[Option End]
The trap special built-in shall conform to XBD Utility Syntax Guidelines.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
See the DESCRIPTION.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
If the trap name [XSI] [Option Start]  or number [Option End] is invalid, a non-zero exit status shall be returned; otherwise, zero shall be returned. For both interactive and non-interactive shells, invalid signal names [XSI] [Option Start]  or numbers [Option End] shall not be considered a syntax error and do not cause the shell to abort.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
Write out a list of all traps and actions:

trap

Set a trap so the logout utility in the directory referred to by the HOME environment variable executes when the shell terminates:

trap '"$HOME"/logout' EXIT

or:

trap '"$HOME"/logout' 0

Unset traps on INT, QUIT, TERM, and EXIT:

trap - INT QUIT TERM EXIT

RATIONALE
Implementations may permit lowercase signal names as an extension. Implementations may also accept the names with the SIG prefix; no known historical shell does so. The trap and kill utilities in this volume of POSIX.1-2008 are now consistent in their omission of the SIG prefix for signal names. Some kill implementations do not allow the prefix, and kill -l lists the signals without prefixes.

Trapping SIGKILL or SIGSTOP is syntactically accepted by some historical implementations, but it has no effect. Portable POSIX applications cannot attempt to trap these signals.

The output format is not historical practice. Since the output of historical trap commands is not portable (because numeric signal values are not portable) and had to change to become so, an opportunity was taken to format the output in a way that a shell script could use to save and then later reuse a trap if it wanted.

The KornShell uses an ERR trap that is triggered whenever set -e would cause an exit. This is allowable as an extension, but was not mandated, as other shells have not used it.

The text about the environment for the EXIT trap invalidates the behavior of some historical versions of interactive shells which, for example, close the standard input before executing a trap on 0. For example, in some historical interactive shell sessions the following trap on 0 would always print "--" :

trap 'read foo; echo "-$foo-"' 0

The command:

trap 'eval " $cmd"' 0

causes the contents of the shell variable cmd to be executed as a command when the shell exits. Using:

trap '$cmd' 0

does not work correctly if cmd contains any special characters such as quoting or redirections. Using:

trap " $cmd" 0

also works (the leading <space> character protects against unlikely cases where cmd is a decimal integer or begins with '-' ), but it expands the cmd variable when the trap command is executed, not when the exit action is executed.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

XBD Utility Syntax Guidelines, <signal.h>

CHANGE HISTORY
Issue 6
XSI-conforming implementations provide the mapping of signal names to numbers given above (previously this had been marked obsolescent). Other implementations need not provide this optional mapping.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

Austin Group Interpretation 1003.1-2001 #116 is applied.

POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0052 [53,268,440], XCU/TC1-2008/0053 [53,268,440], XCU/TC1-2008/0054 [163], XCU/TC1-2008/0055 [163], and XCU/TC1-2008/0056 [163] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
unset - unset values and attributes of variables and functions
SYNOPSIS
unset [-fv] name...

DESCRIPTION
Each variable or function specified by name shall be unset.

If -v is specified, name refers to a variable name and the shell shall unset it and remove it from the environment. Read-only variables cannot be unset.

If -f is specified, name refers to a function and the shell shall unset the function definition.

If neither -f nor -v is specified, name refers to a variable; if a variable by that name does not exist, it is unspecified whether a function by that name, if any, shall be unset.

Unsetting a variable or function that was not previously set shall not be considered an error and does not cause the shell to abort.

The unset special built-in shall support XBD Utility Syntax Guidelines.

Note that:

VARIABLE=

is not equivalent to an unset of VARIABLE; in the example, VARIABLE is set to "". Also, the variables that can be unset should not be misinterpreted to include the special parameters (see Special Parameters).

OPTIONS
See the DESCRIPTION.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
All name operands were successfully unset.
>0
At least one name could not be unset.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
Unset VISUAL variable:

unset -v VISUAL

Unset the functions foo and bar:

unset -f foo bar

RATIONALE
Consideration was given to omitting the -f option in favor of an unfunction utility, but the standard developers decided to retain historical practice.

The -v option was introduced because System V historically used one name space for both variables and functions. When unset is used without options, System V historically unset either a function or a variable, and there was no confusion about which one was intended. A portable POSIX application can use unset without an option to unset a variable, but not a function; the -f option must be used.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

XBD Utility Syntax Guidelines

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

End of informative text.
<<< Previous	Home	Next >>>


<<< Previous	Home	Next >>>
The Open Group Base Specifications Issue 7
IEEE Std 1003.1-2008, 2016 Edition
Copyright  2001-2016 The IEEE and The Open Group
4. General Concepts
For the purposes of POSIX.1-2008, the general concepts given in General Concepts apply.

Note:
No shading to denote extensions or options occurs in this chapter. Where the terms and definitions given in this chapter are used elsewhere in text related to extensions and options, they are shaded as appropriate.
4.1 Concurrent Execution
Functions that suspend the execution of the calling thread shall not cause the execution of other threads to be indefinitely suspended.

4.2 Default Initialization
Default initialization causes an object to be initialized according to these rules:

If it has pointer type, it is initialized to a null pointer.

If it has arithmetic type, it is initialized to (positive or unsigned) zero.

If it is an aggregate, every member is initialized (recursively) according to these rules.

If it is a union, the first named member is initialized (recursively) according to these rules.

For an object of aggregate type with an explicit initializer, the initialization shall occur in initializer list order, each initializer provided for a particular subobject overriding any previously listed initializer for the same subobject; all subobjects that are not initialized explicitly shall be initialized implicitly according to the rules for default initialization.

Objects with static storage duration but no explicit initializer shall be initialized implicitly according to the rules for default initialization.

An explicit initializer of { 0 } works to perform explicit default initialization for any object of scalar or aggregate type, and for any storage duration.

Notes:
The ISO C standard does not require a compiler to set any field alignment padding bits in a structure or array definition to a particular value. Because of this, a structure initialized using { 0 } might not memcmp() as equal to the same structure initialized using memset() to zero. For consistent results, portable applications comparing structures should test each field individually.

If an implementation treats the all-zero bit pattern of a pointer object as a null pointer, and the all-zero bit pattern of a floating-point object as equivalent to positive 0, then memset() to zero and calloc() have the same effects as default initialization for all named members of a structure. [MX] [Option Start]  Implementations that define __STDC_IEC_559__ guarantee that the all-zero bit pattern of a floating-point object represents 0.0. [Option End]

4.3 Directory Protection
If a directory is writable and the mode bit S_ISVTX is set on the directory, a process may remove or rename files within that directory only if one or more of the following is true:

The effective user ID of the process is the same as that of the owner ID of the file.

The effective user ID of the process is the same as that of the owner ID of the directory.

The process has appropriate privileges.

Optionally, the file is writable by the process. Whether or not files that are writable by the process can be removed or renamed is implementation-defined.

If the S_ISVTX bit is set on a non-directory file, the behavior is unspecified.

4.4 Extended Security Controls
An implementation may provide implementation-defined extended security controls (see Extended Security Controls). These permit an implementation to provide security mechanisms to implement different security policies than those described in POSIX.1-2008. These mechanisms shall not alter or override the defined semantics of any of the interfaces in POSIX.1-2008.

4.5 File Access Permissions
The standard file access control mechanism uses the file permission bits, as described below.

Implementations may provide additional or alternate file access control mechanisms, or both. An additional access control mechanism shall only further restrict the access permissions defined by the file permission bits. An alternate file access control mechanism shall:

Specify file permission bits for the file owner class, file group class, and file other class of that file, corresponding to the access permissions.

Be enabled only by explicit user action, on a per-file basis by the file owner or a user with appropriate privileges.

Be disabled for a file after the file permission bits are changed for that file with chmod(). The disabling of the alternate mechanism need not disable any additional mechanisms supported by an implementation.

Whenever a process requests file access permission for read, write, or execute/search, if no additional mechanism denies access, access shall be determined as follows:

If a process has appropriate privileges:

If read, write, or directory search permission is requested, access shall be granted.

If execute permission is requested, access shall be granted if execute permission is granted to at least one user by the file permission bits or by an alternate access control mechanism; otherwise, access shall be denied.

Otherwise:

The file permission bits of a file contain read, write, and execute/search permissions for the file owner class, file group class, and file other class.

Access shall be granted if an alternate access control mechanism is not enabled and the requested access permission bit is set for the class (file owner class, file group class, or file other class) to which the process belongs, or if an alternate access control mechanism is enabled and it allows the requested access; otherwise, access shall be denied.

4.6 File Hierarchy
Files in the system are organized in a hierarchical structure in which all of the non-terminal nodes are directories and all of the terminal nodes are any other type of file. Since multiple directory entries may refer to the same file, the hierarchy is properly described as a "directed graph".

4.7 Filenames
Uppercase and lowercase letters shall retain their unique identities between conforming implementations.

4.8 Filename Portability
For a filename to be portable across implementations conforming to POSIX.1-2008, it shall consist only of the portable filename character set as defined in Portable Filename Character Set.

Note:
Applications should avoid using filenames that have the <hyphen-minus> character as the first character since this may cause problems when filenames are passed as command line arguments.
4.9 File Times Update
Many operations have requirements to update file timestamps. These requirements do not apply to streams that have no underlying file description (for example, memory streams created by open_memstream() have no underlying file description).

Each file has three distinct associated timestamps: the time of last data access, the time of last data modification, and the time the file status last changed. These values are returned in the file characteristics structure struct stat, as described in <sys/stat.h>.

Each function or utility in POSIX.1-2008 that reads or writes data (even if the data does not change) or performs an operation to change file status (even if the file status does not change) indicates which of the appropriate timestamps shall be marked for update. If an implementation of such a function or utility marks for update one of these timestamps in a place or time not specified by POSIX.1-2008, this shall be documented, except that any changes caused by pathname resolution need not be documented. For the other functions or utilities in POSIX.1-2008 (those that are not explicitly required to read or write file data or change file status, but that in some implementations happen to do so), the effect is unspecified.

An implementation may update timestamps that are marked for update immediately, or it may update such timestamps periodically. At the point in time when an update occurs, any marked timestamps shall be set to the current time and the update marks shall be cleared. All timestamps that are marked for update shall be updated when the file ceases to be open by any process or before a fstat(), fstatat(), fsync(), futimens(), lstat(), stat(), utime(), utimensat(), or utimes() is successfully performed on the file. Other times at which updates are done are unspecified. Marks for update, and updates themselves, shall not be done for files on read-only file systems; see Read-Only File System.

The resolution of timestamps of files in a file system is implementation-defined, but shall be no coarser than one-second resolution. The three timestamps shall always have values that are supported by the file system. Whenever any of a file's timestamps are to be set to a value V according to the rules of the preceding paragraphs of this section, the implementation shall immediately set the timestamp to the greatest value supported by the file system that is not greater than V.

4.10 Host and Network Byte Orders
When data is transmitted over the network, it is sent as a sequence of octets (8-bit unsigned values). If an entity (such as an address or a port number) can be larger than 8 bits, it needs to be stored in several octets. The convention is that all such values are stored with 8 bits in each octet, and with the first (lowest-addressed) octet holding the most-significant bits. This is called "network byte order".

Network byte order may not be convenient for processing actual values. For this, it is more sensible for values to be stored as ordinary integers. This is known as "host byte order". In host byte order:

The most significant bit might not be stored in the first byte in address order.

Bits might not be allocated to bytes in any obvious order at all.

8-bit values stored in uint8_t objects do not require conversion to or from host byte order, as they have the same representation. 16 and 32-bit values can be converted using the htonl(), htons(), ntohl(), and ntohs() functions. When reading data that is to be converted to host byte order, it should either be received directly into a uint16_t or uint32_t object or should be copied from an array of bytes using memcpy() or similar. Passing the data through other types could cause the byte order to be changed. Similar considerations apply when sending data.

4.11 Measurement of Execution Time
The mechanism used to measure execution time shall be implementation-defined. The implementation shall also define to whom the CPU time that is consumed by interrupt handlers and system services on behalf of the operating system will be charged. See CPU Time (Execution Time).

4.12 Memory Synchronization
Applications shall ensure that access to any memory location by more than one thread of control (threads or processes) is restricted such that no thread of control can read or modify a memory location while another thread of control may be modifying it. Such access is restricted using functions that synchronize thread execution and also synchronize memory with respect to other threads. The following functions synchronize memory with respect to other threads:


fork()
pthread_barrier_wait()
pthread_cond_broadcast()
pthread_cond_signal()
pthread_cond_timedwait()
pthread_cond_wait()
pthread_create()
pthread_join()
pthread_mutex_lock()
pthread_mutex_timedlock()
 


pthread_mutex_trylock()
pthread_mutex_unlock()
pthread_spin_lock()
pthread_spin_trylock()
pthread_spin_unlock()
pthread_rwlock_rdlock()
pthread_rwlock_timedrdlock()
pthread_rwlock_timedwrlock()
pthread_rwlock_tryrdlock()
pthread_rwlock_trywrlock()
 


pthread_rwlock_unlock()
pthread_rwlock_wrlock()
sem_post()
sem_timedwait()
sem_trywait()
sem_wait()
semctl()
semop()
wait()
waitpid()
 

The pthread_once() function shall synchronize memory for the first call in each thread for a given pthread_once_t object. If the init_routine called by pthread_once() is a cancellation point and is canceled, a call to pthread_once() for the same pthread_once_t object made from a cancellation cleanup handler shall also synchronize memory.

The pthread_mutex_lock() function need not synchronize memory if the mutex type if PTHREAD_MUTEX_RECURSIVE and the calling thread already owns the mutex. The pthread_mutex_unlock() function need not synchronize memory if the mutex type is PTHREAD_MUTEX_RECURSIVE and the mutex has a lock count greater than one.

Unless explicitly stated otherwise, if one of the above functions returns an error, it is unspecified whether the invocation causes memory to be synchronized.

Applications may allow more than one thread of control to read a memory location simultaneously.

4.13 Pathname Resolution
Pathname resolution is performed for a process to resolve a pathname to a particular directory entry for a file in the file hierarchy. There may be multiple pathnames that resolve to the same directory entry, and multiple directory entries for the same file. When a process resolves a pathname of an existing directory entry, the entire pathname shall be resolved as described below. When a process resolves a pathname of a directory entry that is to be created immediately after the pathname is resolved, pathname resolution terminates when all components of the path prefix of the last component have been resolved. It is then the responsibility of the process to create the final component.

Each filename in the pathname is located in the directory specified by its predecessor (for example, in the pathname fragment a/b, file b is located in directory a). Pathname resolution shall fail if this cannot be accomplished. If the pathname begins with a <slash>, the predecessor of the first filename in the pathname shall be taken to be the root directory of the process (such pathnames are referred to as "absolute pathnames"). If the pathname does not begin with a <slash>, the predecessor of the first filename of the pathname shall be taken to be either the current working directory of the process or for certain interfaces the directory identified by a file descriptor passed to the interface (such pathnames are referred to as "relative pathnames").

The interpretation of a pathname component is dependent on the value of {NAME_MAX} and _POSIX_NO_TRUNC associated with the path prefix of that component. If any pathname component is longer than {NAME_MAX}, the implementation shall consider this an error.

A pathname that contains at least one non- <slash> character and that ends with one or more trailing <slash> characters shall not be resolved successfully unless the last pathname component before the trailing <slash> characters names an existing directory or a directory entry that is to be created for a directory immediately after the pathname is resolved. Interfaces using pathname resolution may specify additional constraints1 when a pathname that does not name an existing directory contains at least one non- <slash> character and contains one or more trailing <slash> characters.

If a symbolic link is encountered during pathname resolution, the behavior shall depend on whether the pathname component is at the end of the pathname and on the function being performed. If all of the following are true, then pathname resolution is complete:

This is the last pathname component of the pathname.

The pathname has no trailing <slash>.

The function is required to act on the symbolic link itself, or certain arguments direct that the function act on the symbolic link itself.

In all other cases, the system shall prefix the remaining pathname, if any, with the contents of the symbolic link, except that if the contents of the symbolic link is the empty string, then either pathname resolution shall fail with functions reporting an [ENOENT] error and utilities writing an equivalent diagnostic message, or the pathname of the directory containing the symbolic link shall be used in place of the contents of the symbolic link. If the contents of the symbolic link consist solely of <slash> characters, then all leading <slash> characters of the remaining pathname shall be omitted from the resulting combined pathname, leaving only the leading <slash> characters from the symbolic link contents. In the cases where prefixing occurs, if the combined length exceeds {PATH_MAX}, and the implementation considers this to be an error, pathname resolution shall fail with functions reporting an [ENAMETOOLONG] error and utilities writing an equivalent diagnostic message. Otherwise, the resolved pathname shall be the resolution of the pathname just created. If the resulting pathname does not begin with a <slash>, the predecessor of the first filename of the pathname is taken to be the directory containing the symbolic link.

If the system detects a loop in the pathname resolution process, pathname resolution shall fail with functions reporting an [ELOOP] error and utilities writing an equivalent diagnostic message. The same may happen if during the resolution process more symbolic links were followed than the implementation allows. This implementation-defined limit shall not be smaller than {SYMLOOP_MAX}.

The special filename dot shall refer to the directory specified by its predecessor. The special filename dot-dot shall refer to the parent directory of its predecessor directory. As a special case, in the root directory, dot-dot may refer to the root directory itself.

A pathname consisting of a single <slash> shall resolve to the root directory of the process. A null pathname shall not be successfully resolved. If a pathname begins with two successive <slash> characters, the first component following the leading <slash> characters may be interpreted in an implementation-defined manner, although more than two leading <slash> characters shall be treated as a single <slash> character.

Pathname resolution for a given pathname shall yield the same results when used by any interface in POSIX.1-2008 as long as there are no changes to any files evaluated during pathname resolution for the given pathname between resolutions.

4.14 Process ID Reuse
A process group ID shall not be reused by the system until the process group lifetime ends.

A process ID shall not be reused by the system until the process lifetime ends. In addition, if there exists a process group whose process group ID is equal to that process ID, the process ID shall not be reused by the system until the process group lifetime ends. A process that is not a system process shall not have a process ID of 1.

4.15 Scheduling Policy
A scheduling policy affects process or thread ordering:

When a process or thread is a running thread and it becomes a blocked thread

When a process or thread is a running thread and it becomes a preempted thread

When a process or thread is a blocked thread and it becomes a runnable thread

When a running thread calls a function that can change the priority or scheduling policy of a process or thread

In other scheduling policy-defined circumstances

Conforming implementations shall define the manner in which each of the scheduling policies may modify the priorities or otherwise affect the ordering of processes or threads at each of the occurrences listed above. Additionally, conforming implementations shall define in what other circumstances and in what manner each scheduling policy may modify the priorities or affect the ordering of processes or threads.

4.16 Seconds Since the Epoch
A value that approximates the number of seconds that have elapsed since the Epoch. A Coordinated Universal Time name (specified in terms of seconds (tm_sec), minutes (tm_min), hours (tm_hour), days since January 1 of the year (tm_yday), and calendar year minus 1900 (tm_year)) is related to a time represented as seconds since the Epoch, according to the expression below.

If the year is <1970 or the value is negative, the relationship is undefined. If the year is >=1970 and the value is non-negative, the value is related to a Coordinated Universal Time name according to the C-language expression, where tm_sec, tm_min, tm_hour, tm_yday, and tm_year are all integer types:

tm_sec + tm_min*60 + tm_hour*3600 + tm_yday*86400 +
    (tm_year-70)*31536000 + ((tm_year-69)/4)*86400 -
    ((tm_year-1)/100)*86400 + ((tm_year+299)/400)*86400

The relationship between the actual time of day and the current value for seconds since the Epoch is unspecified.

How any changes to the value of seconds since the Epoch are made to align to a desired relationship with the current actual time is implementation-defined. As represented in seconds since the Epoch, each and every day shall be accounted for by exactly 86400 seconds.

Note:
The last three terms of the expression add in a day for each year that follows a leap year starting with the first leap year since the Epoch. The first term adds a day every 4 years starting in 1973, the second subtracts a day back out every 100 years starting in 2001, and the third adds a day back in every 400 years starting in 2001. The divisions in the formula are integer divisions; that is, the remainder is discarded leaving only the integer quotient.
4.17 Semaphore
A minimum synchronization primitive to serve as a basis for more complex synchronization mechanisms to be defined by the application program.

For the semaphores associated with the Semaphores option, a semaphore is represented as a shareable resource that has a non-negative integer value. When the value is zero, there is a (possibly empty) set of threads awaiting the availability of the semaphore.

For the semaphores associated with the X/Open System Interfaces (XSI) option, a semaphore is a positive integer (0 through 32767). The semget() function can be called to create a set or array of semaphores. A semaphore set can contain one or more semaphores up to an implementation-defined value.

Semaphore Lock Operation
An operation that is applied to a semaphore. If, prior to the operation, the value of the semaphore is zero, the semaphore lock operation shall cause the calling thread to be blocked and added to the set of threads awaiting the semaphore; otherwise, the value shall be decremented.

Semaphore Unlock Operation
An operation that is applied to a semaphore. If, prior to the operation, there are any threads in the set of threads awaiting the semaphore, then some thread from that set shall be removed from the set and becomes unblocked; otherwise, the semaphore value shall be incremented.

4.18 Thread-Safety
Refer to XSH Threads.

4.19 Tracing
The trace system allows a traced process to have a selection of events created for it. Traces consist of streams of trace event types.

A trace event type is identified on the one hand by a trace event type name, also referenced as a trace event name, and on the other hand by a trace event type identifier. A trace event name is a human-readable string. A trace event type identifier is an opaque identifier used by the trace system. There shall be a one-to-one relationship between trace event type identifiers and trace event names for a given trace stream and also for a given traced process. The trace event type identifier shall be generated automatically from a trace event name by the trace system either when a trace controller process invokes posix_trace_trid_eventid_open() or when an instrumented application process invokes posix_trace_eventid_open(). Trace event type identifiers are used to filter trace event types, to allow interpretation of user data, and to identify the kind of trace point that generated a trace event.

Each trace event shall be of a particular trace event type, and associated with a trace event type identifier. The execution of a trace point shall generate a trace event if a trace stream has been created and started for the process that executed the trace point and if the corresponding trace event type identifier is not ignored by filtering.

A generated trace event shall be recorded in a trace stream, and optionally also in a trace log if a trace log is associated with the trace stream, except that:

For a trace stream, if no resources are available for the event, the event is lost.

For a trace log, if no resources are available for the event, or a flush operation does not succeed, the event is lost.

A trace event recorded in an active trace stream may be retrieved by an application having appropriate privileges.

A trace event recorded in a trace log may be retrieved by an application having appropriate privileges after opening the trace log as a pre-recorded trace stream, with the function posix_trace_open().
When a trace event is reported it is possible to retrieve the following:

A trace event type identifier

A timestamp

The process ID of the traced process, if the trace event is process-dependent

Any optional trace event data including its length

If the Threads option is supported, the thread ID, if the trace event is process-dependent

The program address at which the trace point was invoked

Trace events may be mapped from trace event types to trace event names. One such mapping shall be associated with each trace stream. An active trace stream is associated with a traced process, and also with its children if the Trace Inherit option is supported and also the inheritance policy is set to _POSIX_TRACE_INHERIT. Therefore each traced process has a mapping of the trace event names to trace event type identifiers that have been defined for that process.

Traces can be recorded into either trace streams or trace logs.

The implementation and format of a trace stream are unspecified. A trace stream need not be and generally is not persistent. A trace stream may be either active or pre-recorded:

An active trace stream is a trace stream that has been created and has not yet been shut down. It can be of one of the two following classes:

An active trace stream without a trace log that was created with the posix_trace_create() function

If the Trace Log option is supported, an active trace stream with a trace log that was created with the posix_trace_create_withlog() function

A pre-recorded trace stream is a trace stream that was opened from a trace log object using the posix_trace_open() function.

An active trace stream can loop. This behavior means that when the resources allocated by the trace system for the trace stream are exhausted, the trace system reuses the resources associated with the oldest recorded trace events to record new trace events.

If the Trace Log option is supported, an active trace stream with a trace log can be flushed. This operation causes the trace system to write trace events from the trace stream to the associated trace log, following the defined policies or using an explicit function call. After this operation, the trace system may reuse the resources associated with the flushed trace events.

An active trace stream with or without a trace log can be cleared. This operation shall cause all the resources associated with this trace stream to be reinitialized. The trace stream shall behave as if it was returning from its creation, except that the mapping of trace event type identifiers to trace event names shall not be cleared. If a trace log was associated with this trace stream, the trace log shall also be reinitialized.

A trace log shall be recorded when the posix_trace_shutdown() operation is invoked or during tracing, depending on the tracing strategy which is defined by a log policy. After the trace stream has been shut down, the trace information can be retrieved from the associated trace log using the same interface used to retrieve information from an active trace stream.

For a traced process, if the Trace Inherit option is supported and the trace stream's inheritance attribute is _POSIX_TRACE_INHERIT, the initial targeted traced process shall be traced together with all of its future children. The posix_pid member of each trace event in a trace stream shall be the process ID of the traced process.

Each trace point may be an implementation-defined action such as a context switch, or an application-programmed action such as a call to a specific operating system service (for example, fork()) or a call to posix_trace_event().

Trace points may be filtered. The operation of the filter is to filter out (ignore) selected trace events. By default, no trace events are filtered.

The results of the tracing operations can be analyzed and monitored by a trace controller process or a trace analyzer process.

Only the trace controller process has control of the trace stream it has created. The control of the operation of a trace stream is done using its corresponding trace stream identifier. The trace controller process is able to:

Initialize the attributes of a trace stream

Create the trace stream

Start and stop tracing

Know the mapping of the traced process

If the Trace Event Filter option is supported, filter the type of trace events to be recorded

Shut the trace stream down

A traced process may also be a trace controller process. Only the trace controller process can control its trace stream(s). A trace stream created by a trace controller process shall be shut down if its controller process terminates or executes another file.

A trace controller process may also be a trace analyzer process. Trace analysis can be done concurrently with the traced process or can be done off-line, in the same or in a different platform.

4.20 Treatment of Error Conditions for Mathematical Functions
For all the functions in the <math.h> header, an application wishing to check for error situations should set errno to 0 and call feclearexcept(FE_ALL_EXCEPT) before calling the function. On return, if errno is non-zero or fetestexcept( FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.

On implementations that support the IEC 60559 Floating-Point option, whether or when functions in the <math.h> header raise an undeserved underflow floating-point exception is unspecified. Otherwise, as implied by XSH feraiseexcept, the <math.h> functions do not raise spurious floating-point exceptions (detectable by the user), other than the inexact floating-point exception.

The following error conditions are defined for all functions in the <math.h> header.

4.20.1 Domain Error
A "domain error" shall occur if an input argument is outside the domain over which the mathematical function is defined. The description of each function lists any required domain errors; an implementation may define additional domain errors, provided that such errors are consistent with the mathematical definition of the function.

On a domain error, the function shall return an implementation-defined value; if the integer expression (math_errhandling & MATH_ERRNO) is non-zero, errno shall be set to [EDOM]; if the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, the "invalid" floating-point exception shall be raised.

4.20.2 Pole Error
A "pole error" occurs if the mathematical result of the function is an exact infinity (for example, log(0.0)).

On a pole error, the function shall return the value of the macro HUGE_VAL, HUGE_VALF, or HUGE_VALL according to the return type, with the same sign as the correct value of the function; if the integer expression (math_errhandling & MATH_ERRNO) is non-zero, errno shall be set to [ERANGE]; if the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, the "divide-by-zero" floating-point exception shall be raised.

4.20.3 Range Error
A "range error" shall occur if the finite mathematical result of the function cannot be represented in an object of the specified type, due to extreme magnitude.

Result Overflows
A floating result overflows if the magnitude of the mathematical result is finite but so large that the mathematical result cannot be represented without extraordinary roundoff error in an object of the specified type. If a floating result overflows and default rounding is in effect, then the function shall return the value of the macro HUGE_VAL, HUGE_VALF, or HUGE_VALL according to the return type, with the same sign as the correct value of the function; if the integer expression (math_errhandling & MATH_ERRNO) is non-zero, errno shall be set to [ERANGE]; if the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, the "overflow" floating-point exception shall be raised.

Result Underflows
The result underflows if the magnitude of the mathematical result is so small that the mathematical result cannot be represented, without extraordinary roundoff error, in an object of the specified type. If the result underflows, the function shall return an implementation-defined value whose magnitude is no greater than the smallest normalized positive number in the specified type; if the integer expression (math_errhandling & MATH_ERRNO) is non-zero, whether errno is set to [ERANGE] is implementation-defined; if the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, whether the "underflow'' floating-point exception is raised is implementation-defined.

4.21 Treatment of NaN Arguments for the Mathematical Functions
For functions called with a NaN argument, no errors shall occur and a NaN shall be returned, except where stated otherwise.

If a function with one or more NaN arguments returns a NaN result, the result should be the same as one of the NaN arguments (after possible type conversion), except perhaps for the sign.

On implementations that support the IEC 60559:1989 standard floating point, functions with signaling NaN argument(s) shall be treated as if the function were called with an argument that is a required domain error and shall return a quiet NaN result, except where stated otherwise.

Note:
The function might never see the signaling NaN, since it might trigger when the arguments are evaluated during the function call.
On implementations that support the IEC 60559:1989 standard floating point, for those functions that do not have a documented domain error, the following shall apply:

These functions shall fail if:
Domain Error
Any argument is a signaling NaN.
Either, the integer expression (math_errhandling & MATH_ERRNO) is non-zero and errno shall be set to [EDOM], or the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero and the invalid floating-point exception shall be raised.

4.22 Utility
A utility program shall be either an executable file, such as might be produced by a compiler or linker system from computer source code, or a file of shell source code, directly interpreted by the shell. The program may have been produced by the user, provided by the system implementor, or acquired from an independent distributor.

The system may implement certain utilities as shell functions (see XCU Function Definition Command) or built-in utilities, but only an application that is aware of the command search order (as described in XCU Command Search and Execution) or of performance characteristics can discern differences between the behavior of such a function or built-in utility and that of an executable file.

4.23 Variable Assignment
In the shell command language, a word consisting of the following parts:

varname=value
When used in a context where assignment is defined to occur and at no other time, the value (representing a word or field) shall be assigned as the value of the variable denoted by varname.

Note:
For further information, see XCU Simple Commands.
The varname and value parts shall meet the requirements for a name and a word, respectively, except that they are delimited by the embedded unquoted <equals-sign>, in addition to other delimiters.

Note:
Additional delimiters are described in XCU Token Recognition.
When a variable assignment is done, the variable shall be created if it did not already exist. If value is not specified, the variable shall be given a null value.

Note:
An alternative form of variable assignment:
symbol=value
(where symbol is a valid word delimited by an <equals-sign>, but not a valid name) produces unspecified results. The form symbol= value is used by the KornShell name[ expression]= value syntax.

Footnotes
1.
The only interfaces that further constrain pathnames in POSIX.1-2008 are the rename() and renameat() functions (see XSH rename) and the mv utility (see XCU mv).
 

return to top of page
UNIX  is a registered Trademark of The Open Group.
POSIX  is a registered Trademark of The IEEE.
Copyright  2001-2016 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT ]
<<< Previous	Home	Next >>>


<<< Previous	Home	Next >>>
The Open Group Base Specifications Issue 7
IEEE Std 1003.1-2008, 2016 Edition
Copyright  2001-2016 The IEEE and The Open Group
12. Utility Conventions
12.1 Utility Argument Syntax
This section describes the argument syntax of the standard utilities and introduces terminology used throughout POSIX.1-2008 for describing the arguments processed by the utilities.

Within POSIX.1-2008, a special notation is used for describing the syntax of a utility's arguments. Unless otherwise noted, all utility descriptions use this notation, which is illustrated by this example (see XCU Simple Commands):

utility_name[-a][-b][-c option_argument]
    [-d|-e][-f[option_argument]][operand...]
The notation used for the SYNOPSIS sections imposes requirements on the implementors of the standard utilities and provides a simple reference for the application developer or system user.

The utility in the example is named utility_name. It is followed by options, option-arguments, and operands. The arguments that consist of <hyphen-minus> characters and single letters or digits, such as 'a', are known as "options" (or, historically, "flags"). Certain options are followed by an "option-argument", as shown with [ -c option_argument]. The arguments following the last options and option-arguments are named "operands".

Option-arguments are shown separated from their options by <blank> characters, except when the option-argument is enclosed in the '[' and ']' notation to indicate that it is optional. This reflects the situation in which an optional option-argument (if present) is included within the same argument string as the option; for a mandatory option-argument, it is the next argument. The Utility Syntax Guidelines in Utility Syntax Guidelines require that the option be a separate argument from its option-argument and that option-arguments not be optional, but there are some exceptions in POSIX.1-2008 to ensure continued operation of historical applications:

If the SYNOPSIS of a standard utility shows an option with a mandatory option-argument (as with [ -c option_argument] in the example), a conforming application shall use separate arguments for that option and its option-argument. However, a conforming implementation shall also permit applications to specify the option and option-argument in the same argument string without intervening <blank> characters.

If the SYNOPSIS shows an optional option-argument (as with [ -f[ option_argument]] in the example), a conforming application shall place any option-argument for that option directly adjacent to the option in the same argument string, without intervening <blank> characters. If the utility receives an argument containing only the option, it shall behave as specified in its description for an omitted option-argument; it shall not treat the next argument (if any) as the option-argument for that option.

Options are usually listed in alphabetical order unless this would make the utility description more confusing. There are no implied relationships between the options based upon the order in which they appear, unless otherwise stated in the OPTIONS section, or unless the exception in Guideline 11 of Utility Syntax Guidelines applies. If an option that does not have option-arguments is repeated, the results are undefined, unless otherwise stated.

Frequently, names of parameters that require substitution by actual values are shown with embedded <underscore> characters. Alternatively, parameters are shown as follows:

<parameter name>

The angle brackets are used for the symbolic grouping of a phrase representing a single parameter and conforming applications shall not include them in data submitted to the utility.

When a utility has only a few permissible options, they are sometimes shown individually, as in the example. Utilities with many flags generally show all of the individual flags (that do not take option-arguments) grouped, as in:

utility_name [-abcDxyz][-p arg][operand]
Utilities with very complex arguments may be shown as follows:

utility_name [options][operands]
Unless otherwise specified, whenever an operand or option-argument is, or contains, a numeric value:

The number is interpreted as a decimal integer.

Numerals in the range 0 to 2147483647 are syntactically recognized as numeric values.

When the utility description states that it accepts negative numbers as operands or option-arguments, numerals in the range -2147483647 to 2147483647 are syntactically recognized as numeric values.

When the utility description states that the number is a file size-related value (such as a file size or offset, line number, or block count), numerals in the range 0 to the maximum file size supported by the implementation are syntactically recognized as numeric values (see XCU Considerations for Utilities in Support of Files of Arbitrary Size). Where negative values are permitted, any value in the range -(maximum file size) to the maximum file size is accepted.

Ranges greater than those listed here are allowed.

This does not mean that all numbers within the allowable range are necessarily semantically correct. A standard utility that accepts an option-argument or operand that is to be interpreted as a number, and for which a range of values smaller than that shown above is permitted by the POSIX.1-2008, describes that smaller range along with the description of the option-argument or operand. If an error is generated, the utility's diagnostic message shall indicate that the value is out of the supported range, not that it is syntactically incorrect.

Arguments or option-arguments enclosed in the '[' and ']' notation are optional and can be omitted. Conforming applications shall not include the '[' and ']' symbols in data submitted to the utility.

Arguments separated by the '|' ( <vertical-line>) bar notation are mutually-exclusive. Conforming applications shall not include the '|' symbol in data submitted to the utility. Alternatively, mutually-exclusive options and operands may be listed with multiple synopsis lines.
For example:

utility_name -d[-a][-c option_argument][operand...]
utility_name[-a][-b][operand...]
When multiple synopsis lines are given for a utility, it is an indication that the utility has mutually-exclusive arguments. These mutually-exclusive arguments alter the functionality of the utility so that only certain other arguments are valid in combination with one of the mutually-exclusive arguments. Only one of the mutually-exclusive arguments is allowed for invocation of the utility. Unless otherwise stated in an accompanying OPTIONS section, the relationships between arguments depicted in the SYNOPSIS sections are mandatory requirements placed on conforming applications. The use of conflicting mutually-exclusive arguments produces undefined results, unless a utility description specifies otherwise. When an option is shown without the '[' and ']' brackets, it means that option is required for that version of the SYNOPSIS. However, it is not required to be the first argument, as shown in the example above, unless otherwise stated.

Ellipses ( "..." ) are used to denote that one or more occurrences of an operand are allowed. When an option or an operand followed by ellipses is enclosed in brackets, zero or more options or operands can be specified. The form:

utility_name [-g option_argument]...[operand...]
indicates that multiple occurrences of the option and its option-argument preceding the ellipses are valid, with semantics as indicated in the OPTIONS section of the utility. (See also Guideline 11 in Utility Syntax Guidelines .)

The form:

utility_name -f option_argument [-f option_argument]... [operand...]
indicates that the -f option is required to appear at least once and may appear multiple times.

When the synopsis line is too long to be printed on a single line in the Shell and Utilities volume of POSIX.1-2008, the indented lines following the initial line are continuation lines. An actual use of the command would appear on a single logical line.

12.2 Utility Syntax Guidelines
The following guidelines are established for the naming of utilities and for the specification of options, option-arguments, and operands. The getopt() function in the System Interfaces volume of POSIX.1-2008 assists utilities in handling options and operands that conform to these guidelines.

Operands and option-arguments can contain characters not specified in the portable character set.

The guidelines are intended to provide guidance to the authors of future utilities, such as those written specific to a local system or that are components of a larger application. Some of the standard utilities do not conform to all of these guidelines; in those cases, the OPTIONS sections describe the deviations.
Guideline 1:
Utility names should be between two and nine characters, inclusive.
Guideline 2:
Utility names should include lowercase letters (the lower character classification) and digits only from the portable character set.
Guideline 3:
Each option name should be a single alphanumeric character (the alnum character classification) from the portable character set. The -W (capital-W) option shall be reserved for vendor options.
Multi-digit options should not be allowed.

Guideline 4:
All options should be preceded by the '-' delimiter character.
Guideline 5:
One or more options without option-arguments, followed by at most one option that takes an option-argument, should be accepted when grouped behind one '-' delimiter.
Guideline 6:
Each option and option-argument should be a separate argument, except as noted in Utility Argument Syntax, item (2).
Guideline 7:
Option-arguments should not be optional.
Guideline 8:
When multiple option-arguments are specified to follow a single option, they should be presented as a single argument, using <comma> characters within that argument or <blank> characters within that argument to separate them.
Guideline 9:
All options should precede operands on the command line.
Guideline 10:
The first -- argument that is not an option-argument should be accepted as a delimiter indicating the end of options. Any following arguments should be treated as operands, even if they begin with the '-' character.
Guideline 11:
The order of different options relative to one another should not matter, unless the options are documented as mutually-exclusive and such an option is documented to override any incompatible options preceding it. If an option that has option-arguments is repeated, the option and option-argument combinations should be interpreted in the order specified on the command line.
Guideline 12:
The order of operands may matter and position-related interpretations should be determined on a utility-specific basis.
Guideline 13:
For utilities that use operands to represent files to be opened for either reading or writing, the '-' operand should be used to mean only standard input (or standard output when it is clear from context that an output file is being specified) or a file named -.
Guideline 14:
If an argument can be identified according to Guidelines 3 through 10 as an option, or as a group of options without option-arguments behind one '-' delimiter, then it should be treated as such.
The utilities in the Shell and Utilities volume of POSIX.1-2008 that claim conformance to these guidelines shall conform completely to these guidelines as if these guidelines contained the term "shall" instead of "should". On some implementations, the utilities accept usage in violation of these guidelines for backwards-compatibility as well as accepting the required form.

Where a utility described in the Shell and Utilities volume of POSIX.1-2008 as conforming to these guidelines is required to accept, or not to accept, the operand '-' to mean standard input or output, this usage is explained in the OPERANDS section. Otherwise, if such a utility uses operands to represent files, it is implementation-defined whether the operand '-' stands for standard input (or standard output), or for a file named -.

It is recommended that all future utilities and applications use these guidelines to enhance user portability. The fact that some historical utilities could not be changed (to avoid breaking existing applications) should not deter this future goal.

 

return to top of page
UNIX  is a registered Trademark of The Open Group.
POSIX  is a registered Trademark of The IEEE.
Copyright  2001-2016 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT ]
<<< Previous	Home	Next >>>


<<< Previous	Home	Next >>>
The Open Group Base Specifications Issue 7
IEEE Std 1003.1-2008, 2016 Edition
Copyright  2001-2016 The IEEE and The Open Group
3. Definitions
For the purposes of POSIX.1-2008, the following terms and definitions apply. The Authoritative Dictionary of IEEE Standards Terms, Seventh Edition should be referenced for terms not defined in this section.

Note:
No shading to denote extensions or options occurs in this chapter. Where the terms and definitions given in this chapter are used elsewhere in text related to extensions and options, they are shaded as appropriate.
3.1 Abortive Release
An abrupt termination of a network connection that may result in the loss of data.

3.2 Absolute Pathname
A pathname beginning with a single or more than two <slash> characters; see also Pathname.

Note:
Pathname Resolution is defined in detail in Pathname Resolution .
3.3 Access Mode
A particular form of access permitted to a file.

3.4 Additional File Access Control Mechanism
An implementation-defined mechanism that is layered upon the access control mechanisms defined here, but which do not grant permissions beyond those defined herein, although they may further restrict them.

Note:
File Access Permissions are defined in detail in File Access Permissions.
3.5 Address Space
The memory locations that can be referenced by a process or the threads of a process.

3.6 Advisory Information
An interface that advises the implementation on (portable) application behavior so that it can optimize the system.

3.7 Affirmative Response
An input string that matches one of the responses acceptable to the LC_MESSAGES category keyword yesexpr, matching an extended regular expression in the current locale.

Note:
The LC_MESSAGES category is defined in detail in LC_MESSAGES.
3.8 Alert
To cause the user's terminal to give some audible or visual indication that an error or some other event has occurred. When the standard output is directed to a terminal device, the method for alerting the terminal user is unspecified. When the standard output is not directed to a terminal device, the alert is accomplished by writing the alert to standard output (unless the utility description indicates that the use of standard output produces undefined results in this case).

3.9 Alert Character (<alert>)
A character that in the output stream should cause a terminal to alert its user via a visual or audible notification. It is the character designated by '\a' in the C language. It is unspecified whether this character is the exact sequence transmitted to an output device by the system to accomplish the alert function.

3.10 Alias Name
In the shell command language, a word consisting solely of underscores, digits, and alphabetics from the portable character set and any of the following characters: '!', '%', ',', '@'.

Implementations may allow other characters within alias names as an extension.

Note:
The Portable Character Set is defined in detail in Portable Character Set.
3.11 Alignment
A requirement that objects of a particular type be located on storage boundaries with addresses that are particular multiples of a byte address.

Note:
See also the ISO C standard, Section B3.
3.12 Alternate File Access Control Mechanism
An implementation-defined mechanism that is independent of the access control mechanisms defined herein, and which if enabled on a file may either restrict or extend the permissions of a given user. POSIX.1-2008 defines when such mechanisms can be enabled and when they are disabled.

Note:
File Access Permissions are defined in detail in File Access Permissions.
3.13 Alternate Signal Stack
Memory associated with a thread, established upon request by the implementation for a thread, separate from the thread signal stack, in which signal handlers responding to signals sent to that thread may be executed.

3.14 Ancillary Data
Protocol-specific, local system-specific, or optional information. The information can be both local or end-to-end significant, header information, part of a data portion, protocol-specific, and implementation or system-specific.

3.15 Angle Brackets
The characters '<' (left-angle-bracket) and '>' (right-angle-bracket). When used in the phrase "enclosed in angle brackets", the symbol '<' immediately precedes the object to be enclosed, and '>' immediately follows it. When describing these characters in the portable character set, the names <less-than-sign> and <greater-than-sign> are used.

3.16 Apostrophe Character (<apostrophe>)
The character designated by '\'' in the C language, also known as the single-quote character.

3.17 Application
A computer program that performs some desired function.

When the User Portability Utilities option is supported, requirements placed on applications relating to the use of standard utilities shall also apply to the actions of a user who is entering shell command language statements into an interactive shell.

3.18 Application Address
Endpoint address of a specific application.

3.19 Application Program Interface (API)
The definition of syntax and semantics for providing computer system services.

3.20 Appropriate Privileges
An implementation-defined means of associating privileges with a process with regard to the function calls, function call options, and the commands that need special privileges. There may be zero or more such means. These means (or lack thereof) are described in the conformance document.

Note:
Function calls are defined in the System Interfaces volume of POSIX.1-2008, and commands are defined in the Shell and Utilities volume of POSIX.1-2008.
3.21 Argument
In the shell command language, a parameter passed to a utility as the equivalent of a single string in the argv array created by one of the exec functions. An argument is one of the options, option-arguments, or operands following the command name.

Note:
The Utility Argument Syntax is defined in detail in Utility Argument Syntax and XCU Command Search and Execution.
In the C language, an expression in a function call expression or a sequence of preprocessing tokens in a function-like macro invocation.

3.22 Arm (a Timer)
To start a timer measuring the passage of time, enabling notifying a process when the specified time or time interval has passed.

3.23 Asterisk Character (<asterisk>)
The character '*'.

3.24 Async-Cancel-Safe Function
A function that may be safely invoked by an application while the asynchronous form of cancellation is enabled. No function is async-cancel-safe unless explicitly described as such.

3.25 Asynchronous Events
Events that occur independently of the execution of the application.

3.26 Asynchronous Input and Output
A functionality enhancement to allow an application process to queue data input and output commands with asynchronous notification of completion.

3.27 Async-Signal-Safe Function
A function that can be called, without restriction, from signal-catching functions. Note that, although there is no restriction on the calls themselves, for certain functions there are restrictions on subsequent behavior after the function is called from a signal-catching function. No function is async-signal-safe unless explicitly described as such.

Note:
Async-signal-safety is defined in detail in XSH Signal Actions .
3.28 Asynchronously-Generated Signal
A signal that is not attributable to a specific thread. Examples are signals sent via kill(), signals sent from the keyboard, and signals delivered to process groups. Being asynchronous is a property of how the signal was generated and not a property of the signal number. All signals may be generated asynchronously.

Note:
The kill() function is defined in detail in the System Interfaces volume of POSIX.1-2008.
3.29 Asynchronous I/O Completion
For an asynchronous read or write operation, when a corresponding synchronous read or write would have completed and when any associated status fields have been updated.

3.30 Asynchronous I/O Operation
An I/O operation that does not of itself cause the thread requesting the I/O to be blocked from further use of the processor.

This implies that the process and the I/O operation may be running concurrently.

3.31 Authentication
The process of validating a user or process to verify that the user or process is not a counterfeit.

3.32 Authorization
The process of verifying that a user or process has permission to use a resource in the manner requested.

To ensure security, the user or process would also need to be authenticated before granting access.

3.33 Background Job
See Background Process Group in Background Process Group (or Background Job).

3.34 Background Process
A process that is a member of a background process group.

3.35 Background Process Group (or Background Job)
Any process group, other than a foreground process group, that is a member of a session that has established a connection with a controlling terminal.

3.36 Backquote Character
The character '`', also known as <grave-accent>.

3.37 Backslash Character (<backslash>)
The character designated by '\\' in the C language, also known as reverse solidus.

3.38 Backspace Character (<backspace>)
A character that, in the output stream, should cause printing (or displaying) to occur one column position previous to the position about to be printed. If the position about to be printed is at the beginning of the current line, the behavior is unspecified. It is the character designated by '\b' in the C language. It is unspecified whether this character is the exact sequence transmitted to an output device by the system to accomplish the backspace function. The backspace defined here is not necessarily the ERASE special character.

Note:
Special Characters are defined in detail in Special Characters .
3.39 Barrier
A synchronization object that allows multiple threads to synchronize at a particular point in their execution.

3.40 Basename
For pathnames containing at least one filename: the final, or only, filename in the pathname. For pathnames consisting only of <slash> characters: either '/' or "//" if the pathname consists of exactly two <slash> characters, and '/' otherwise.

3.41 Basic Regular Expression (BRE)
A regular expression (see Regular Expression) used by the majority of utilities that select strings from a set of character strings.

Note:
Basic Regular Expressions are described in detail in Basic Regular Expressions.
3.42 Batch Access List
A list of user IDs and group IDs of those users and groups authorized to place batch jobs in a batch queue.

A batch access list is associated with a batch queue. A batch server uses the batch access list of a batch queue as one of the criteria in deciding to put a batch job in a batch queue.

3.43 Batch Administrator
A user that is authorized to modify all the attributes of queues and jobs and to change the status of a batch server.

3.44 Batch Client
A computational entity that utilizes batch services by making requests of batch servers.

Batch clients often provide the means by which users access batch services, although a batch server may act as a batch client by virtue of making requests of another batch server.

3.45 Batch Destination
The batch server in a batch system to which a batch job should be sent for processing.

Acceptance of a batch job at a batch destination is the responsibility of a receiving batch server. A batch destination may consist of a batch server-specific portion, a network-wide portion, or both. The batch server-specific portion is referred to as the "batch queue". The network-wide portion is referred to as a "batch server name".

3.46 Batch Destination Identifier
A string that identifies a specific batch destination.

A string of characters in the portable character set used to specify a particular batch destination.

Note:
The Portable Character Set is defined in detail in Portable Character Set.
3.47 Batch Directive
A line from a file that is interpreted by the batch server. The line is usually in the form of a comment and is an additional means of passing options to the qsub utility.

Note:
The qsub utility is defined in detail in the Shell and Utilities volume of POSIX.1-2008.
3.48 Batch Job
A set of computational tasks for a computing system.

Batch jobs are managed by batch servers.

Once created, a batch job may be executing or pending execution. A batch job that is executing has an associated session leader (a process) that initiates and monitors the computational tasks of the batch job.

3.49 Batch Job Attribute
A named data type whose value affects the processing of a batch job.

The values of the attributes of a batch job affect the processing of that job by the batch server that manages the batch job.

3.50 Batch Job Identifier
A unique name for a batch job. A name that is unique among all other batch job identifiers in a batch system and that identifies the batch server to which the batch job was originally submitted.

3.51 Batch Job Name
A label that is an attribute of a batch job. The batch job name is not necessarily unique.

3.52 Batch Job Owner
The username@ hostname of the user submitting the batch job, where username is a user name (see also User Name) and hostname is a network host name.

3.53 Batch Job Priority
A value specified by the user that may be used by an implementation to determine the order in which batch jobs are selected to be executed. Job priority has a numeric value in the range -1024 to 1023.

Note:
The batch job priority is not the execution priority (nice value) of the batch job.
3.54 Batch Job State
An attribute of a batch job which determines the types of requests that the batch server that manages the batch job can accept for the batch job. Valid states include QUEUED, RUNNING, HELD, WAITING, EXITING, and TRANSITING.

3.55 Batch Name Service
A service that assigns batch names that are unique within the batch name space, and that can translate a unique batch name into the location of the named batch entity.

3.56 Batch Name Space
The environment within which a batch name is known to be unique.

3.57 Batch Node
A host containing part or all of a batch system.

A batch node is a host meeting at least one of the following conditions:

Capable of executing a batch client

Contains a routing batch queue

Contains an execution batch queue

3.58 Batch Operator
A user that is authorized to modify some, but not all, of the attributes of jobs and queues, and may change the status of the batch server.

3.59 Batch Queue
A manageable object that represents a set of batch jobs and is managed by a single batch server.

Note:
A set of batch jobs is called a batch queue largely for historical reasons. Jobs are selected from the batch queue for execution based on attributes such as priority, resource requirements, and hold conditions.
See also XCU Batch Queues.

3.60 Batch Queue Attribute
A named data type whose value affects the processing of all batch jobs that are members of the batch queue.

A batch queue has attributes that affect the processing of batch jobs that are members of the batch queue.

3.61 Batch Queue Position
The place, relative to other jobs in the batch queue, occupied by a particular job in a batch queue. This is defined in part by submission time and priority; see also Batch Queue Priority.

3.62 Batch Queue Priority
The maximum job priority allowed for any batch job in a given batch queue.

The batch queue priority is set and may be changed by users with appropriate privileges. The priority is bounded in an implementation-defined manner.

3.63 Batch Rerunability
An attribute of a batch job indicating that it may be rerun after an abnormal termination from the beginning without affecting the validity of the results.

3.64 Batch Restart
The action of resuming the processing of a batch job from the point of the last checkpoint. Typically, this is done if the batch job has been interrupted because of a system failure.

3.65 Batch Server
A computational entity that provides batch services.

3.66 Batch Server Name
A string of characters in the portable character set used to specify a particular server in a network.

Note:
The Portable Character Set is defined in detail in Portable Character Set.
3.67 Batch Service
Computational and organizational services performed by a batch system on behalf of batch jobs.

Batch services are of two types: requested and deferred.

Note:
Batch Services are listed in XCU Batch Services Summary.
3.68 Batch Service Request
A solicitation of services from a batch client to a batch server.

A batch service request may entail the exchange of any number of messages between the batch client and the batch server.

When naming specific types of service requests, the term "request" is qualified by the type of request, as in Queue Batch Job Request and Delete Batch Job Request.

3.69 Batch Submission
The process by which a batch client requests that a batch server create a batch job via a Queue Job Request to perform a specified computational task.

3.70 Batch System
A collection of one or more batch servers.

3.71 Batch Target User
The name of a user on the batch destination batch server.

The target user is the user name under whose account the batch job is to execute on the destination batch server.

3.72 Batch User
A user who is authorized to make use of batch services.

3.73 Bind
The process of assigning a network address to an endpoint.

3.74 Blank Character (<blank>)
One of the characters that belong to the blank character class as defined via the LC_CTYPE category in the current locale. In the POSIX locale, a <blank> character is either a <tab> or a <space>.

3.75 Blank Line
A line consisting solely of zero or more <blank> characters terminated by a <newline>; see also Empty Line.

3.76 Blocked Process (or Thread)
A process (or thread) that is waiting for some condition (other than the availability of a processor) to be satisfied before it can continue execution.

3.77 Blocking
A property of an open file description that causes function calls associated with it to wait for the requested action to be performed before returning.

3.78 Block-Mode Terminal
A terminal device operating in a mode incapable of the character-at-a-time input and output operations described by some of the standard utilities.

Note:
Output Devices and Terminal Types are defined in detail in Output Devices and Terminal Types.
3.79 Block Special File
A file that refers to a device. A block special file is normally distinguished from a character special file by providing access to the device in a manner such that the hardware characteristics of the device are not visible.

3.80 Braces
The characters '{' (left-curly-bracket) and '}' (right-curly-bracket). When used in the phrase "enclosed in (curly) braces" the symbol '{' immediately precedes the object to be enclosed, and '}' immediately follows it. When describing these characters in the portable character set, the names <left-curly-bracket> and <left-brace> are used for '{', and <right-curly-bracket> and <right-brace> are used for '}'.

3.81 Brackets
The characters '[' (left-square-bracket) and ']' (right-square-bracket). When used in the phrase "enclosed in (square) brackets" the symbol '[' immediately precedes the object to be enclosed, and ']' immediately follows it. When describing these characters in the portable character set, the names <left-square-bracket> and <right-square-bracket> are used.

3.82 Broadcast
The transfer of data from one endpoint to several endpoints, as described in RFC 919 and RFC 922.

3.83 Built-In Utility (or Built-In)
A utility implemented within a shell. The utilities referred to as special built-ins have special qualities. Unless qualified, the term "built-in" includes the special built-in utilities. Regular built-ins are not required to be actually built into the shell on the implementation, but they do have special command-search qualities.

Note:
Special Built-In Utilities are defined in detail in XCU Special Built-In Utilities.
Regular Built-In Utilities are defined in detail in XCU Command Search and Execution.

3.84 Byte
An individually addressable unit of data storage that is exactly an octet, used to store a character or a portion of a character; see also Character. A byte is composed of a contiguous sequence of 8 bits. The least significant bit is called the "low-order" bit; the most significant is called the "high-order" bit.

Note:
The definition of byte from the ISO C standard is broader than the above and might accommodate hardware architectures with different sized addressable units than octets.
3.85 Byte Input/Output Functions
The functions that perform byte-oriented input from streams or byte-oriented output to streams: fgetc(), fgets(), fprintf(), fputc(), fputs(), fread(), fscanf(), fwrite(), getc(), getchar(), getdelim(), getline(), gets(), printf(), putc(), putchar(), puts(), scanf(), ungetc(), vfprintf(), and vprintf().

Note:
Functions are defined in detail in the System Interfaces volume of POSIX.1-2008.
3.86 Carriage-Return Character (<carriage-return>)
A character that in the output stream indicates that printing should start at the beginning of the same physical line in which the carriage-return occurred. It is the character designated by '\r' in the C language. It is unspecified whether this character is the exact sequence transmitted to an output device by the system to accomplish the movement to the beginning of the line.

3.87 Character
A sequence of one or more bytes representing a single graphic symbol or control code.

Note:
This term corresponds to the ISO C standard term multi-byte character, where a single-byte character is a special case of a multi-byte character. Unlike the usage in the ISO C standard, character here has no necessary relationship with storage space, and byte is used when storage space is discussed.
See the definition of the portable character set in Portable Character Set for a further explanation of the graphical representations of (abstract) characters, as opposed to character encodings.

3.88 Character Array
An array of elements of type char.

3.89 Character Class
A named set of characters sharing an attribute associated with the name of the class. The classes and the characters that they contain are dependent on the value of the LC_CTYPE category in the current locale.

Note:
The LC_CTYPE category is defined in detail in LC_CTYPE .
3.90 Character Set
A finite set of different characters used for the representation, organization, or control of data.

3.91 Character Special File
A file that refers to a device (such as a terminal device file) or that has special properties (such as /dev/null).

Note:
The General Terminal Interface is defined in detail in General Terminal Interface.
3.92 Character String
A contiguous sequence of characters terminated by and including the first null byte.

3.93 Child Process
A new process created (by fork(), posix_spawn(), or posix_spawnp()) by a given process. A child process remains the child of the creating process as long as both processes continue to exist.

Note:
The fork(), posix_spawn(), and posix_spawnp() functions are defined in detail in the System Interfaces volume of POSIX.1-2008.
3.94 Circumflex Character (<circumflex>)
The character '^'.

3.95 Clock
A software or hardware object that can be used to measure the apparent or actual passage of time.

The current value of the time measured by a clock can be queried and, possibly, set to a value within the legal range of the clock.

3.96 Clock Jump
The difference between two successive distinct values of a clock, as observed from the application via one of the "get time'' operations.

3.97 Clock Tick
An interval of time; an implementation-defined number of these occur each second. Clock ticks are one of the units that may be used to express a value found in type clock_t.

3.98 Coded Character Set
A set of unambiguous rules that establishes a character set and the one-to-one relationship between each character of the set and its bit representation.

3.99 Codeset
The result of applying rules that map a numeric code value to each element of a character set. An element of a character set may be related to more than one numeric code value but the reverse is not true. However, for state-dependent encodings the relationship between numeric code values and elements of a character set may be further controlled by state information. The character set may contain fewer elements than the total number of possible numeric code values; that is, some code values may be unassigned.

Note:
Character Encoding is defined in detail in Character Encoding.
3.100 Collating Element
The smallest entity used to determine the logical ordering of character or wide-character strings; see also Collation Sequence. A collating element consists of either a single character, or two or more characters collating as a single entity. The value of the LC_COLLATE category in the current locale determines the current set of collating elements.

3.101 Collation
The logical ordering of character or wide-character strings according to defined precedence rules. These rules identify a collation sequence between the collating elements, and such additional rules that can be used to order strings consisting of multiple collating elements.

3.102 Collation Sequence
The relative order of collating elements as determined by the setting of the LC_COLLATE category in the current locale. The collation sequence is used for sorting and is determined from the collating weights assigned to each collating element. In the absence of weights, the collation sequence is the order in which collating elements are specified between order_start and order_end keywords in the LC_COLLATE category.

Multi-level sorting is accomplished by assigning elements one or more collation weights, up to the limit {COLL_WEIGHTS_MAX}. On each level, elements may be given the same weight (at the primary level, called an equivalence class; see also Equivalence Class) or be omitted from the sequence. Strings that collate equally using the first assigned weight (primary ordering) are then compared using the next assigned weight (secondary ordering), and so on.

Note:
{COLL_WEIGHTS_MAX} is defined in detail in <limits.h>.
3.103 Column Position
A unit of horizontal measure related to characters in a line.

It is assumed that each character in a character set has an intrinsic column width independent of any output device. Each printable character in the portable character set has a column width of one. The standard utilities, when used as described in POSIX.1-2008, assume that all characters have integral column widths. The column width of a character is not necessarily related to the internal representation of the character (numbers of bits or bytes).

The column position of a character in a line is defined as one plus the sum of the column widths of the preceding characters in the line. Column positions are numbered starting from 1.

3.104 Command
A directive to the shell to perform a particular task.

Note:
Shell Commands are defined in detail in XCU Shell Commands.
3.105 Command Language Interpreter
An interface that interprets sequences of text input as commands. It may operate on an input stream or it may interactively prompt and read commands from a terminal. It is possible for applications to invoke utilities through a number of interfaces, which are collectively considered to act as command interpreters. The most obvious of these are the sh utility and the system() function, although popen() and the various forms of exec may also be considered to behave as interpreters.

Note:
The sh utility is defined in detail in the Shell and Utilities volume of POSIX.1-2008.
The system(), popen(), and exec functions are defined in detail in the System Interfaces volume of POSIX.1-2008.

3.106 Composite Graphic Symbol
A graphic symbol consisting of a combination of two or more other graphic symbols in a single character position, such as a diacritical mark and a base character.

3.107 Condition Variable
A synchronization object which allows a thread to suspend execution, repeatedly, until some associated predicate becomes true. A thread whose execution is suspended on a condition variable is said to be blocked on the condition variable.

3.108 Connected Socket
A connection-mode socket for which a connection has been established, or a connectionless-mode socket for which a peer address has been set. See also Connection, Connection Mode, Connectionless Mode, and Socket.

3.109 Connection
An association established between two or more endpoints for the transfer of data

3.110 Connection Mode
The transfer of data in the context of a connection; see also Connectionless Mode.

3.111 Connectionless Mode
The transfer of data other than in the context of a connection; see also Connection Mode and Datagram.

3.112 Control Character
A character, other than a graphic character, that affects the recording, processing, transmission, or interpretation of text.

3.113 Control Operator
In the shell command language, a token that performs a control function. It is one of the following symbols:

&   &&   (   )   ;   ;;   newline   |   ||

The end-of-input indicator used internally by the shell is also considered a control operator.

Note:
Token Recognition is defined in detail in XCU Token Recognition .
3.114 Controlling Process
The session leader that established the connection to the controlling terminal. If the terminal subsequently ceases to be a controlling terminal for this session, the session leader ceases to be the controlling process.

3.115 Controlling Terminal
A terminal that is associated with a session. Each session may have at most one controlling terminal associated with it, and a controlling terminal is associated with exactly one session. Certain input sequences from the controlling terminal cause signals to be sent to all processes in the foreground process group associated with the controlling terminal.

Note:
The General Terminal Interface is defined in detail in General Terminal Interface.
3.116 Conversion Descriptor
A per-process unique value used to identify an open codeset conversion.

3.117 Core File
A file of unspecified format that may be generated when a process terminates abnormally.

3.118 CPU Time (Execution Time)
The time spent executing a process or thread, including the time spent executing system services on behalf of that process or thread. If the Threads option is supported, then the value of the CPU-time clock for a process is implementation-defined. With this definition the sum of all the execution times of all the threads in a process might not equal the process execution time, even in a single-threaded process, because implementations may differ in how they account for time during context switches or for other reasons.

3.119 CPU-Time Clock
A clock that measures the execution time of a particular process or thread.

3.120 CPU-Time Timer
A timer attached to a CPU-time clock.

3.121 Current Job
In the context of job control, the job that will be used as the default for the fg or bg utilities. There is at most one current job; see also Job Control Job ID.

3.122 Current Working Directory
See Working Directory in Working Directory (or Current Working Directory).

3.123 Cursor Position
The line and column position on the screen denoted by the terminal's cursor.

3.124 Datagram
A unit of data transferred from one endpoint to another in connectionless mode service.

3.125 Data Segment
Memory associated with a process, that can contain dynamically allocated data.

3.126 Deferred Batch Service
A service that is performed as a result of events that are asynchronous with respect to requests.

Note:
Once a batch job has been created, it is subject to deferred services.
3.127 Device
A computer peripheral or an object that appears to the application as such.

3.128 Device ID
A non-negative integer used to identify a device.

3.129 Directory
A file that contains directory entries. No two directory entries in the same directory have the same name.

3.130 Directory Entry (or Link)
An object that associates a filename with a file. Several directory entries can associate names with the same file.

3.131 Directory Stream
A sequence of all the directory entries in a particular directory. An open directory stream may be implemented using a file descriptor.

3.132 Disarm (a Timer)
To stop a timer from measuring the passage of time, disabling any future process notifications (until the timer is armed again).

3.133 Display
To output to the user's terminal. If the output is not directed to a terminal, the results are undefined.

3.134 Display Line
A line of text on a physical device or an emulation thereof. Such a line will have a maximum number of characters which can be presented.

Note:
This may also be written as "line on the display".
3.135 Dollar-Sign Character (<dollar-sign>)
The character '$'.

3.136 Dot
In the context of naming files, the filename consisting of a single <period> character ( '.' ).

Note:
In the context of shell special built-in utilities, see dot in XCU Special Built-In Utilities.
Pathname Resolution is defined in detail in Pathname Resolution.

3.137 Dot-Dot
The filename consisting solely of two <period> characters ( ".." ).

Note:
Pathname Resolution is defined in detail in Pathname Resolution .
3.138 Double-Quote Character
The character '"' also known as <quotation-mark>.

Note:
The "double" adjective in this term refers to the two strokes in the character glyph. POSIX.1-2008 never uses the term "double-quote" to refer to two apostrophes or quotation-marks.
3.139 Downshifting
The conversion of an uppercase character that has a single-character lowercase representation into this lowercase representation.

3.140 Driver
A module that controls data transferred to and received from devices.

Note:
Drivers are traditionally written to be a part of the system implementation, although they are frequently written separately from the writing of the implementation. A driver may contain processor-specific code, and therefore be non-portable.
3.141 Effective Group ID
An attribute of a process that is used in determining various permissions, including file access permissions; see also Group ID.

3.142 Effective User ID
An attribute of a process that is used in determining various permissions, including file access permissions; see also User ID.

3.143 Eight-Bit Transparency
The ability of a software component to process 8-bit characters without modifying or utilizing any part of the character in a way that is inconsistent with the rules of the current coded character set.

3.144 Empty Directory
A directory that contains, at most, directory entries for dot and dot-dot, and has exactly one link to it (other than its own dot entry, if one exists), in dot-dot. No other links to the directory may exist. It is unspecified whether an implementation can ever consider the root directory to be empty.

3.145 Empty Line
A line consisting of only a <newline>; see also Blank Line.

3.146 Empty String (or Null String)
A string whose first byte is a null byte.

3.147 Empty Wide-Character String
A wide-character string whose first element is a null wide-character code.

3.148 Encoding Rule
The rules used to convert between wide-character codes and multi-byte character codes.

Note:
Stream Orientation and Encoding Rules are defined in detail in XSH Stream Orientation and Encoding Rules.
3.149 Entire Regular Expression
The concatenated set of one or more basic regular expressions or extended regular expressions that make up the pattern specified for string selection.

Note:
Regular Expressions are defined in detail in Regular Expressions.
3.150 Epoch
The time zero hours, zero minutes, zero seconds, on January 1, 1970 Coordinated Universal Time (UTC).

Note:
See also Seconds Since the Epoch defined in Seconds Since the Epoch.
3.151 Equivalence Class
A set of collating elements with the same primary collation weight.

Elements in an equivalence class are typically elements that naturally group together, such as all accented letters based on the same base letter.

The collation order of elements within an equivalence class is determined by the weights assigned on any subsequent levels after the primary weight.

3.152 Era
A locale-specific method for counting and displaying years.

Note:
The LC_TIME category is defined in detail in LC_TIME.
3.153 Event Management
The mechanism that enables applications to register for and be made aware of external events such as data becoming available for reading.

3.154 Executable File
A regular file acceptable as a new process image file by the equivalent of the exec family of functions, and thus usable as one form of a utility. The standard utilities described as compilers can produce executable files, but other unspecified methods of producing executable files may also be provided. The internal format of an executable file is unspecified, but a conforming application cannot assume an executable file is a text file.

3.155 Execute
To perform command search and execution actions, as defined in the Shell and Utilities volume of POSIX.1-2008; see also Invoke.

Note:
Command Search and Execution is defined in detail in XCU Command Search and Execution.
3.156 Execution Time
See CPU Time in CPU Time (Execution Time).

3.157 Execution Time Monitoring
A set of execution time monitoring primitives that allow online measuring of thread and process execution times.

3.158 Expand
In the shell command language, when not qualified, the act of applying word expansions.

Note:
Word Expansions are defined in detail in XCU wordexp.
3.159 Extended Regular Expression (ERE)
A regular expression (see also Regular Expression) that is an alternative to the Basic Regular Expression using a more extensive syntax, occasionally used by some utilities.

Note:
Extended Regular Expressions are described in detail in Extended Regular Expressions.
3.160 Extended Security Controls
Implementation-defined security controls allowed by the file access permission and appropriate privileges (see also Appropriate Privileges) mechanisms, through which an implementation can support different security policies from those described in POSIX.1-2008.

Note:
See also Extended Security Controls defined in Extended Security Controls.
File Access Permissions are defined in detail in File Access Permissions.

3.161 Feature Test Macro
A macro used to determine whether a particular set of features is included from a header.

Note:
See also XSH The Compilation Environment.
3.162 Field
In the shell command language, a unit of text that is the result of parameter expansion, arithmetic expansion, command substitution, or field splitting. During command processing, the resulting fields are used as the command name and its arguments.

Note:
Parameter Expansion is defined in detail in XCU Parameter Expansion.
Arithmetic Expansion is defined in detail in XCU Arithmetic Expansion.

Command Substitution is defined in detail in XCU Command Substitution.

Field Splitting is defined in detail in XCU Field Splitting.

For further information on command processing, see XCU Simple Commands.

3.163 FIFO Special File (or FIFO)
A type of file with the property that data written to such a file is read on a first-in-first-out basis.

Note:
Other characteristics of FIFOs are described in the System Interfaces volume of POSIX.1-2008, lseek(), open(), read(), and write().
3.164 File
An object that can be written to, or read from, or both. A file has certain attributes, including access permissions and type. File types include regular file, character special file, block special file, FIFO special file, symbolic link, socket, and directory. Other types of files may be supported by the implementation.

3.165 File Description
See Open File Description in Open File Description.

3.166 File Descriptor
A per-process unique, non-negative integer used to identify an open file for the purpose of file access. The value of a newly-created file descriptor is from zero to {OPEN_MAX}-1. A file descriptor can have a value greater than or equal to {OPEN_MAX} if the value of {OPEN_MAX} has decreased (see sysconf) since the file descriptor was opened. File descriptors may also be used to implement message catalog descriptors and directory streams; see also Open File Description.

Note:
{OPEN_MAX} is defined in detail in <limits.h>.
3.167 File Group Class
The property of a file indicating access permissions for a process related to the group identification of a process. A process is in the file group class of a file if the process is not in the file owner class and if the effective group ID or one of the supplementary group IDs of the process matches the group ID associated with the file. Other members of the class may be implementation-defined.

3.168 File Mode
An object containing the file mode bits and some information about the file type of a file.

Note:
File mode bits and file types are defined in detail in <sys/stat.h> .
3.169 File Mode Bits
A file's file permission bits, set-user-ID-on-execution bit (S_ISUID), set-group-ID-on-execution bit (S_ISGID), and, on directories, the restricted deletion flag bit (S_ISVTX).

Note:
File Mode Bits are defined in detail in <sys/stat.h>.
3.170 Filename
A sequence of bytes consisting of 1 to {NAME_MAX} bytes used to name a file. The bytes composing the name shall not contain the <NUL> or <slash> characters. In the context of a pathname, each filename shall be followed by a <slash> or a <NUL> character; elsewhere, a filename followed by a <NUL> character forms a string (but not necessarily a character string). The filenames dot and dot-dot have special meaning. A filename is sometimes referred to as a "pathname component". See also Pathname.

Note:
Pathname Resolution is defined in detail in Pathname Resolution .
3.171 Filename String
A string consisting of a filename followed by a <NUL> character.

3.172 File Offset
The byte position in the file where the next I/O operation begins. Each open file description associated with a regular file, block special file, or directory has a file offset. A character special file that does not refer to a terminal device may have a file offset. There is no file offset specified for a pipe or FIFO.

3.173 File Other Class
The property of a file indicating access permissions for a process related to the user and group identification of a process. A process is in the file other class of a file if the process is not in the file owner class or file group class.

3.174 File Owner Class
The property of a file indicating access permissions for a process related to the user identification of a process. A process is in the file owner class of a file if the effective user ID of the process matches the user ID of the file.

3.175 File Permission Bits
Information about a file that is used, along with other information, to determine whether a process has read, write, or execute/search permission to a file. The bits are divided into three parts: owner, group, and other. Each part is used with the corresponding file class of processes. These bits are contained in the file mode.

Note:
File modes are defined in detail in <sys/stat.h>.
File Access Permissions are defined in detail in File Access Permissions.

3.176 File Serial Number
A per-file system unique identifier for a file.

3.177 File System
A collection of files and certain of their attributes. It provides a name space for file serial numbers referring to those files.

3.178 File Type
See File in File.

3.179 Filter
A command whose operation consists of reading data from standard input or a list of input files and writing data to standard output. Typically, its function is to perform some transformation on the data stream.

3.180 First Open (of a File)
When a process opens a file that is not currently an open file within any process.

3.181 Flow Control
The mechanism employed by a communications provider that constrains a sending entity to wait until the receiving entities can safely receive additional data without loss.

3.182 Foreground Job
See Foreground Process Group in Foreground Process Group (or Foreground Job).

3.183 Foreground Process
A process that is a member of a foreground process group.

3.184 Foreground Process Group (or Foreground Job)
A process group whose member processes have certain privileges, denied to processes in background process groups, when accessing their controlling terminal. Each session that has established a connection with a controlling terminal has at most one process group of the session as the foreground process group of that controlling terminal.

Note:
The General Terminal Interface is defined in detail in General Terminal Interface.
3.185 Foreground Process Group ID
The process group ID of the foreground process group.

3.186 Form-Feed Character (<form-feed>)
A character that in the output stream indicates that printing should start on the next page of an output device. It is the character designated by '\f' in the C language. If the form-feed is not the first character of an output line, the result is unspecified. It is unspecified whether this character is the exact sequence transmitted to an output device by the system to accomplish the movement to the next page.

3.187 Graphic Character
A member of the graph character class of the current locale.

Note:
The graph character class is defined in detail in LC_CTYPE .
3.188 Group Database
A system database that contains at least the following information for each group ID:

Group name

Numerical group ID

List of users allowed in the group

The list of users allowed in the group is used by the newgrp utility.

Note:
The newgrp utility is defined in detail in the Shell and Utilities volume of POSIX.1-2008.
3.189 Group ID
A non-negative integer, which can be contained in an object of type gid_t, that is used to identify a group of system users. Each system user is a member of at least one group. When the identity of a group is associated with a process, a group ID value is referred to as a real group ID, an effective group ID, one of the supplementary group IDs, or a saved set-group-ID. The value (gid_t)-1 shall not be a valid group ID, but does have a defined use in some interfaces defined in this standard.

3.190 Group Name
A string that is used to identify a group; see also Group Database. To be portable across conforming systems, the value is composed of characters from the portable filename character set. The <hyphen-minus> should not be used as the first character of a portable group name.

3.191 Hard Limit
A system resource limitation that may be reset to a lesser or greater limit by a privileged process. A non-privileged process is restricted to only lowering its hard limit.

3.192 Hard Link
The relationship between two directory entries that represent the same file; see also Directory Entry (or Link). The result of an execution of the ln utility (without the -s option) or the link() function. This term is contrasted against symbolic link; see also Symbolic Link.

3.193 Home Directory
The directory specified by the HOME environment variable.

3.194 Host Byte Order
The arrangement of bytes in any integer type when using a specific machine architecture.

Note:
Two common methods of byte ordering are big-endian and little-endian. Big-endian is a format for storage of binary data in which the most significant byte is placed first, with the rest in descending order. Little-endian is a format for storage or transmission of binary data in which the least significant byte is placed first, with the rest in ascending order. See also Host and Network Byte Orders.
3.195 Incomplete Line
A sequence of one or more non- <newline> characters at the end of the file.

3.196 Inf
A value representing +infinity or a value representing -infinity that can be stored in a floating type. Not all systems support the Inf values.

3.197 Instrumented Application
An application that contains at least one call to the trace point function posix_trace_event(). Each process of an instrumented application has a mapping of trace event names to trace event type identifiers. This mapping is used by the trace stream that is created for that process.

3.198 Interactive Shell
A processing mode of the shell that is suitable for direct user interaction.

3.199 Internationalization
The provision within a computer program of the capability of making itself adaptable to the requirements of different native languages, local customs, and coded character sets.

3.200 Interprocess Communication
A functionality enhancement to add a high-performance, deterministic interprocess communication facility for local communication.

3.201 Invoke
To perform command search and execution actions, except that searching for shell functions and special built-in utilities is suppressed; see also Execute.

Note:
Command Search and Execution is defined in detail in XCU Command Search and Execution.
3.202 Job
A set of processes, comprising a shell pipeline, and any processes descended from it, that are all in the same process group.

Note:
See also XCU Pipelines.
3.203 Job Control
A facility that allows users selectively to stop (suspend) the execution of processes and continue (resume) their execution at a later point. The user typically employs this facility via the interactive interface jointly supplied by the terminal I/O driver and a command interpreter.

3.204 Job Control Job ID
A handle that is used to refer to a job. The job control job ID can be any of the forms shown in the following table:
Table: Job Control Job ID Formats
Job Control

 

Job ID

Meaning

%%

Current job.

%+

Current job.

%-

Previous job.

%n

Job number n.

%string

Job whose command begins with string.

%?string

Job whose command contains string.

3.205 Last Close (of a File)
When a process closes a file, resulting in the file not being an open file within any process.

3.206 Line
A sequence of zero or more non- <newline> characters plus a terminating <newline> character.

3.207 Linger
The period of time before terminating a connection, to allow outstanding data to be transferred.

3.208 Link
See Directory Entry in Directory Entry (or Link).

3.209 Link Count
The number of directory entries that refer to a particular file.

3.210 Live Process
An address space with one or more threads executing within that address space, and the required system resources for those threads.

Note:
Many of the system resources defined by POSIX.1-2008 are shared among all of the threads within a process. These include the process ID, the parent process ID, process group ID, session membership, real, effective, and saved set-user-ID, real, effective, and saved set-group-ID, supplementary group IDs, current working directory, root directory, file mode creation mask, and file descriptors.
3.211 Local Customs
The conventions of a geographical area or territory for such things as date, time, and currency formats.

3.212 Local Interprocess Communication (Local IPC)
The transfer of data between processes in the same system.

3.213 Locale
The definition of the subset of a user's environment that depends on language and cultural conventions.

Note:
Locales are defined in detail in Locale.
3.214 Localization
The process of establishing information within a computer system specific to the operation of particular native languages, local customs, and coded character sets.

3.215 Login
The unspecified activity by which a user gains access to the system. Each login is associated with exactly one login name.

3.216 Login Name
A user name that is associated with a login.

3.217 Map
To create an association between a page-aligned range of the address space of a process and some memory object, such that a reference to an address in that range of the address space results in a reference to the associated memory object. The mapped memory object is not necessarily memory-resident.

3.218 Marked Message
A STREAMs message on which a certain flag is set. Marking a message gives the application protocol-specific information. An application can use ioctl() to determine whether a given message is marked.

Note:
The ioctl() function is defined in detail in the System Interfaces volume of POSIX.1-2008.
3.219 Matched
A state applying to a sequence of zero or more characters when the characters in the sequence correspond to a sequence of characters defined by a basic regular expression or extended regular expression pattern.

Note:
Regular Expressions are defined in detail in Regular Expressions.
3.220 Memory Mapped Files
A facility to allow applications to access files as part of the address space.

3.221 Memory Object
One of:

A file (see File)

A shared memory object (see Shared Memory Object)

A typed memory object (see Typed Memory Object)

When used in conjunction with mmap(), a memory object appears in the address space of the calling process.

Note:
The mmap() function is defined in detail in the System Interfaces volume of POSIX.1-2008.
3.222 Memory-Resident
The process of managing the implementation in such a way as to provide an upper bound on memory access times.

3.223 Message
In the context of programmatic message passing, information that can be transferred between processes or threads by being added to and removed from a message queue. A message consists of a fixed-size message buffer.

3.224 Message Catalog
In the context of providing natural language messages to the user, a file or storage area containing program messages, command prompts, and responses to prompts for a particular native language, territory, and codeset.

3.225 Message Catalog Descriptor
In the context of providing natural language messages to the user, a per-process unique value used to identify an open message catalog. A message catalog descriptor may be implemented using a file descriptor.

3.226 Message Queue
In the context of programmatic message passing, an object to which messages can be added and removed. Messages may be removed in the order in which they were added or in priority order.

3.227 Mode
A collection of attributes that specifies a file's type and its access permissions.

Note:
File Access Permissions are defined in detail in File Access Permissions.
3.228 Monotonic Clock
A clock measuring real time, whose value cannot be set via clock_settime() and which cannot have negative clock jumps.

3.229 Mount Point
Either the system root directory or a directory for which the st_dev field of structure stat differs from that of its parent directory.

Note:
The stat structure is defined in detail in <sys/stat.h>.
3.230 Multi-Character Collating Element
A sequence of two or more characters that collate as an entity. For example, in some coded character sets, an accented character is represented by a non-spacing accent, followed by the letter. Other examples are the Spanish elements ch and ll.

3.231 Multi-Threaded Library
A library containing object files that were produced by compiling with c99 using the flags output by getconf POSIX_V7_THREADS_CFLAGS, or by compiling using a non-standard utility with equivalent flags, and which makes use of interfaces that are only made available by c99 when the -l pthread option is used or makes use of SIGEV_THREAD notifications.

3.232 Multi-Threaded Process
A process that contains more than one thread.

3.233 Multi-Threaded Program
A program whose executable file was produced by compiling with c99 using the flags output by getconf POSIX_V7_THREADS_CFLAGS, and linking with c99 using the flags output by getconf POSIX_V7_THREADS_LDFLAGS and the -l pthread option, or by compiling and linking using a non-standard utility with equivalent flags. Execution of a multi-threaded program initially creates a single-threaded process; the process can create additional threads using pthread_create() or SIGEV_THREAD notifications.

3.234 Mutex
A synchronization object used to allow multiple threads to serialize their access to shared data. The name derives from the capability it provides; namely, mutual-exclusion. The thread that has locked a mutex becomes its owner and remains the owner until that same thread unlocks the mutex.

3.235 Name
In the shell command language, a word consisting solely of underscores, digits, and alphabetics from the portable character set. The first character of a name is not a digit.

Note:
The Portable Character Set is defined in detail in Portable Character Set.
3.236 Named STREAM
A STREAMS-based file descriptor that is attached to a name in the file system name space. All subsequent operations on the named STREAM act on the STREAM that was associated with the file descriptor until the name is disassociated from the STREAM.

3.237 NaN (Not a Number)
A set of values that may be stored in a floating type but that are neither Inf nor valid floating-point numbers. Not all systems support NaN values.

3.238 Native Language
A computer user's spoken or written language, such as American English, British English, Danish, Dutch, French, German, Italian, Japanese, Norwegian, or Swedish.

3.239 Negative Response
An input string that matches one of the responses acceptable to the LC_MESSAGES category keyword noexpr, matching an extended regular expression in the current locale.

Note:
The LC_MESSAGES category is defined in detail in LC_MESSAGES.
3.240 Network
A collection of interconnected hosts.

Note:
The term "network" in POSIX.1-2008 is used to refer to the network of hosts. The term "batch system" is used to refer to the network of batch servers.
3.241 Network Address
A network-visible identifier used to designate specific endpoints in a network. Specific endpoints on host systems have addresses, and host systems may also have addresses.

3.242 Network Byte Order
The way of representing any integer type such that, when transmitted over a network via a network endpoint, the int type is transmitted as an appropriate number of octets with the most significant octet first, followed by any other octets in descending order of significance.

Note:
This order is more commonly known as big-endian ordering. See also Host and Network Byte Orders.
3.243 Newline Character (<newline>)
A character that in the output stream indicates that printing should start at the beginning of the next line. It is the character designated by '\n' in the C language. It is unspecified whether this character is the exact sequence transmitted to an output device by the system to accomplish the movement to the next line.

3.244 Nice Value
A number used as advice to the system to alter process scheduling. Numerically smaller values give a process additional preference when scheduling a process to run. Numerically larger values reduce the preference and make a process less likely to run. Typically, a process with a smaller nice value runs to completion more quickly than an equivalent process with a higher nice value. The symbol {NZERO} specifies the default nice value of the system.

3.245 Non-Blocking
A property of an open file description that causes function calls involving it to return without delay when it is detected that the requested action associated with the function call cannot be completed without unknown delay.

Note:
The exact semantics are dependent on the type of file associated with the open file description. For data reads from devices such as ttys and FIFOs, this property causes the read to return immediately when no data was available. Similarly, for writes, it causes the call to return immediately when the thread would otherwise be delayed in the write operation; for example, because no space was available. For networking, it causes functions not to await protocol events (for example, acknowledgements) to occur. See also XSH Socket I/O Mode.
3.246 Non-Spacing Characters
A character, such as a character representing a diacritical mark in the ISO/IEC 6937:1994 standard coded graphic character set, which is used in combination with other characters to form composite graphic symbols.

3.247 NUL
A character with all bits set to zero.

3.248 Null Byte
A byte with all bits set to zero.

3.249 Null Pointer
A pointer obtained by converting an integer constant expression with the value 0, or such an expression cast to type void *, to a pointer type; for example, (char *)0. The C language guarantees that a null pointer compares unequal to a pointer to any object or function, so it is used by many functions that return pointers to indicate an error.

3.250 Null String
See Empty String in Empty String (or Null String).

3.251 Null Wide-Character Code
A wide-character code with all bits set to zero.

3.252 Number-Sign Character (<number-sign>)
The character '#', also known as hash sign.

3.253 Object File
A regular file containing the output of a compiler, formatted as input to a linkage editor for linking with other object files into an executable form. The methods of linking are unspecified and may involve the dynamic linking of objects at runtime. The internal format of an object file is unspecified, but a conforming application cannot assume an object file is a text file.

3.254 Octet
Unit of data representation that consists of eight contiguous bits.

3.255 Offset Maximum
An attribute of an open file description representing the largest value that can be used as a file offset.

3.256 Opaque Address
An address such that the entity making use of it requires no details about its contents or format.

3.257 Open File
A file that is currently associated with a file descriptor.

3.258 Open File Description
A record of how a process or group of processes is accessing a file. Each file descriptor refers to exactly one open file description, but an open file description can be referred to by more than one file descriptor. The file offset, file status, and file access modes are attributes of an open file description.

3.259 Operand
An argument to a command that is generally used as an object supplying information to a utility necessary to complete its processing. Operands generally follow the options in a command line.

Note:
Utility Argument Syntax is defined in detail in Utility Argument Syntax.
3.260 Operator
In the shell command language, either a control operator or a redirection operator.

3.261 Option
An argument to a command that is generally used to specify changes in the utility's default behavior.

Note:
Utility Argument Syntax is defined in detail in Utility Argument Syntax.
3.262 Option-Argument
A parameter that follows certain options. In some cases an option-argument is included within the same argument string as the option-in most cases it is the next argument.

Note:
Utility Argument Syntax is defined in detail in Utility Argument Syntax.
3.263 Orientation
A stream has one of three orientations: unoriented, byte-oriented, or wide-oriented.

Note:
For further information, see XSH Stream Orientation and Encoding Rules.
3.264 Orphaned Process Group
A process group in which the parent of every member is either itself a member of the group or is not a member of the group's session.

3.265 Page
The granularity of process memory mapping or locking.

Physical memory and memory objects can be mapped into the address space of a process on page boundaries and in integral multiples of pages. Process address space can be locked into memory (made memory-resident) on page boundaries and in integral multiples of pages.

3.266 Page Size
The size, in bytes, of the system unit of memory allocation, protection, and mapping. On systems that have segment rather than page-based memory architectures, the term "page" means a segment.

3.267 Parameter
In the shell command language, an entity that stores values. There are three types of parameters: variables (named parameters), positional parameters, and special parameters. Parameter expansion is accomplished by introducing a parameter with the '$' character.

Note:
See also XCU Parameters and Variables.
In the C language, an object declared as part of a function declaration or definition that acquires a value on entry to the function, or an identifier following the macro name in a function-like macro definition.

3.268 Parent Directory
When discussing a given directory, the directory that both contains a directory entry for the given directory and is represented by the pathname dot-dot in the given directory.

When discussing other types of files, a directory containing a directory entry for the file under discussion.

This concept does not apply to dot and dot-dot.

3.269 Parent Process
The process which created (or inherited) the process under discussion.

3.270 Parent Process ID
An attribute of a new process identifying the parent of the process. The parent process ID of a process is the process ID of its creator, for the lifetime of the creator. After the creator's lifetime has ended, the parent process ID is the process ID of an implementation-defined system process.

3.271 Pathname
A string that is used to identify a file. In the context of POSIX.1-2008, a pathname may be limited to {PATH_MAX} bytes, including the terminating null byte. It has optional beginning <slash> characters, followed by zero or more filenames separated by <slash> characters. A pathname can optionally contain one or more trailing <slash> characters. Multiple successive <slash> characters are considered to be the same as one <slash>, except for the case of exactly two leading <slash> characters.

Note:
If a pathname consists of only bytes corresponding to characters from the portable filename character set (see Portable Filename Character Set), <slash> characters, and a single terminating <NUL> character, the pathname will be usable as a character string in all supported locales; otherwise, the pathname might only be a string (rather than a character string). Additionally, since the single-byte encoding of the <slash> character is required to be the same across all locales and to not occur within a multi-byte character, references to a <slash> character within a pathname are well-defined even when the pathname is not a character string. However, this property does not necessarily hold for the remaining characters within the portable filename character set.
Pathname Resolution is defined in detail in Pathname Resolution.

3.272 Pathname Component
See Filename in Filename.

3.273 Path Prefix
The part of a pathname up to, but not including, the last component and any trailing <slash> characters, unless the pathname consists entirely of <slash> characters, in which case the path prefix is '/' for a pathname containing either a single <slash> or three or more <slash> characters, and '//' for the pathname //. The path prefix of a pathname containing no <slash> characters is empty, but is treated as referring to the current working directory.

Note:
The term is used both in the sense of identifying part of a pathname that forms the prefix and of joining a non-empty path prefix to a filename to form a pathname. In the latter case, the path prefix need not have a trailing <slash> (in which case the joining is done with a <slash> character).
3.274 Pattern
A sequence of characters used either with regular expression notation or for pathname expansion, as a means of selecting various character strings or pathnames, respectively.

Note:
Regular Expressions are defined in detail in Regular Expressions.
See also XCU Pathname Expansion.

The syntaxes of the two types of patterns are similar, but not identical; POSIX.1-2008 always indicates the type of pattern being referred to in the immediate context of the use of the term.

3.275 Period Character (<period>)
The character '.'. The term "period" is contrasted with dot (see also Dot), which is used to describe a specific directory entry.

3.276 Permissions
Attributes of an object that determine the privilege necessary to access or manipulate the object.

Note:
File Access Permissions are defined in detail in File Access Permissions.
3.277 Persistence
A mode for semaphores, shared memory, and message queues requiring that the object and its state (including data, if any) are preserved after the object is no longer referenced by any process.

Persistence of an object does not imply that the state of the object is maintained across a system crash or a system reboot.

3.278 Pipe
An object identical to a FIFO which has no links in the file hierarchy.

Note:
The pipe() function is defined in detail in the System Interfaces volume of POSIX.1-2008.
3.279 Polling
A scheduling scheme whereby the local process periodically checks until the pre-specified events (for example, read, write) have occurred.

3.280 Portable Character Set
The collection of characters that are required to be present in all locales supported by conforming systems.

Note:
The Portable Character Set is defined in detail in Portable Character Set.
This term is contrasted against the smaller portable filename character set; see also Portable Filename Character Set.

3.281 Portable Filename
A filename consisting only of characters from the portable filename character set.

Note:
Applications should avoid using filenames that have the <hyphen-minus> character as the first character since this may cause problems when filenames are passed as command line arguments.
3.282 Portable Filename Character Set
The set of characters from which portable filenames are constructed.

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
a b c d e f g h i j k l m n o p q r s t u v w x y z
0 1 2 3 4 5 6 7 8 9 . _ -

The last three characters are the <period>, <underscore>, and <hyphen-minus> characters, respectively. See also Pathname.

3.283 Positional Parameter
In the shell command language, a parameter denoted by a single digit or one or more digits in curly braces.

Note:
For further information, see XCU Positional Parameters.
3.284 Preallocation
The reservation of resources in a system for a particular use.

Preallocation does not imply that the resources are immediately allocated to that use, but merely indicates that they are guaranteed to be available in bounded time when needed.

3.285 Preempted Process (or Thread)
A running thread whose execution is suspended due to another thread becoming runnable at a higher priority.

3.286 Previous Job
In the context of job control, the job that will be used as the default for the fg or bg utilities if the current job exits. There is at most one previous job; see also Job Control Job ID.

3.287 Printable Character
One of the characters included in the print character classification of the LC_CTYPE category in the current locale.

Note:
The LC_CTYPE category is defined in detail in LC_CTYPE .
3.288 Printable File
A text file consisting only of the characters included in the print and space character classifications of the LC_CTYPE category and the <backspace>, all in the current locale.

Note:
The LC_CTYPE category is defined in detail in LC_CTYPE .
3.289 Priority
A non-negative integer associated with processes or threads whose value is constrained to a range defined by the applicable scheduling policy. Numerically higher values represent higher priorities.

3.290 Priority Band
The queuing order applied to normal priority STREAMS messages. High priority STREAMS messages are not grouped by priority bands. The only differentiation made by the STREAMS mechanism is between zero and non-zero bands, but specific protocol modules may differentiate between priority bands.

3.291 Priority Inversion
A condition in which a thread that is not voluntarily suspended (waiting for an event or time delay) is not running while a lower priority thread is running. Such blocking of the higher priority thread is often caused by contention for a shared resource.

3.292 Priority Scheduling
A performance and determinism improvement facility to allow applications to determine the order in which threads that are ready to run are granted access to processor resources.

3.293 Priority-Based Scheduling
Scheduling in which the selection of a running thread is determined by the priorities of the runnable processes or threads.

3.294 Privilege
See Appropriate Privileges in Appropriate Privileges.

3.295 Process
A live process (see Live Process) or a zombie process (see Zombie Process ). The lifetime of a process is described in Process Lifetime.

3.296 Process Group
A collection of processes that permits the signaling of related processes. Each process in the system is a member of a process group that is identified by a process group ID. A newly created process joins the process group of its creator.

3.297 Process Group ID
The unique positive integer identifier representing a process group during its lifetime.

Note:
See also Process Group ID Reuse defined in Process ID Reuse .
3.298 Process Group Leader
A process whose process ID is the same as its process group ID.

3.299 Process Group Lifetime
The period of time that begins when a process group is created and ends when the last remaining process in the group leaves the group, due either to the end of the lifetime of the last process or to the last remaining process calling the setsid() or setpgid() functions.

Note:
The setsid() and setpgid() functions are defined in detail in the System Interfaces volume of POSIX.1-2008.
3.300 Process ID
The unique positive integer identifier representing a process during its lifetime.

Note:
See also Process ID Reuse defined in Process ID Reuse.
3.301 Process Lifetime
The period of time that begins when a process is created and ends when its process ID is returned to the system.

See also Live Process, Process Termination, and Zombie Process.

Note:
Process creation is defined in detail in the descriptions of the fork(), posix_spawn(), and posix_spawnp() functions in the System Interfaces volume of POSIX.1-2008.
3.302 Process Memory Locking
A performance improvement facility to bind application programs into the high-performance random access memory of a computer system. This avoids potential latencies introduced by the operating system in storing parts of a program that were not recently referenced on secondary memory devices.

3.303 Process Termination
There are two kinds of process termination:

Normal termination occurs by a return from main(), when requested with the exit(), _exit(), or _Exit() functions; or when the last thread in the process terminates by returning from its start function, by calling the pthread_exit() function, or through cancellation.

Abnormal termination occurs when requested by the abort() function or when some signals are received.

Note:
The consequences of process termination can be found in the description of the _Exit() function in the System Interfaces volume of POSIX.1-2008. The _exit(), _Exit(), abort(), and exit() functions are defined in detail in the System Interfaces volume of POSIX.1-2008.
3.304 Process-To-Process Communication
The transfer of data between processes.

3.305 Process Virtual Time
The measurement of time in units elapsed by the system clock while a process is executing.

3.306 Program
A prepared sequence of instructions to the system to accomplish a defined task. The term "program" in POSIX.1-2008 encompasses applications written in the Shell Command Language, complex utility input languages (for example, awk, lex, sed, and so on), and high-level languages.

3.307 Protocol
A set of semantic and syntactic rules for exchanging information.

3.308 Pseudo-Terminal
A facility that provides an interface that is identical to the terminal subsystem, except where noted otherwise in POSIX.1-2008. A pseudo-terminal is composed of two devices: the "master device" and a "slave device". The slave device provides processes with an interface that is identical to the terminal interface, although there need not be hardware behind that interface. Anything written on the master device is presented to the slave as an input and anything written on the slave device is presented as an input on the master side.

3.309 Radix Character
The character that separates the integer part of a number from the fractional part.

3.310 Read-Only File System
A file system that has implementation-defined characteristics restricting modifications.

Note:
File Times Update is described in detail in File Times Update.
3.311 Read-Write Lock
Multiple readers, single writer (read-write) locks allow many threads to have simultaneous read-only access to data while allowing only one thread to have write access at any given time. They are typically used to protect data that is read-only more frequently than it is changed.

Read-write locks can be used to synchronize threads in the current process and other processes if they are allocated in memory that is writable and shared among the cooperating processes and have been initialized for this behavior.

3.312 Real Group ID
The attribute of a process that, at the time of process creation, identifies the group of the user who created the process; see also Group ID.

3.313 Real Time
Time measured as total units elapsed by the system clock without regard to which thread is executing.

3.314 Realtime Signal Extension
A determinism improvement facility to enable asynchronous signal notifications to an application to be queued without impacting compatibility with the existing signal functions.

3.315 Real User ID
The attribute of a process that, at the time of process creation, identifies the user who created the process; see also User ID.

3.316 Record
A collection of related data units or words which is treated as a unit.

3.317 Redirection
In the shell command language, a method of associating files with the input or output of commands.

Note:
For further information, see XCU Redirection.
3.318 Redirection Operator
In the shell command language, a token that performs a redirection function. It is one of the following symbols:

<     >     >|     <<     >>     <&     >&     <<-     <>

3.319 Referenced Shared Memory Object
A shared memory object that is open or has one or more mappings defined on it.

3.320 Refresh
To ensure that the information on the user's terminal screen is up-to-date.

3.321 Regular Expression
A pattern that selects specific strings from a set of character strings.

Note:
Regular Expressions are described in detail in Regular Expressions .
3.322 Region
In the context of the address space of a process, a sequence of addresses.

In the context of a file, a sequence of offsets.

3.323 Regular File
A file that is a randomly accessible sequence of bytes, with no further structure imposed by the system.

3.324 Relative Pathname
A pathname not beginning with a <slash> character.

Note:
Pathname Resolution is defined in detail in Pathname Resolution .
3.325 Relocatable File
A file holding code or data suitable for linking with other object files to create an executable or a shared object file.

3.326 Relocation
The process of connecting symbolic references with symbolic definitions. For example, when a program calls a function, the associated call instruction transfers control to the proper destination address at execution.

3.327 Requested Batch Service
A service that is either rejected or performed prior to a response from the service to the requester.

3.328 (Time) Resolution
The minimum time interval that a clock can measure or whose passage a timer can detect.

3.329 Robust Mutex
A mutex with the robust attribute set.

Note:
The robust attribute is defined in detail by the pthread_mutexattr_getrobust() function.
3.330 Root Directory
A directory, associated with a process, that is used in pathname resolution for pathnames that begin with a <slash> character.

3.331 Runnable Process (or Thread)
A thread that is capable of being a running thread, but for which no processor is available.

3.332 Running Process (or Thread)
A thread currently executing on a processor. On multi-processor systems there may be more than one such thread in a system at a time.

3.333 Saved Resource Limits
An attribute of a process that provides some flexibility in the handling of unrepresentable resource limits, as described in the exec family of functions and setrlimit().

Note:
The exec and setrlimit() functions are defined in detail in the System Interfaces volume of POSIX.1-2008.
3.334 Saved Set-Group-ID
An attribute of a process that allows some flexibility in the assignment of the effective group ID attribute, as described in the exec family of functions and setgid().

Note:
The exec and setgid() functions are defined in detail in the System Interfaces volume of POSIX.1-2008.
3.335 Saved Set-User-ID
An attribute of a process that allows some flexibility in the assignment of the effective user ID attribute, as described in the exec family of functions and setuid().

Note:
The exec and setuid() functions are defined in detail in the System Interfaces volume of POSIX.1-2008.
3.336 Scheduling
The application of a policy to select a runnable process or thread to become a running process or thread, or to alter one or more of the thread lists.

3.337 Scheduling Allocation Domain
The set of processors on which an individual thread can be scheduled at any given time.

3.338 Scheduling Contention Scope
A property of a thread that defines the set of threads against which that thread competes for resources.

For example, in a scheduling decision, threads sharing scheduling contention scope compete for processor resources. In POSIX.1-2008, a thread has scheduling contention scope of either PTHREAD_SCOPE_SYSTEM or PTHREAD_SCOPE_PROCESS.

3.339 Scheduling Policy
A set of rules that is used to determine the order of execution of processes or threads to achieve some goal.

Note:
Scheduling Policy is defined in detail in Scheduling Policy.
3.340 Screen
A rectangular region of columns and lines on a terminal display. A screen may be a portion of a physical display device or may occupy the entire physical area of the display device.

3.341 Scroll
To move the representation of data vertically or horizontally relative to the terminal screen. There are two types of scrolling:

The cursor moves with the data.

The cursor remains stationary while the data moves.

3.342 Semaphore
A minimum synchronization primitive to serve as a basis for more complex synchronization mechanisms to be defined by the application program.

Note:
Semaphores are defined in detail in Semaphore.
3.343 Session
A collection of process groups established for job control purposes. Each process group is a member of a session. A process is considered to be a member of the session of which its process group is a member. A newly created process joins the session of its creator. A process can alter its session membership; see setsid(). There can be multiple process groups in the same session.

Note:
The setsid() function is defined in detail in the System Interfaces volume of POSIX.1-2008.
3.344 Session Leader
A process that has created a session.

Note:
For further information, see the setsid() function defined in the System Interfaces volume of POSIX.1-2008.
3.345 Session Lifetime
The period between when a session is created and the end of the lifetime of all the process groups that remain as members of the session.

3.346 Shared Memory Object
An object that represents memory that can be mapped concurrently into the address space of more than one process.

3.347 Shell
A program that interprets sequences of text input as commands. It may operate on an input stream or it may interactively prompt and read commands from a terminal.

3.348 Shell, the
The Shell Command Language Interpreter; a specific instance of a shell.

Note:
For further information, see the sh utility defined in the Shell and Utilities volume of POSIX.1-2008.
3.349 Shell Script
A file containing shell commands. If the file is made executable, it can be executed by specifying its name as a simple command. Execution of a shell script causes a shell to execute the commands within the script. Alternatively, a shell can be requested to execute the commands in a shell script by specifying the name of the shell script as the operand to the sh utility.

Note:
Simple Commands are defined in detail in XCU Simple Commands.
The sh utility is defined in detail in the Shell and Utilities volume of POSIX.1-2008.

3.350 Signal
A mechanism by which a process or thread may be notified of, or affected by, an event occurring in the system. Examples of such events include hardware exceptions and specific actions by processes. The term signal is also used to refer to the event itself.

3.351 Signal Stack
Memory established for a thread, in which signal handlers catching signals sent to that thread are executed.

3.352 Single-Quote Character
The character designated by '\'' in the C language, also known as <apostrophe>.

3.353 Single-Threaded Process
A process that contains a single thread.

3.354 Single-Threaded Program
A program whose executable file was produced by compiling with c99 without using the flags output by getconf POSIX_V7_THREADS_CFLAGS and linking with c99 using neither the flags output by getconf POSIX_V7_THREADS_LDFLAGS nor the -l pthread option, or by compiling and linking using a non-standard utility with equivalent flags. Execution of a single-threaded program creates a single-threaded process; if the process attempts to create additional threads using pthread_create() or SIGEV_THREAD notifications, the behavior is undefined. If the process uses dlopen() to load a multi-threaded library, the behavior is undefined.

3.355 Slash Character (<slash>)
The character '/', also known as solidus.

3.356 Socket
A file of a particular type that is used as a communications endpoint for process-to-process communication as described in the System Interfaces volume of POSIX.1-2008.

3.357 Socket Address
An address associated with a socket or remote endpoint, including an address family identifier and addressing information specific to that address family. The address may include multiple parts, such as a network address associated with a host system and an identifier for a specific endpoint.

3.358 Soft Limit
A resource limitation established for each process that the process may set to any value less than or equal to the hard limit.

3.359 Source Code
When dealing with the Shell Command Language, input to the command language interpreter. The term "shell script" is synonymous with this meaning.

When dealing with an ISO/IEC-conforming programming language, source code is input to a compiler conforming to that ISO/IEC standard.

Source code also refers to the input statements prepared for the following standard utilities: awk, bc, ed, ex, lex, localedef, make, sed, and yacc.

Source code can also refer to a collection of sources meeting any or all of these meanings.

Note:
The awk, bc, ed, ex, lex, localedef, make, sed, and yacc utilities are defined in detail in the Shell and Utilities volume of POSIX.1-2008.
3.360 Space Character (<space>)
The character defined in the portable character set as <space>. The <space> character is a member of the space character class of the current locale, but represents the single character, and not all of the possible members of the class; see also White Space.

3.361 Spawn
A process creation primitive useful for systems that have difficulty with fork() and as an efficient replacement for fork()/ exec.

3.362 Special Built-In
See Built-In Utility in Built-In Utility (or Built-In).

3.363 Special Parameter
In the shell command language, a parameter named by a single character from the following list:

*   @   #   ?   !   -   $   0

Note:
For further information, see XCU Special Parameters.
3.364 Spin Lock
A synchronization object used to allow multiple threads to serialize their access to shared data.

3.365 Sporadic Server
A scheduling policy for threads and processes that reserves a certain amount of execution capacity for processing aperiodic events at a given priority level.

3.366 Standard Error
An output stream usually intended to be used for diagnostic messages.

3.367 Standard Input
An input stream usually intended to be used for primary data input.

3.368 Standard Output
An output stream usually intended to be used for primary data output.

3.369 Standard Utilities
The utilities described in the Shell and Utilities volume of POSIX.1-2008.

3.370 Stream
Appearing in lowercase, a stream is a file access object that allows access to an ordered sequence of characters, as described by the ISO C standard. Such objects can be created by the fdopen(), fmemopen(), fopen(), open_memstream(), or popen() functions, and are associated with a file descriptor. A stream provides the additional services of user-selectable buffering and formatted input and output; see also STREAM.

Note:
For further information, see XSH Standard I/O Streams.
The fdopen(), fmemopen(), fopen(), open_memstream(), and popen() functions are defined in detail in the System Interfaces volume of POSIX.1-2008.

3.371 STREAM
Appearing in uppercase, STREAM refers to a full-duplex connection between a process and an open device or pseudo-device. It optionally includes one or more intermediate processing modules that are interposed between the process end of the STREAM and the device driver (or pseudo-device driver) end of the STREAM; see also Stream.

Note:
For further information, see XSH STREAMS.
3.372 STREAM End
The STREAM end is the driver end of the STREAM and is also known as the downstream end of the STREAM.

3.373 STREAM Head
The STREAM head is the beginning of the STREAM and is at the boundary between the system and the application process. This is also known as the upstream end of the STREAM.

3.374 STREAMS Multiplexor
A driver with multiple STREAMS connected to it. Multiplexing with STREAMS connected above is referred to as N-to-1, or "upper multiplexing". Multiplexing with STREAMS connected below is referred to as 1-to-N or "lower multiplexing".

3.375 String
A contiguous sequence of bytes terminated by and including the first null byte.

3.376 Subshell
A shell execution environment, distinguished from the main or current shell execution environment.

Note:
For further information, see XCU Shell Execution Environment.
3.377 Successfully Transferred
For a write operation to a regular file, when the system ensures that all data written is readable on any subsequent open of the file (even one that follows a system or power failure) in the absence of a failure of the physical storage medium.

For a read operation, when an image of the data on the physical storage medium is available to the requesting process.

3.378 Supplementary Group ID
An attribute of a process used in determining file access permissions. A process has up to {NGROUPS_MAX} supplementary group IDs in addition to the effective group ID. The supplementary group IDs of a process are set to the supplementary group IDs of the parent process when the process is created.

3.379 Suspended Job
A job that has received a SIGSTOP, SIGTSTP, SIGTTIN, or SIGTTOU signal that caused the process group to stop. A suspended job is a background job, but a background job is not necessarily a suspended job.

3.380 Symbolic Constant
An object-like macro defined with a constant value.

Unless stated otherwise, the following shall apply to every symbolic constant:

It expands to a compile-time constant expression with an integer type.

It may be defined as another type of constant-e.g., an enumeration constant-as well as being a macro.

It need not be usable in #if preprocessing directives.

3.381 Symbolic Link
A type of file with the property that when the file is encountered during pathname resolution, a string stored by the file is used to modify the pathname resolution. The stored string has a length of {SYMLINK_MAX} bytes or fewer.

Note:
Pathname Resolution is defined in detail in Pathname Resolution .
3.382 Synchronized Input and Output
A determinism and robustness improvement mechanism to enhance the data input and output mechanisms, so that an application can ensure that the data being manipulated is physically present on secondary mass storage devices.

3.383 Synchronized I/O Completion
The state of an I/O operation that has either been successfully transferred or diagnosed as unsuccessful.

3.384 Synchronized I/O Data Integrity Completion
For read, when the operation has been completed or diagnosed if unsuccessful. The read is complete only when an image of the data has been successfully transferred to the requesting process. If there were any pending write requests affecting the data to be read at the time that the synchronized read operation was requested, these write requests are successfully transferred prior to reading the data.

For write, when the operation has been completed or diagnosed if unsuccessful. The write is complete only when the data specified in the write request is successfully transferred and all file system information required to retrieve the data is successfully transferred.

File attributes that are not necessary for data retrieval (access time, modification time, status change time) need not be successfully transferred prior to returning to the calling process.

3.385 Synchronized I/O File Integrity Completion
Identical to a synchronized I/O data integrity completion with the addition that all file attributes relative to the I/O operation (including access time, modification time, status change time) are successfully transferred prior to returning to the calling process.

3.386 Synchronized I/O Operation
An I/O operation performed on a file that provides the application assurance of the integrity of its data and files.

3.387 Synchronous I/O Operation
An I/O operation that causes the thread requesting the I/O to be blocked from further use of the processor until that I/O operation completes.

Note:
A synchronous I/O operation does not imply synchronized I/O data integrity completion or synchronized I/O file integrity completion.
3.388 Synchronously-Generated Signal
A signal that is attributable to a specific thread.

For example, a thread executing an illegal instruction or touching invalid memory causes a synchronously-generated signal. Being synchronous is a property of how the signal was generated and not a property of the signal number.

3.389 System
An implementation of POSIX.1-2008.

3.390 System Boot
An unspecified sequence of events that may result in the loss of transitory data; that is, data that is not saved in permanent storage. For example, message queues, shared memory, semaphores, and processes.

3.391 System Clock
A clock with at least one second resolution that contains seconds since the Epoch.

3.392 System Console
A device that receives messages sent by the syslog() function, and the fmtmsg() function when the MM_CONSOLE flag is set.

Note:
The syslog() and fmtmsg() functions are defined in detail in the System Interfaces volume of POSIX.1-2008.
3.393 System Crash
An interval initiated by an unspecified circumstance that causes all processes (possibly other than special system processes) to be terminated in an undefined manner, after which any changes to the state and contents of files created or written to by an application prior to the interval are undefined, except as required elsewhere in POSIX.1-2008.

3.394 System Databases
An implementation provides two system databases: the "group database" (see also Group Database) and the "user database" (see also User Database).

3.395 System Documentation
All documentation provided with an implementation except for the conformance document. Electronically distributed documents for an implementation are considered part of the system documentation.

3.396 System Process
An object other than a process executing an application, that is provided by the system and has a process ID.

3.397 System Reboot
See System Boot defined in System Boot.

3.398 System Trace Event
A trace event that is generated by the implementation, in response either to a system-initiated action or to an application-requested action, except for a call to posix_trace_event(). When supported by the implementation, a system-initiated action generates a process-independent system trace event and an application-requested action generates a process-dependent system trace event. For a system trace event not defined by POSIX.1-2008, the associated trace event type identifier is derived from the implementation-defined name for this trace event, and the associated data is of implementation-defined content and length.

3.399 System-Wide
Pertaining to events occurring in all processes existing in an implementation at a given point in time.

3.400 Tab Character (<tab>)
A character that in the output stream indicates that printing or displaying should start at the next horizontal tabulation position on the current line. It is the character designated by '\t' in the C language. If the current position is at or past the last defined horizontal tabulation position, the behavior is unspecified. It is unspecified whether this character is the exact sequence transmitted to an output device by the system to accomplish the tabulation.

3.401 Terminal (or Terminal Device)
A character special file that obeys the specifications of the general terminal interface.

Note:
The General Terminal Interface is defined in detail in General Terminal Interface.
3.402 Text Column
A roughly rectangular block of characters capable of being laid out side-by-side next to other text columns on an output page or terminal screen. The widths of text columns are measured in column positions.

3.403 Text File
A file that contains characters organized into zero or more lines. The lines do not contain NUL characters and none can exceed {LINE_MAX} bytes in length, including the <newline> character. Although POSIX.1-2008 does not distinguish between text files and binary files (see the ISO C standard), many utilities only produce predictable or meaningful output when operating on text files. The standard utilities that have such restrictions always specify "text files" in their STDIN or INPUT FILES sections.

3.404 Thread
A single flow of control within a process. Each thread has its own thread ID, scheduling priority and policy, errno value, floating point environment, thread-specific key/value bindings, and the required system resources to support a flow of control. Anything whose address may be determined by a thread, including but not limited to static variables, storage obtained via malloc(), directly addressable storage obtained through implementation-defined functions, and automatic variables, are accessible to all threads in the same process.

Note:
The malloc() function is defined in detail in the System Interfaces volume of POSIX.1-2008.
3.405 Thread ID
Each thread in a process is uniquely identified during its lifetime by a value of type pthread_t called a thread ID.

3.406 Thread List
An ordered set of runnable threads that all have the same ordinal value for their priority.

The ordering of threads on the list is determined by a scheduling policy or policies. The set of thread lists includes all runnable threads in the system.

3.407 Thread-Safe
A thread-safe function can be safely invoked concurrently with other calls to the same function, or with calls to any other thread-safe functions, by multiple threads. Each function defined in the System Interfaces volume of POSIX.1-2008 is thread-safe unless explicitly stated otherwise. Examples are any "pure" function, a function which holds a mutex locked while it is accessing static storage, or objects shared among threads.

3.408 Thread-Specific Data Key
A process global handle of type pthread_key_t which is used for naming thread-specific data.

Although the same key value may be used by different threads, the values bound to the key by pthread_setspecific() and accessed by pthread_getspecific() are maintained on a per-thread basis and persist for the life of the calling thread.

Note:
The pthread_getspecific() and pthread_setspecific() functions are defined in detail in the System Interfaces volume of POSIX.1-2008.
3.409 Tilde Character (<tilde>)
The character ''.

3.410 Timeouts
A method of limiting the length of time an interface will block; see also Blocked Process (or Thread) .

3.411 Timer
A mechanism that can notify a thread when the time as measured by a particular clock has reached or passed a specified value, or when a specified amount of time has passed.

3.412 Timer Overrun
A condition that occurs each time a timer, for which there is already an expiration signal queued to the process, expires.

3.413 Token
In the shell command language, a sequence of characters that the shell considers as a single unit when reading input. A token is either an operator or a word.

Note:
The rules for reading input are defined in detail in XCU Token Recognition.
3.414 Trace Analyzer Process
A process that extracts trace events from a trace stream to retrieve information about the behavior of an application.

3.415 Trace Controller Process
A process that creates a trace stream for tracing a process.

3.416 Trace Event
A data object that represents an action executed by the system, and that is recorded in a trace stream.

3.417 Trace Event Type
A data object type that defines a class of trace event.

3.418 Trace Event Type Mapping
A one-to-one mapping between trace event types and trace event names.

3.419 Trace Filter
A filter that allows the trace controller process to specify those trace event types that are to be ignored; that is, not generated.

3.420 Trace Generation Version
A data object that is an implementation-defined character string, generated by the trace system and describing the origin and version of the trace system.

3.421 Trace Log
The flushed image of a trace stream, if the trace stream is created with a trace log.

3.422 Trace Point
An action that may cause a trace event to be generated.

3.423 Trace Stream
An opaque object that contains trace events plus internal data needed to interpret those trace events.

3.424 Trace Stream Identifier
A handle to manage tracing operations in a trace stream.

3.425 Trace System
A system that allows both system and user trace events to be generated into a trace stream. These trace events can be retrieved later.

3.426 Traced Process
A process for which at least one trace stream has been created. A traced process is also called a target process.

3.427 Tracing Status of a Trace Stream
A status that describes the state of an active trace stream. The tracing status of a trace stream can be retrieved from the trace stream attributes. An active trace stream can be in one of two states: running or suspended.

3.428 Typed Memory Name Space
A system-wide name space that contains the names of the typed memory objects present in the system. It is configurable for a given implementation.

3.429 Typed Memory Object
A combination of a typed memory pool and a typed memory port. The entire contents of the pool are accessible from the port. The typed memory object is identified through a name that belongs to the typed memory name space.

3.430 Typed Memory Pool
An extent of memory with the same operational characteristics. Typed memory pools may be contained within each other.

3.431 Typed Memory Port
A hardware access path to one or more typed memory pools.

3.432 Unbind
Remove the association between a network address and an endpoint.

3.433 Unit Data
See Datagram in Datagram.

3.434 Upshifting
The conversion of a lowercase character that has a single-character uppercase representation into this uppercase representation.

3.435 User Database
A system database that contains at least the following information for each user ID:

User name

Numerical user ID

Initial numerical group ID

Initial working directory

Initial user program

The initial numerical group ID is used by the newgrp utility. Any other circumstances under which the initial values are operative are implementation-defined.

If the initial user program field is null, an implementation-defined program is used.

If the initial working directory field is null, the interpretation of that field is implementation-defined.

Note:
The newgrp utility is defined in detail in the Shell and Utilities volume of POSIX.1-2008.
3.436 User ID
A non-negative integer that is used to identify a system user. When the identity of a user is associated with a process, a user ID value is referred to as a real user ID, an effective user ID, or a saved set-user-ID. The value (uid_t)-1 shall not be a valid user ID, but does have a defined use in some interfaces defined in this standard.

3.437 User Name
A string that is used to identify a user; see also User Database. To be portable across systems conforming to POSIX.1-2008, the value is composed of characters from the portable filename character set. The <hyphen-minus> character should not be used as the first character of a portable user name.

3.438 User Trace Event
A trace event that is generated explicitly by the application as a result of a call to posix_trace_event().

3.439 Utility
A program, excluding special built-in utilities provided as part of the Shell Command Language, that can be called by name from a shell to perform a specific task, or related set of tasks.

Note:
For further information on special built-in utilities, see XCU Special Built-In Utilities.
3.440 Variable
In the shell command language, a named parameter.

Note:
For further information, see XCU Parameters and Variables.
3.441 Vertical-Tab Character (<vertical-tab>)
A character that in the output stream indicates that printing should start at the next vertical tabulation position. It is the character designated by '\v' in the C language. If the current position is at or past the last defined vertical tabulation position, the behavior is unspecified. It is unspecified whether this character is the exact sequence transmitted to an output device by the system to accomplish the tabulation.

3.442 White Space
A sequence of one or more characters that belong to the space character class as defined via the LC_CTYPE category in the current locale.

In the POSIX locale, white space consists of one or more <blank> ( <space> and <tab> characters), <newline>, <carriage-return>, <form-feed>, and <vertical-tab> characters.

3.443 Wide-Character Code (C Language)
An integer value corresponding to a single graphic symbol or control code.

Note:
C Language Wide-Character Codes are defined in detail in C Language Wide-Character Codes.
3.444 Wide-Character Input/Output Functions
The functions that perform wide-oriented input from streams or wide-oriented output to streams: fgetwc(), fgetws(), fputwc(), fputws(), fwprintf(), fwscanf(), getwc(), getwchar(), putwc(), putwchar(), ungetwc(), vfwprintf(), vfwscanf(), vwprintf(), vwscanf(), wprintf(), and wscanf().

Note:
These functions are defined in detail in the System Interfaces volume of POSIX.1-2008.
3.445 Wide-Character String
A contiguous sequence of wide-character codes terminated by and including the first null wide-character code.

3.446 Word
In the shell command language, a token other than an operator. In some cases a word is also a portion of a word token: in the various forms of parameter expansion, such as ${name-word}, and variable assignment, such as name=word, the word is the portion of the token depicted by word. The concept of a word is no longer applicable following word expansions-only fields remain.

Note:
For further information, see XCU Parameter Expansion and wordexp.
3.447 Working Directory (or Current Working Directory)
A directory, associated with a process, that is used in pathname resolution for pathnames that do not begin with a <slash> character.

3.448 Worldwide Portability Interface
Functions for handling characters in a codeset-independent manner.

3.449 Write
To output characters to a file, such as standard output or standard error. Unless otherwise stated, standard output is the default output destination for all uses of the term "write''; see the distinction between display and write in Display.

3.450 XSI
The X/Open System Interfaces (XSI) option is the core application programming interface for C and sh programming for systems conforming to the Single UNIX Specification. This is a superset of the mandatory requirements for conformance to POSIX.1-2008.

3.451 XSI-Conformant
A system which allows an application to be built using a set of services that are consistent across all systems that conform to POSIX.1-2008 and that support the XSI option.

Note:
See also Conformance.
3.452 Zombie Process
The remains of a live process (see Live Process) after it terminates (see Process Termination) and before its status information (see XSH Status Information) is consumed by its parent process.

3.453 0
The algebraic sign provides additional information about any variable that has the value zero when the representation allows the sign to be determined.

 

return to top of page
UNIX  is a registered Trademark of The Open Group.
POSIX  is a registered Trademark of The IEEE.
Copyright  2001-2016 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT ]
<<< Previous	Home	Next >>>


<<< Previous	Home	Next >>>
The Open Group Base Specifications Issue 7
IEEE Std 1003.1-2008, 2016 Edition
Copyright  2001-2016 The IEEE and The Open Group
2. Shell Command Language
This chapter contains the definition of the Shell Command Language.

2.1 Shell Introduction
The shell is a command language interpreter. This chapter describes the syntax of that command language as it is used by the sh utility and the system() and popen() functions defined in the System Interfaces volume of POSIX.1-2008.

The shell operates according to the following general overview of operations. The specific details are included in the cited sections of this chapter.

The shell reads its input from a file (see sh), from the -c option or from the system() and popen() functions defined in the System Interfaces volume of POSIX.1-2008. If the first line of a file of shell commands starts with the characters "#!", the results are unspecified.

The shell breaks the input into tokens: words and operators; see Token Recognition.

The shell parses the input into simple commands (see Simple Commands) and compound commands (see Compound Commands).

The shell performs various expansions (separately) on different parts of each command, resulting in a list of pathnames and fields to be treated as a command and arguments; see wordexp.

The shell performs redirection (see Redirection) and removes redirection operators and their operands from the parameter list.

The shell executes a function (see Function Definition Command), built-in (see Special Built-In Utilities), executable file, or script, giving the names of the arguments as positional parameters numbered 1 to n, and the name of the command (or in the case of a function within a script, the name of the script) as the positional parameter numbered 0 (see Command Search and Execution).

The shell optionally waits for the command to complete and collects the exit status (see Exit Status for Commands).

2.2 Quoting
Quoting is used to remove the special meaning of certain characters or words to the shell. Quoting can be used to preserve the literal meaning of the special characters in the next paragraph, prevent reserved words from being recognized as such, and prevent parameter expansion and command substitution within here-document processing (see Here-Document).

The application shall quote the following characters if they are to represent themselves:

|  &  ;  <  >  (  )  $  `  \  "  '  <space>  <tab>  <newline>

and the following may need to be quoted under certain circumstances. That is, these characters may be special depending on conditions described elsewhere in this volume of POSIX.1-2008:

*   ?   [   #      =   %

The various quoting mechanisms are the escape character, single-quotes, and double-quotes. The here-document represents another form of quoting; see Here-Document.

2.2.1 Escape Character (Backslash)
A <backslash> that is not quoted shall preserve the literal value of the following character, with the exception of a <newline>. If a <newline> follows the <backslash>, the shell shall interpret this as line continuation. The <backslash> and <newline> shall be removed before splitting the input into tokens. Since the escaped <newline> is removed entirely from the input and is not replaced by any white space, it cannot serve as a token separator.

2.2.2 Single-Quotes
Enclosing characters in single-quotes ( '' ) shall preserve the literal value of each character within the single-quotes. A single-quote cannot occur within single-quotes.

2.2.3 Double-Quotes
Enclosing characters in double-quotes ( "" ) shall preserve the literal value of all characters within the double-quotes, with the exception of the characters backquote, <dollar-sign>, and <backslash>, as follows:

$
The <dollar-sign> shall retain its special meaning introducing parameter expansion (see Parameter Expansion), a form of command substitution (see Command Substitution), and arithmetic expansion (see Arithmetic Expansion).
The input characters within the quoted string that are also enclosed between "$(" and the matching ')' shall not be affected by the double-quotes, but rather shall define that command whose output replaces the "$(...)" when the word is expanded. The tokenizing rules in Token Recognition, not including the alias substitutions in Alias Substitution, shall be applied recursively to find the matching ')'.

Within the string of characters from an enclosed "${" to the matching '}', an even number of unescaped double-quotes or single-quotes, if any, shall occur. A preceding <backslash> character shall be used to escape a literal '{' or '}'. The rule in Parameter Expansion shall be used to determine the matching '}'.

`
The backquote shall retain its special meaning introducing the other form of command substitution (see Command Substitution). The portion of the quoted string from the initial backquote and the characters up to the next backquote that is not preceded by a <backslash>, having escape characters removed, defines that command whose output replaces "`...`" when the word is expanded. Either of the following cases produces undefined results:
A single-quoted or double-quoted string that begins, but does not end, within the "`...`" sequence

A "`...`" sequence that begins, but does not end, within the same double-quoted string

\
The <backslash> shall retain its special meaning as an escape character (see Escape Character (Backslash)) only when followed by one of the following characters when considered special:
$   `   "   \   <newline>

The application shall ensure that a double-quote is preceded by a <backslash> to be included within double-quotes. The parameter '@' has special meaning inside double-quotes and is described in Special Parameters .

2.3 Token Recognition
The shell shall read its input in terms of lines. (For details about how the shell reads its input, see the description of sh.) The input lines can be of unlimited length. These lines shall be parsed using two major modes: ordinary token recognition and processing of here-documents.

When an io_here token has been recognized by the grammar (see Shell Grammar), one or more of the subsequent lines immediately following the next NEWLINE token form the body of one or more here-documents and shall be parsed according to the rules of Here-Document.

When it is not processing an io_here, the shell shall break its input into tokens by applying the first applicable rule below to the next character in its input. The token shall be from the current position in the input until a token is delimited according to one of the rules below; the characters forming the token are exactly those in the input, including any quoting characters. If it is indicated that a token is delimited, and no characters have been included in a token, processing shall continue until an actual token is delimited.

If the end of input is recognized, the current token (if any) shall be delimited.

If the previous character was used as part of an operator and the current character is not quoted and can be used with the previous characters to form an operator, it shall be used as part of that (operator) token.

If the previous character was used as part of an operator and the current character cannot be used with the previous characters to form an operator, the operator containing the previous character shall be delimited.

If the current character is <backslash>, single-quote, or double-quote and it is not quoted, it shall affect quoting for subsequent characters up to the end of the quoted text. The rules for quoting are as described in Quoting . During token recognition no substitutions shall be actually performed, and the result token shall contain exactly the characters that appear in the input (except for <newline> joining), unmodified, including any embedded or enclosing quotes or substitution operators, between the <quotation-mark> and the end of the quoted text. The token shall not be delimited by the end of the quoted field.

If the current character is an unquoted '$' or '`', the shell shall identify the start of any candidates for parameter expansion (Parameter Expansion), command substitution (Command Substitution), or arithmetic expansion (Arithmetic Expansion) from their introductory unquoted character sequences: '$' or "${", "$(" or '`', and "$((", respectively. The shell shall read sufficient input to determine the end of the unit to be expanded (as explained in the cited sections). While processing the characters, if instances of expansions or quoting are found nested within the substitution, the shell shall recursively process them in the manner specified for the construct that is found. The characters found from the beginning of the substitution to its end, allowing for any recursion necessary to recognize embedded constructs, shall be included unmodified in the result token, including any embedded or enclosing substitution operators or quotes. The token shall not be delimited by the end of the substitution.

If the current character is not quoted and can be used as the first character of a new operator, the current token (if any) shall be delimited. The current character shall be used as the beginning of the next (operator) token.

If the current character is an unquoted <blank>, any token containing the previous character is delimited and the current character shall be discarded.

If the previous character was part of a word, the current character shall be appended to that word.

If the current character is a '#', it and all subsequent characters up to, but excluding, the next <newline> shall be discarded as a comment. The <newline> that ends the line is not considered part of the comment.

The current character is used as the start of a new word.

Once a token is delimited, it is categorized as required by the grammar in Shell Grammar.

2.3.1 Alias Substitution
After a token has been delimited, but before applying the grammatical rules in Shell Grammar, a resulting word that is identified to be the command name word of a simple command shall be examined to determine whether it is an unquoted, valid alias name. However, reserved words in correct grammatical context shall not be candidates for alias substitution. A valid alias name (see XBD Alias Name) shall be one that has been defined by the alias utility and not subsequently undefined using unalias. Implementations also may provide predefined valid aliases that are in effect when the shell is invoked. To prevent infinite loops in recursive aliasing, if the shell is not currently processing an alias of the same name, the word shall be replaced by the value of the alias; otherwise, it shall not be replaced.

If the value of the alias replacing the word ends in a <blank>, the shell shall check the next command word for alias substitution; this process shall continue until a word is found that is not a valid alias or an alias value does not end in a <blank>.

When used as specified by this volume of POSIX.1-2008, alias definitions shall not be inherited by separate invocations of the shell or by the utility execution environments invoked by the shell; see Shell Execution Environment.

2.4 Reserved Words
Reserved words are words that have special meaning to the shell; see Shell Commands. The following words shall be recognized as reserved words:


!
{
}
case


do
done
elif
else


esac
fi
for
if


in
then
until
while

This recognition shall only occur when none of the characters is quoted and when the word is used as:

The first word of a command

The first word following one of the reserved words other than case, for, or in

The third word in a case command (only in is valid in this case)

The third word in a for command (only in and do are valid in this case)

See the grammar in Shell Grammar.

The following words may be recognized as reserved words on some implementations (when none of the characters are quoted), causing unspecified results:

[[

]]

function

select

Words that are the concatenation of a name and a <colon> ( ':' ) are reserved; their use produces unspecified results.

2.5 Parameters and Variables
A parameter can be denoted by a name, a number, or one of the special characters listed in Special Parameters. A variable is a parameter denoted by a name.

A parameter is set if it has an assigned value (null is a valid value). Once a variable is set, it can only be unset by using the unset special built-in command.

2.5.1 Positional Parameters
A positional parameter is a parameter denoted by the decimal value represented by one or more digits, other than the single digit 0. The digits denoting the positional parameters shall always be interpreted as a decimal value, even if there is a leading zero. When a positional parameter with more than one digit is specified, the application shall enclose the digits in braces (see Parameter Expansion). Positional parameters are initially assigned when the shell is invoked (see sh), temporarily replaced when a shell function is invoked (see Function Definition Command), and can be reassigned with the set special built-in command.

2.5.2 Special Parameters
Listed below are the special parameters and the values to which they shall expand. Only the values of the special parameters are listed; see wordexp for a detailed summary of all the stages involved in expanding words.

@
Expands to the positional parameters, starting from one, initially producing one field for each positional parameter that is set. When the expansion occurs in a context where field splitting will be performed, any empty fields may be discarded and each of the non-empty fields shall be further split as described in Field Splitting. When the expansion occurs within double-quotes, the behavior is unspecified unless one of the following is true:
Field splitting as described in Field Splitting would be performed if the expansion were not within double-quotes (regardless of whether field splitting would have any effect; for example, if IFS is null).

The double-quotes are within the word of a ${parameter:-word} or a ${parameter:+word} expansion (with or without the <colon>; see Parameter Expansion) which would have been subject to field splitting if parameter had been expanded instead of word.

If one of these conditions is true, the initial fields shall be retained as separate fields, except that if the parameter being expanded was embedded within a word, the first field shall be joined with the beginning part of the original word and the last field shall be joined with the end part of the original word. In all other contexts the results of the expansion are unspecified. If there are no positional parameters, the expansion of '@' shall generate zero fields, even when '@' is within double-quotes; however, if the expansion is embedded within a word which contains one or more other parts that expand to a quoted null string, these null string(s) shall still produce an empty field, except that if the other parts are all within the same double-quotes as the '@', it is unspecified whether the result is zero fields or one empty field.

*
Expands to the positional parameters, starting from one, initially producing one field for each positional parameter that is set. When the expansion occurs in a context where field splitting will be performed, any empty fields may be discarded and each of the non-empty fields shall be further split as described in Field Splitting. When the expansion occurs in a context where field splitting will not be performed, the initial fields shall be joined to form a single field with the value of each parameter separated by the first character of the IFS variable if IFS contains at least one character, or separated by a <space> if IFS is unset, or with no separation if IFS is set to a null string.
#
Expands to the decimal number of positional parameters. The command name (parameter 0) shall not be counted in the number given by '#' because it is a special parameter, not a positional parameter.
?
Expands to the decimal exit status of the most recent pipeline (see Pipelines).
-
(Hyphen.) Expands to the current option flags (the single-letter option names concatenated into a string) as specified on invocation, by the set special built-in command, or implicitly by the shell.
$
Expands to the decimal process ID of the invoked shell. In a subshell (see Shell Execution Environment ), '$' shall expand to the same value as that of the current shell.
!
Expands to the decimal process ID of the most recent background command (see Lists) executed from the current shell. (For example, background commands executed from subshells do not affect the value of "$!" in the current shell environment.) For a pipeline, the process ID is that of the last command in the pipeline.
0
(Zero.) Expands to the name of the shell or shell script. See sh for a detailed description of how this name is derived.
See the description of the IFS variable in Shell Variables.

2.5.3 Shell Variables
Variables shall be initialized from the environment (as defined by XBD Environment Variables and the exec function in the System Interfaces volume of POSIX.1-2008) and can be given new values with variable assignment commands. If a variable is initialized from the environment, it shall be marked for export immediately; see the export special built-in. New variables can be defined and initialized with variable assignments, with the read or getopts utilities, with the name parameter in a for loop, with the ${ name= word} expansion, or with other mechanisms provided as implementation extensions.
The following variables shall affect the execution of the shell:

ENV
[UP] [Option Start] The processing of the ENV shell variable shall be supported if the system supports the User Portability Utilities option. [Option End]
This variable, when and only when an interactive shell is invoked, shall be subjected to parameter expansion (see Parameter Expansion) by the shell and the resulting value shall be used as a pathname of a file containing shell commands to execute in the current environment. The file need not be executable. If the expanded value of ENV is not an absolute pathname, the results are unspecified. ENV shall be ignored if the user's real and effective user IDs or real and effective group IDs are different.

HOME
The pathname of the user's home directory. The contents of HOME are used in tilde expansion (see Tilde Expansion).
IFS
A string treated as a list of characters that is used for field splitting, expansion of the '*' special parameter, and to split lines into fields with the read utility. If the value of IFS includes any bytes that do not form part of a valid character, the results of field splitting, expansion of '*', and use of the read utility are unspecified.
If IFS is not set, it shall behave as normal for an unset variable, except that field splitting by the shell and line splitting by the read utility shall be performed as if the value of IFS is <space> <tab> <newline>; see Field Splitting.

The shell shall set IFS to <space> <tab> <newline> when it is invoked.

LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD Internationalization Variables for the precedence of internationalization variables used to determine the values of locale categories.)
LC_ALL
The value of this variable overrides the LC_* variables and LANG, as described in XBD Environment Variables.
LC_COLLATE
Determine the behavior of range expressions, equivalence classes, and multi-character collating elements within pattern matching.
LC_CTYPE
Determine the interpretation of sequences of bytes of text data as characters (for example, single-byte as opposed to multi-byte characters), which characters are defined as letters (character class alpha) and <blank> characters (character class blank), and the behavior of character classes within pattern matching. Changing the value of LC_CTYPE after the shell has started shall not affect the lexical processing of shell commands in the current shell execution environment or its subshells. Invoking a shell script or performing exec sh subjects the new shell to the changes in LC_CTYPE.
LC_MESSAGES
Determine the language in which messages should be written.
LINENO
Set by the shell to a decimal number representing the current sequential line number (numbered starting with 1) within a script or function before it executes each command. If the user unsets or resets LINENO, the variable may lose its special meaning for the life of the shell. If the shell is not currently executing a script or function, the value of LINENO is unspecified. This volume of POSIX.1-2008 specifies the effects of the variable only for systems supporting the User Portability Utilities option.
NLSPATH
[XSI] [Option Start] Determine the location of message catalogs for the processing of LC_MESSAGES. [Option End]
PATH
A string formatted as described in XBD Environment Variables, used to effect command interpretation; see Command Search and Execution.
PPID
Set by the shell to the decimal value of its parent process ID during initialization of the shell. In a subshell (see Shell Execution Environment), PPID shall be set to the same value as that of the parent of the current shell. For example, echo $ PPID and (echo $ PPID) would produce the same value.
PS1
Each time an interactive shell is ready to read a command, the value of this variable shall be subjected to parameter expansion and written to standard error. The default value shall be "$ ". For users who have specific additional implementation-defined privileges, the default may be another, implementation-defined value. The shell shall replace each instance of the character '!' in PS1 with the history file number of the next command to be typed. Escaping the '!' with another '!' (that is, "!!" ) shall place the literal character '!' in the prompt. This volume of POSIX.1-2008 specifies the effects of the variable only for systems supporting the User Portability Utilities option.
PS2
Each time the user enters a <newline> prior to completing a command line in an interactive shell, the value of this variable shall be subjected to parameter expansion and written to standard error. The default value is "> ". This volume of POSIX.1-2008 specifies the effects of the variable only for systems supporting the User Portability Utilities option.
PS4
When an execution trace (set -x) is being performed in an interactive shell, before each line in the execution trace, the value of this variable shall be subjected to parameter expansion and written to standard error. The default value is "+ ". This volume of POSIX.1-2008 specifies the effects of the variable only for systems supporting the User Portability Utilities option.
PWD
Set by the shell and by the cd utility. In the shell the value shall be initialized from the environment as follows. If a value for PWD is passed to the shell in the environment when it is executed, the value is an absolute pathname of the current working directory that is no longer than {PATH_MAX} bytes including the terminating null byte, and the value does not contain any components that are dot or dot-dot, then the shell shall set PWD to the value from the environment. Otherwise, if a value for PWD is passed to the shell in the environment when it is executed, the value is an absolute pathname of the current working directory, and the value does not contain any components that are dot or dot-dot, then it is unspecified whether the shell sets PWD to the value from the environment or sets PWD to the pathname that would be output by pwd -P. Otherwise, the sh utility sets PWD to the pathname that would be output by pwd -P. In cases where PWD is set to the value from the environment, the value can contain components that refer to files of type symbolic link. In cases where PWD is set to the pathname that would be output by pwd -P, if there is insufficient permission on the current working directory, or on any parent of that directory, to determine what that pathname would be, the value of PWD is unspecified. Assignments to this variable may be ignored. If an application sets or unsets the value of PWD, the behaviors of the cd and pwd utilities are unspecified.
2.6 Word Expansions
This section describes the various expansions that are performed on words. Not all expansions are performed on every word, as explained in the following sections.

Tilde expansions, parameter expansions, command substitutions, arithmetic expansions, and quote removals that occur within a single word expand to a single field. It is only field splitting or pathname expansion that can create multiple fields from a single word. The single exception to this rule is the expansion of the special parameter '@' within double-quotes, as described in Special Parameters.

The order of word expansion shall be as follows:

Tilde expansion (see Tilde Expansion), parameter expansion (see Parameter Expansion), command substitution (see Command Substitution), and arithmetic expansion (see Arithmetic Expansion) shall be performed, beginning to end. See item 5 in Token Recognition.

Field splitting (see Field Splitting) shall be performed on the portions of the fields generated by step 1, unless IFS is null.

Pathname expansion (see Pathname Expansion) shall be performed, unless set -f is in effect.

Quote removal (see Quote Removal) shall always be performed last.

The expansions described in this section shall occur in the same shell environment as that in which the command is executed.

If the complete expansion appropriate for a word results in an empty field, that empty field shall be deleted from the list of fields that form the completely expanded command, unless the original word contained single-quote or double-quote characters.

The '$' character is used to introduce parameter expansion, command substitution, or arithmetic evaluation. If an unquoted '$' is followed by a character that is not one of the following:

A numeric character

The name of one of the special parameters (see Special Parameters)

A valid first character of a variable name

A <left-curly-bracket> ( '{' )

A <left-parenthesis>

the result is unspecified.

2.6.1 Tilde Expansion
A "tilde-prefix" consists of an unquoted <tilde> character at the beginning of a word, followed by all of the characters preceding the first unquoted <slash> in the word, or all the characters in the word if there is no <slash>. In an assignment (see XBD Variable Assignment), multiple tilde-prefixes can be used: at the beginning of the word (that is, following the <equals-sign> of the assignment), following any unquoted <colon>, or both. A tilde-prefix in an assignment is terminated by the first unquoted <colon> or <slash>. If none of the characters in the tilde-prefix are quoted, the characters in the tilde-prefix following the <tilde> are treated as a possible login name from the user database. A portable login name cannot contain characters outside the set given in the description of the LOGNAME environment variable in XBD Other Environment Variables. If the login name is null (that is, the tilde-prefix contains only the tilde), the tilde-prefix is replaced by the value of the variable HOME. If HOME is unset, the results are unspecified. Otherwise, the tilde-prefix shall be replaced by a pathname of the initial working directory associated with the login name obtained using the getpwnam() function as defined in the System Interfaces volume of POSIX.1-2008. If the system does not recognize the login name, the results are undefined.

The pathname resulting from tilde expansion shall be treated as if quoted to prevent it being altered by field splitting and pathname expansion.

2.6.2 Parameter Expansion
The format for parameter expansion is as follows:

${expression}

where expression consists of all characters until the matching '}'. Any '}' escaped by a <backslash> or within a quoted string, and characters in embedded arithmetic expansions, command substitutions, and variable expansions, shall not be examined in determining the matching '}'.

The simplest form for parameter expansion is:

${parameter}

The value, if any, of parameter shall be substituted.

The parameter name or symbol can be enclosed in braces, which are optional except for positional parameters with more than one digit or when parameter is a name and is followed by a character that could be interpreted as part of the name. The matching closing brace shall be determined by counting brace levels, skipping over enclosed quoted strings, and command substitutions.

If the parameter is not enclosed in braces, and is a name, the expansion shall use the longest valid name (see XBD Name), whether or not the variable represented by that name exists. Otherwise, the parameter is a single-character symbol, and behavior is unspecified if that character is neither a digit nor one of the special parameters (see Special Parameters).

If a parameter expansion occurs inside double-quotes:

Pathname expansion shall not be performed on the results of the expansion.

Field splitting shall not be performed on the results of the expansion.

In addition, a parameter expansion can be modified by using one of the following formats. In each case that a value of word is needed (based on the state of parameter, as described below), word shall be subjected to tilde expansion, parameter expansion, command substitution, and arithmetic expansion. If word is not needed, it shall not be expanded. The '}' character that delimits the following parameter expansion modifications shall be determined as described previously in this section and in Double-Quotes.

${parameter:-[word]}
Use Default Values. If parameter is unset or null, the expansion of word (or an empty string if word is omitted) shall be substituted; otherwise, the value of parameter shall be substituted.
${parameter:=[word]}
Assign Default Values. If parameter is unset or null, the expansion of word (or an empty string if word is omitted) shall be assigned to parameter. In all cases, the final value of parameter shall be substituted. Only variables, not positional parameters or special parameters, can be assigned in this way.
${parameter:?[word]}
Indicate Error if Null or Unset. If parameter is unset or null, the expansion of word (or a message indicating it is unset if word is omitted) shall be written to standard error and the shell exits with a non-zero exit status. Otherwise, the value of parameter shall be substituted. An interactive shell need not exit.
${parameter:+[word]}
Use Alternative Value. If parameter is unset or null, null shall be substituted; otherwise, the expansion of word (or an empty string if word is omitted) shall be substituted.
In the parameter expansions shown previously, use of the <colon> in the format shall result in a test for a parameter that is unset or null; omission of the <colon> shall result in a test for a parameter that is only unset. If parameter is '#' and the colon is omitted, the application shall ensure that word is specified (this is necessary to avoid ambiguity with the string length expansion). The following table summarizes the effect of the <colon>:

 

parameter
Set and Not Null

parameter
Set But Null

parameter
Unset

${parameter:-word}

substitute parameter

substitute word

substitute word

${parameter-word}

substitute parameter

substitute null

substitute word

${parameter:=word}

substitute parameter

assign word

assign word

${parameter=word}

substitute parameter

substitute null

assign word

${parameter:?word}

substitute parameter

error, exit

error, exit

${parameter?word}

substitute parameter

substitute null

error, exit

${parameter:+word}

substitute word

substitute null

substitute null

${parameter+word}

substitute word

substitute word

substitute null

In all cases shown with "substitute", the expression is replaced with the value shown. In all cases shown with "assign", parameter is assigned that value, which also replaces the expression.

${#parameter}
String Length. The length in characters of the value of parameter shall be substituted. If parameter is '*' or '@', the result of the expansion is unspecified. If parameter is unset and set -u is in effect, the expansion shall fail.
The following four varieties of parameter expansion provide for substring processing. In each case, pattern matching notation (see Pattern Matching Notation), rather than regular expression notation, shall be used to evaluate the patterns. If parameter is '#', '*', or '@', the result of the expansion is unspecified. If parameter is unset and set -u is in effect, the expansion shall fail. Enclosing the full parameter expansion string in double-quotes shall not cause the following four varieties of pattern characters to be quoted, whereas quoting characters within the braces shall have this effect. In each variety, if word is omitted, the empty pattern shall be used.

${parameter%[word]}
Remove Smallest Suffix Pattern. The word shall be expanded to produce a pattern. The parameter expansion shall then result in parameter, with the smallest portion of the suffix matched by the pattern deleted. If present, word shall not begin with an unquoted '%'.
${parameter%%[word]}
Remove Largest Suffix Pattern. The word shall be expanded to produce a pattern. The parameter expansion shall then result in parameter, with the largest portion of the suffix matched by the pattern deleted.
${parameter#[word]}
Remove Smallest Prefix Pattern. The word shall be expanded to produce a pattern. The parameter expansion shall then result in parameter, with the smallest portion of the prefix matched by the pattern deleted. If present, word shall not begin with an unquoted '#'.
${parameter##[word]}
Remove Largest Prefix Pattern. The word shall be expanded to produce a pattern. The parameter expansion shall then result in parameter, with the largest portion of the prefix matched by the pattern deleted.
The following sections are informative.
Examples
${parameter}
In this example, the effects of omitting braces are demonstrated.
a=1
set 2
echo ${a}b-$ab-${1}0-${10}-$10
1b--20--20
${parameter-word}
This example demonstrates the difference between unset and set to the empty string, as well as the rules for finding the delimiting close brace.
foo=asdf
echo ${foo-bar}xyz}
asdfxyz}foo=
echo ${foo-bar}xyz}
xyz}unset foo
echo ${foo-bar}xyz}
barxyz}
${parameter:-word}
In this example, ls is executed only if x is null or unset. (The $(ls) command substitution notation is explained in Command Substitution.)
${x:-$(ls)}

${parameter:=word}
unset X
echo ${X:=abc}
abc
${parameter:?word}
unset posix
echo ${posix:?}
sh: posix: parameter null or not set
${parameter:+word}
set a b c
echo ${3:+posix}
posix
${#parameter}
HOME=/usr/posix
echo ${#HOME}
10
${parameter%word}
x=file.c
echo ${x%.c}.o
file.o
${parameter%%word}
x=posix/src/std
echo ${x%%/*}
posix
${parameter#word}
x=$HOME/src/cmd
echo ${x#$HOME}
/src/cmd
${parameter##word}
x=/one/two/three
echo ${x##*/}
three
The double-quoting of patterns is different depending on where the double-quotes are placed:

"${x#*}"
The <asterisk> is a pattern character.
${x#"*"}
The literal <asterisk> is quoted and not special.
End of informative text.
2.6.3 Command Substitution
Command substitution allows the output of a command to be substituted in place of the command name itself. Command substitution shall occur when the command is enclosed as follows:

$(command)

or (backquoted version):

`command`

The shell shall expand the command substitution by executing command in a subshell environment (see Shell Execution Environment) and replacing the command substitution (the text of command plus the enclosing "$()" or backquotes) with the standard output of the command, removing sequences of one or more <newline> characters at the end of the substitution. Embedded <newline> characters before the end of the output shall not be removed; however, they may be treated as field delimiters and eliminated during field splitting, depending on the value of IFS and quoting that is in effect. If the output contains any null bytes, the behavior is unspecified.

Within the backquoted style of command substitution, <backslash> shall retain its literal meaning, except when followed by: '$', '`', or <backslash>. The search for the matching backquote shall be satisfied by the first unquoted non-escaped backquote; during this search, if a non-escaped backquote is encountered within a shell comment, a here-document, an embedded command substitution of the $(command) form, or a quoted string, undefined results occur. A single-quoted or double-quoted string that begins, but does not end, within the "`...`" sequence produces undefined results.

With the $(command) form, all characters following the open parenthesis to the matching closing parenthesis constitute the command. Any valid shell script can be used for command, except a script consisting solely of redirections which produces unspecified results.

The results of command substitution shall not be processed for further tilde expansion, parameter expansion, command substitution, or arithmetic expansion. If a command substitution occurs inside double-quotes, field splitting and pathname expansion shall not be performed on the results of the substitution.

Command substitution can be nested. To specify nesting within the backquoted version, the application shall precede the inner backquotes with <backslash> characters; for example:

\`command\`

The syntax of the shell command language has an ambiguity for expansions beginning with "$((", which can introduce an arithmetic expansion or a command substitution that starts with a subshell. Arithmetic expansion has precedence; that is, the shell shall first determine whether it can parse the expansion as an arithmetic expansion and shall only parse the expansion as a command substitution if it determines that it cannot parse the expansion as an arithmetic expansion. The shell need not evaluate nested expansions when performing this determination. If it encounters the end of input without already having determined that it cannot parse the expansion as an arithmetic expansion, the shell shall treat the expansion as an incomplete arithmetic expansion and report a syntax error. A conforming application shall ensure that it separates the "$(" and '(' into two tokens (that is, separate them with white space) in a command substitution that starts with a subshell. For example, a command substitution containing a single subshell could be written as:

$( (command) )

2.6.4 Arithmetic Expansion
Arithmetic expansion provides a mechanism for evaluating an arithmetic expression and substituting its value. The format for arithmetic expansion shall be as follows:

$((expression))

The expression shall be treated as if it were in double-quotes, except that a double-quote inside the expression is not treated specially. The shell shall expand all tokens in the expression for parameter expansion, command substitution, and quote removal.

Next, the shell shall treat this as an arithmetic expression and substitute the value of the expression. The arithmetic expression shall be processed according to the rules given in Arithmetic Precision and Operations, with the following exceptions:

Only signed long integer arithmetic is required.

Only the decimal-constant, octal-constant, and hexadecimal-constant constants specified in the ISO C standard, Section 6.4.4.1 are required to be recognized as constants.

The sizeof() operator and the prefix and postfix "++" and "--" operators are not required.

Selection, iteration, and jump statements are not supported.

All changes to variables in an arithmetic expression shall be in effect after the arithmetic expansion, as in the parameter expansion "${x=value}".

If the shell variable x contains a value that forms a valid integer constant, optionally including a leading <plus-sign> or <hyphen-minus>, then the arithmetic expansions "$((x))" and "$(($x))" shall return the same value.

As an extension, the shell may recognize arithmetic expressions beyond those listed. The shell may use a signed integer type with a rank larger than the rank of signed long. The shell may use a real-floating type instead of signed long as long as it does not affect the results in cases where there is no overflow. If the expression is invalid, or the contents of a shell variable used in the expression are not recognized by the shell, the expansion fails and the shell shall write a diagnostic message to standard error indicating the failure.

The following sections are informative.
Examples
A simple example using arithmetic expansion:

# repeat a command 100 times
x=100
while [ $x -gt 0 ]
do
    command    x=$(($x-1))
done

End of informative text.
2.6.5 Field Splitting
After parameter expansion (Parameter Expansion), command substitution (Command Substitution), and arithmetic expansion (Arithmetic Expansion), the shell shall scan the results of expansions and substitutions that did not occur in double-quotes for field splitting and multiple fields can result.

The shell shall treat each character of the IFS as a delimiter and use the delimiters as field terminators to split the results of parameter expansion, command substitution, and arithmetic expansion into fields.

If the value of IFS is a <space>, <tab>, and <newline>, or if it is unset, any sequence of <space>, <tab>, or <newline> characters at the beginning or end of the input shall be ignored and any sequence of those characters within the input shall delimit a field. For example, the input:

<newline><space><tab>foo<tab><tab>bar<space>

yields two fields, foo and bar.

If the value of IFS is null, no field splitting shall be performed.

Otherwise, the following rules shall be applied in sequence. The term " IFS white space" is used to mean any sequence (zero or more instances) of white-space characters that are in the IFS value (for example, if IFS contains <space>/ <comma>/ <tab>, any sequence of <space> and <tab> characters is considered IFS white space).

IFS white space shall be ignored at the beginning and end of the input.

Each occurrence in the input of an IFS character that is not IFS white space, along with any adjacent IFS white space, shall delimit a field, as described previously.

Non-zero-length IFS white space shall delimit a field.

2.6.6 Pathname Expansion
After field splitting, if set -f is not in effect, each field in the resulting command line shall be expanded using the algorithm described in Pattern Matching Notation, qualified by the rules in Patterns Used for Filename Expansion.

2.6.7 Quote Removal
The quote characters ( <backslash>, single-quote, and double-quote) that were present in the original word shall be removed unless they have themselves been quoted.

2.7 Redirection
Redirection is used to open and close files for the current shell execution environment (see Shell Execution Environment) or for any command. Redirection operators can be used with numbers representing file descriptors (see XBD File Descriptor) as described below.

The overall format used for redirection is:

[n]redir-op word
The number n is an optional decimal number designating the file descriptor number; the application shall ensure it is delimited from any preceding text and immediately precede the redirection operator redir-op. If n is quoted, the number shall not be recognized as part of the redirection expression. For example:

echo \2>a

writes the character 2 into file a. If any part of redir-op is quoted, no redirection expression is recognized. For example:

echo 2\>a

writes the characters 2>a to standard output. The optional number, redirection operator, and word shall not appear in the arguments provided to the command to be executed (if any).

Open files are represented by decimal numbers starting with zero. The largest possible value is implementation-defined; however, all implementations shall support at least 0 to 9, inclusive, for use by the application. These numbers are called "file descriptors". The values 0, 1, and 2 have special meaning and conventional uses and are implied by certain redirection operations; they are referred to as standard input, standard output, and standard error, respectively. Programs usually take their input from standard input, and write output on standard output. Error messages are usually written on standard error. The redirection operators can be preceded by one or more digits (with no intervening <blank> characters allowed) to designate the file descriptor number.

If the redirection operator is "<<" or "<<-", the word that follows the redirection operator shall be subjected to quote removal; it is unspecified whether any of the other expansions occur. For the other redirection operators, the word that follows the redirection operator shall be subjected to tilde expansion, parameter expansion, command substitution, arithmetic expansion, and quote removal. Pathname expansion shall not be performed on the word by a non-interactive shell; an interactive shell may perform it, but shall do so only when the expansion would result in one word.

If more than one redirection operator is specified with a command, the order of evaluation is from beginning to end.

A failure to open or create a file shall cause a redirection to fail.

2.7.1 Redirecting Input
Input redirection shall cause the file whose name results from the expansion of word to be opened for reading on the designated file descriptor, or standard input if the file descriptor is not specified.

The general format for redirecting input is:

[n]<word
where the optional n represents the file descriptor number. If the number is omitted, the redirection shall refer to standard input (file descriptor 0).

2.7.2 Redirecting Output
The two general formats for redirecting output are:

[n]>word
[n]>|word
where the optional n represents the file descriptor number. If the number is omitted, the redirection shall refer to standard output (file descriptor 1).

Output redirection using the '>' format shall fail if the noclobber option is set (see the description of set -C) and the file named by the expansion of word exists and is a regular file. Otherwise, redirection using the '>' or ">|" formats shall cause the file whose name results from the expansion of word to be created and opened for output on the designated file descriptor, or standard output if none is specified. If the file does not exist, it shall be created; otherwise, it shall be truncated to be an empty file after being opened.

2.7.3 Appending Redirected Output
Appended output redirection shall cause the file whose name results from the expansion of word to be opened for output on the designated file descriptor. The file is opened as if the open() function as defined in the System Interfaces volume of POSIX.1-2008 was called with the O_APPEND flag. If the file does not exist, it shall be created.

The general format for appending redirected output is as follows:

[n]>>word
where the optional n represents the file descriptor number. If the number is omitted, the redirection refers to standard output (file descriptor 1).

2.7.4 Here-Document
The redirection operators "<<" and "<<-" both allow redirection of subsequent lines read by the shell to the input of a command. The redirected lines are known as a "here-document".

The here-document shall be treated as a single word that begins after the next <newline> and continues until there is a line containing only the delimiter and a <newline>, with no <blank> characters in between. Then the next here-document starts, if there is one. The format is as follows:

[n]<<word
    here-document
delimiter
where the optional n represents the file descriptor number. If the number is omitted, the here-document refers to standard input (file descriptor 0). It is unspecified whether the file descriptor is opened as a regular file, a special file, or a pipe. Portable applications cannot rely on the file descriptor being seekable (see XSH lseek).

If any part of word is quoted, the delimiter shall be formed by performing quote removal on word, and the here-document lines shall not be expanded. Otherwise, the delimiter shall be the word itself.

If no part of word is quoted, all lines of the here-document shall be expanded for parameter expansion, command substitution, and arithmetic expansion. In this case, the <backslash> in the input behaves as the <backslash> inside double-quotes (see Double-Quotes). However, the double-quote character ( ' )' shall not be treated specially within a here-document, except when the double-quote appears within "$()", "``", or "${}".

If the redirection operator is "<<-", all leading <tab> characters shall be stripped from input lines and the line containing the trailing delimiter. If more than one "<<" or "<<-" operator is specified on a line, the here-document associated with the first operator shall be supplied first by the application and shall be read first by the shell.

When a here-document is read from a terminal device and the shell is interactive, it shall write the contents of the variable PS2, processed as described in Shell Variables, to standard error before reading each line of input until the delimiter has been recognized.

The following sections are informative.
Examples
An example of a here-document follows:

cat <<eof1; cat <<eof2
Hi,
eof1
Helene.
eof2

End of informative text.
2.7.5 Duplicating an Input File Descriptor
The redirection operator:

[n]<&word
shall duplicate one input file descriptor from another, or shall close one. If word evaluates to one or more digits, the file descriptor denoted by n, or standard input if n is not specified, shall be made to be a copy of the file descriptor denoted by word; if the digits in word do not represent a file descriptor already open for input, a redirection error shall result; see Consequences of Shell Errors. If word evaluates to '-', file descriptor n, or standard input if n is not specified, shall be closed. Attempts to close a file descriptor that is not open shall not constitute an error. If word evaluates to something else, the behavior is unspecified.

2.7.6 Duplicating an Output File Descriptor
The redirection operator:

[n]>&word
shall duplicate one output file descriptor from another, or shall close one. If word evaluates to one or more digits, the file descriptor denoted by n, or standard output if n is not specified, shall be made to be a copy of the file descriptor denoted by word; if the digits in word do not represent a file descriptor already open for output, a redirection error shall result; see Consequences of Shell Errors. If word evaluates to '-', file descriptor n, or standard output if n is not specified, is closed. Attempts to close a file descriptor that is not open shall not constitute an error. If word evaluates to something else, the behavior is unspecified.

2.7.7 Open File Descriptors for Reading and Writing
The redirection operator:

[n]<>word
shall cause the file whose name is the expansion of word to be opened for both reading and writing on the file descriptor denoted by n, or standard input if n is not specified. If the file does not exist, it shall be created.

2.8 Exit Status and Errors
2.8.1 Consequences of Shell Errors
Certain errors shall cause the shell to write a diagnostic message to standard error and exit as shown in the following table:

Error

Non-Interactive
Shell

Interactive Shell

Shell Diagnostic
Message Required

Shell language syntax error

shall exit

shall not exit

yes

Special built-in utility error

shall exit

shall not exit

no1

Other utility (not a special
built-in) error

shall not exit

shall not exit

no2

Redirection error with
special built-in utilities

shall exit

shall not exit

yes

Redirection error with
compound commands

may exit3

shall not exit

yes

Redirection error with
function execution

may exit3

shall not exit

yes

Redirection error with other
utilities (not special built-ins)

shall not exit

shall not exit

yes

Variable assignment error

shall exit

shall not exit

yes

Expansion error

shall exit

shall not exit

yes

Command not found

may exit

shall not exit

yes

Notes:
Although special built-ins are part of the shell, a diagnostic message written by a special built-in is not considered to be a shell diagnostic message, and can be redirected like any other utility.

The shell is not required to write a diagnostic message, but the utility itself shall write a diagnostic message if required to do so.

A future version of this standard may require the shell to not exit in this condition.

An expansion error is one that occurs when the shell expansions define in wordexp are carried out (for example, "${x!y}", because '!' is not a valid operator); an implementation may treat these as syntax errors if it is able to detect them during tokenization, rather than during expansion.

If any of the errors shown as "shall exit" or "may exit" occur in a subshell environment, the shell shall (respectively, may) exit from the subshell environment with a non-zero status and continue in the environment from which that subshell environment was invoked.

In all of the cases shown in the table where an interactive shell is required not to exit, the shell shall not perform any further processing of the command in which the error occurred.

2.8.2 Exit Status for Commands
Each command has an exit status that can influence the behavior of other shell commands. The exit status of commands that are not utilities is documented in this section. The exit status of the standard utilities is documented in their respective sections.

If a command is not found, the exit status shall be 127. If the command name is found, but it is not an executable utility, the exit status shall be 126. Applications that invoke utilities without using the shell should use these exit status values to report similar errors.

If a command fails during word expansion or redirection, its exit status shall be between 1 and 125 inclusive.

Internally, for purposes of deciding whether a command exits with a non-zero exit status, the shell shall recognize the entire status value retrieved for the command by the equivalent of the wait() function WEXITSTATUS macro (as defined in the System Interfaces volume of POSIX.1-2008). When reporting the exit status with the special parameter '?', the shell shall report the full eight bits of exit status available. The exit status of a command that terminated because it received a signal shall be reported as greater than 128.

2.9 Shell Commands
This section describes the basic structure of shell commands. The following command descriptions each describe a format of the command that is only used to aid the reader in recognizing the command type, and does not formally represent the syntax. In particular, the representations include spacing between tokens in some places where <blank>s would not be necessary (when one of the tokens is an operator). Each description discusses the semantics of the command; for a formal definition of the command language, consult Shell Grammar.

A command is one of the following:

Simple command (see Simple Commands)

Pipeline (see Pipelines)

List compound-list (see Lists)

Compound command (see Compound Commands)

Function definition (see Function Definition Command)

Unless otherwise stated, the exit status of a command shall be that of the last simple command executed by the command. There shall be no limit on the size of any shell command other than that imposed by the underlying system (memory constraints, {ARG_MAX}, and so on).

2.9.1 Simple Commands
A "simple command" is a sequence of optional variable assignments and redirections, in any sequence, optionally followed by words and redirections, terminated by a control operator.

When a given simple command is required to be executed (that is, when any conditional construct such as an AND-OR list or a case statement has not bypassed the simple command), the following expansions, assignments, and redirections shall all be performed from the beginning of the command text to the end:

The words that are recognized as variable assignments or redirections according to Shell Grammar Rules are saved for processing in steps 3 and 4.

The words that are not variable assignments or redirections shall be expanded. If any fields remain following their expansion, the first field shall be considered the command name and remaining fields are the arguments for the command.

Redirections shall be performed as described in Redirection.

Each variable assignment shall be expanded for tilde expansion, parameter expansion, command substitution, arithmetic expansion, and quote removal prior to assigning the value.

In the preceding list, the order of steps 3 and 4 may be reversed if no command name results from step 2 or if the command name matches the name of a special built-in utility; see Special Built-In Utilities.

Variable assignments shall be performed as follows:

If no command name results, variable assignments shall affect the current execution environment.

If the command name is not a special built-in utility or function, the variable assignments shall be exported for the execution environment of the command and shall not affect the current execution environment except as a side-effect of the expansions performed in step 4. In this case it is unspecified:

Whether or not the assignments are visible for subsequent expansions in step 4

Whether variable assignments made as side-effects of these expansions are visible for subsequent expansions in step 4, or in the current shell execution environment, or both

If the command name is a standard utility implemented as a function (see XBD Utility), the effect of variable assignments shall be as if the utility was not implemented as a function.

If the command name is a special built-in utility, variable assignments shall affect the current execution environment. Unless the set -a option is on (see set), it is unspecified:

Whether or not the variables gain the export attribute during the execution of the special built-in utility

Whether or not export attributes gained as a result of the variable assignments persist after the completion of the special built-in utility

If the command name is a function that is not a standard utility implemented as a function, variable assignments shall affect the current execution environment during the execution of the function. It is unspecified:

Whether or not the variable assignments persist after the completion of the function

Whether or not the variables gain the export attribute during the execution of the function

Whether or not export attributes gained as a result of the variable assignments persist after the completion of the function (if variable assignments persist after the completion of the function)

If any of the variable assignments attempt to assign a value to a variable for which the readonly attribute is set in the current shell environment (regardless of whether the assignment is made in that environment), a variable assignment error shall occur. See Consequences of Shell Errors for the consequences of these errors.

If there is no command name, any redirections shall be performed in a subshell environment; it is unspecified whether this subshell environment is the same one as that used for a command substitution within the command. (To affect the current execution environment, see the exec special built-in.) If any of the redirections performed in the current shell execution environment fail, the command shall immediately fail with an exit status greater than zero, and the shell shall write an error message indicating the failure. See Consequences of Shell Errors for the consequences of these failures on interactive and non-interactive shells.

If there is a command name, execution shall continue as described in Command Search and Execution . If there is no command name, but the command contained a command substitution, the command shall complete with the exit status of the last command substitution performed. Otherwise, the command shall complete with a zero exit status.

Command Search and Execution
If a simple command results in a command name and an optional list of arguments, the following actions shall be performed:

If the command name does not contain any <slash> characters, the first successful step in the following sequence shall occur:

If the command name matches the name of a special built-in utility, that special built-in utility shall be invoked.

If the command name matches the name of a utility listed in the following table, the results are unspecified.


alloc
autoload
bind
bindkey
builtin
bye
caller
cap
chdir
clone
 


comparguments
compcall
compctl
compdescribe
compfiles
compgen
compgroups
complete
compquote
comptags
 


comptry
compvalues
declare
dirs
disable
disown
dosh
echotc
echoti
help
 


history
hist
let
local
login
logout
map
mapfile
popd
print
 


pushd
readarray
repeat
savehistory
source
shopt
stop
suspend
typeset
whence
 

If the command name matches the name of a function known to this shell, the function shall be invoked as described in Function Definition Command. If the implementation has provided a standard utility in the form of a function, it shall not be recognized at this point. It shall be invoked in conjunction with the path search in step 1e.

If the command name matches the name [XSI] [Option Start]  of the type or ulimit utility, or [Option End]  of a utility listed in the following table, that utility shall be invoked.


alias
bg
cd
command
 


false
fc
fg
getopts
 


hash
jobs
kill
newgrp
 


pwd
read
true
umask
 


unalias
wait
 

Otherwise, the command shall be searched for using the PATH environment variable as described in XBD Environment Variables :

If the search is successful:

If the system has implemented the utility as a regular built-in or as a shell function, it shall be invoked at this point in the path search.

Otherwise, the shell executes the utility in a separate utility environment (see Shell Execution Environment) with actions equivalent to calling the execl() function as defined in the System Interfaces volume of POSIX.1-2008 with the path argument set to the pathname resulting from the search, arg0 set to the command name, and the remaining execl() arguments set to the command arguments (if any) and the null terminator.

If the execl() function fails due to an error equivalent to the [ENOEXEC] error defined in the System Interfaces volume of POSIX.1-2008, the shell shall execute a command equivalent to having a shell invoked with the pathname resulting from the search as its first operand, with any remaining arguments passed to the new shell, except that the value of "$0" in the new shell may be set to the command name. If the executable file is not a text file, the shell may bypass this command execution. In this case, it shall write an error message, and shall return an exit status of 126.

It is unspecified whether environment variables that were passed to the shell when it was invoked, but were not used to initialize shell variables (see Shell Variables) because they had invalid names, are included in the environment passed to execl() and (if execl() fails as described above) to the new shell.

Once a utility has been searched for and found (either as a result of this specific search or as part of an unspecified shell start-up activity), an implementation may remember its location and need not search for the utility again unless the PATH variable has been the subject of an assignment. If the remembered location fails for a subsequent invocation, the shell shall repeat the search to find the new location for the utility, if any.

If the search is unsuccessful, the command shall fail with an exit status of 127 and the shell shall write an error message.

If the command name contains at least one <slash>, the shell shall execute the utility in a separate utility environment with actions equivalent to calling the execl() function defined in the System Interfaces volume of POSIX.1-2008 with the path and arg0 arguments set to the command name, and the remaining execl() arguments set to the command arguments (if any) and the null terminator.

If the execl() function fails due to an error equivalent to the [ENOEXEC] error, the shell shall execute a command equivalent to having a shell invoked with the command name as its first operand, with any remaining arguments passed to the new shell. If the executable file is not a text file, the shell may bypass this command execution. In this case, it shall write an error message and shall return an exit status of 126.

It is unspecified whether environment variables that were passed to the shell when it was invoked, but were not used to initialize shell variables (see Shell Variables) because they had invalid names, are included in the environment passed to execl() and (if execl() fails as described above) to the new shell.

If the utility would be executed with file descriptor 0, 1, or 2 closed, implementations may execute the utility with the file descriptor open to an unspecified file. If a standard utility or a conforming application is executed with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for writing, the environment in which the utility or application is executed shall be deemed non-conforming, and consequently the utility or application might not behave as described in this standard.

2.9.2 Pipelines
A pipeline is a sequence of one or more commands separated by the control operator '|'. For each command but the last, the shell shall connect the standard output of the command to the standard input of the next command as if by creating a pipe and passing the write end of the pipe as the standard output of the command and the read end of the pipe as the standard input of the next command.

The format for a pipeline is:

[!] command1 [ | command2 ...]
If the pipeline begins with the reserved word ! and command1 is a subshell command, the application shall ensure that the ( operator at the beginning of command1 is separated from the ! by one or more <blank> characters. The behavior of the reserved word ! immediately followed by the ( operator is unspecified.

The standard output of command1 shall be connected to the standard input of command2. The standard input, standard output, or both of a command shall be considered to be assigned by the pipeline before any redirection specified by redirection operators that are part of the command (see Redirection).

If the pipeline is not in the background (see Asynchronous Lists), the shell shall wait for the last command specified in the pipeline to complete, and may also wait for all commands to complete.

Exit Status
If the pipeline does not begin with the ! reserved word, the exit status shall be the exit status of the last command specified in the pipeline. Otherwise, the exit status shall be the logical NOT of the exit status of the last command. That is, if the last command returns zero, the exit status shall be 1; if the last command returns greater than zero, the exit status shall be zero.

2.9.3 Lists
An AND-OR list is a sequence of one or more pipelines separated by the operators "&&" and "||" .

A list is a sequence of one or more AND-OR lists separated by the operators ';' and '&'.

The operators "&&" and "||" shall have equal precedence and shall be evaluated with left associativity. For example, both of the following commands write solely bar to standard output:

false && echo foo || echo bar
true || echo foo && echo bar

A ';' separator or a ';' or <newline> terminator shall cause the preceding AND-OR list to be executed sequentially; an '&' separator or terminator shall cause asynchronous execution of the preceding AND-OR list.

The term "compound-list" is derived from the grammar in Shell Grammar; it is equivalent to a sequence of lists, separated by <newline> characters, that can be preceded or followed by an arbitrary number of <newline> characters.

The following sections are informative.
Examples
The following is an example that illustrates <newline> characters in compound-lists:

while
    # a couple of <newline>s


    # a list
    date && who || ls; cat file
    # a couple of <newline>s


    # another list
    wc file > output & true


do
    # 2 lists
    ls
    cat file
done

End of informative text.
Asynchronous Lists
If a command is terminated by the control operator <ampersand> ( '&' ), the shell shall execute the command asynchronously in a subshell. This means that the shell shall not wait for the command to finish before executing the next command.

The format for running a command in the background is:

command1 & [command2 & ... ]
If job control is disabled (see set, -m), the standard input for an asynchronous list, before any explicit redirections are performed, shall be considered to be assigned to a file that has the same properties as /dev/null. This shall not happen if job control is enabled. In all cases, explicit redirection of standard input shall override this activity.

When an element of an asynchronous list (the portion of the list ended by an <ampersand>, such as command1, above) is started by the shell, the process ID of the last command in the asynchronous list element shall become known in the current shell execution environment; see Shell Execution Environment. This process ID shall remain known until:

The command terminates and the application waits for the process ID.

Another asynchronous list is invoked before "$!" (corresponding to the previous asynchronous list) is expanded in the current execution environment.

The implementation need not retain more than the {CHILD_MAX} most recent entries in its list of known process IDs in the current shell execution environment.

Exit Status
The exit status of an asynchronous list shall be zero.

Sequential Lists
Commands that are separated by a <semicolon> ( ';' ) shall be executed sequentially.

The format for executing commands sequentially shall be:

command1 [; command2] ...

Each command shall be expanded and executed in the order specified.

Exit Status
The exit status of a sequential list shall be the exit status of the last command in the list.

AND Lists
The control operator "&&" denotes an AND list. The format shall be:

command1 [ && command2] ...

First command1 shall be executed. If its exit status is zero, command2 shall be executed, and so on, until a command has a non-zero exit status or there are no more commands left to execute. The commands are expanded only if they are executed.

Exit Status
The exit status of an AND list shall be the exit status of the last command that is executed in the list.

OR Lists
The control operator "||" denotes an OR List. The format shall be:

command1 [ || command2] ...

First, command1 shall be executed. If its exit status is non-zero, command2 shall be executed, and so on, until a command has a zero exit status or there are no more commands left to execute.

Exit Status
The exit status of an OR list shall be the exit status of the last command that is executed in the list.

2.9.4 Compound Commands
The shell has several programming constructs that are "compound commands", which provide control flow for commands. Each of these compound commands has a reserved word or control operator at the beginning, and a corresponding terminator reserved word or operator at the end. In addition, each can be followed by redirections on the same line as the terminator. Each redirection shall apply to all the commands within the compound command that do not explicitly override that redirection.

Grouping Commands
The format for grouping commands is as follows:

( compound-list )
Execute compound-list in a subshell environment; see Shell Execution Environment. Variable assignments and built-in commands that affect the environment shall not remain in effect after the list finishes.
If a character sequence beginning with "((" would be parsed by the shell as an arithmetic expansion if preceded by a '$', shells which implement an extension whereby "((expression))" is evaluated as an arithmetic expression may treat the "((" as introducing as an arithmetic evaluation instead of a grouping command. A conforming application shall ensure that it separates the two leading '(' characters with white space to prevent the shell from performing an arithmetic evaluation.

{ compound-list ; }
Execute compound-list in the current process environment. The semicolon shown here is an example of a control operator delimiting the } reserved word. Other delimiters are possible, as shown in Shell Grammar; a <newline> is frequently used.
Exit Status
The exit status of a grouping command shall be the exit status of compound-list.

The for Loop
The for loop shall execute a sequence of commands for each member in a list of items. The for loop requires that the reserved words do and done be used to delimit the sequence of commands.

The format for the for loop is as follows:

for name [ in [word ... ]]
do
    compound-list
done

First, the list of words following in shall be expanded to generate a list of items. Then, the variable name shall be set to each item, in turn, and the compound-list executed each time. If no items result from the expansion, the compound-list shall not be executed. Omitting:

in word...
shall be equivalent to:

in "$@"

Exit Status
The exit status of a for command shall be the exit status of the last command that executes. If there are no items, the exit status shall be zero.

Case Conditional Construct
The conditional construct case shall execute the compound-list corresponding to the first one of several patterns (see Pattern Matching Notation) that is matched by the string resulting from the tilde expansion, parameter expansion, command substitution, arithmetic expansion, and quote removal of the given word. The reserved word in shall denote the beginning of the patterns to be matched. Multiple patterns with the same compound-list shall be delimited by the '|' symbol. The control operator ')' terminates a list of patterns corresponding to a given action. The compound-list for each list of patterns, with the possible exception of the last, shall be terminated with ";;". The case construct terminates with the reserved word esac (case reversed).
The format for the case construct is as follows:

case word in
    [(] pattern1 ) compound-list ;;
    [[(] pattern[ | pattern] ... ) compound-list ;;] ...
    [[(] pattern[ | pattern] ... ) compound-list]
esac

The ";;" is optional for the last compound-list.

In order from the beginning to the end of the case statement, each pattern that labels a compound-list shall be subjected to tilde expansion, parameter expansion, command substitution, and arithmetic expansion, and the result of these expansions shall be compared against the expansion of word, according to the rules described in Pattern Matching Notation (which also describes the effect of quoting parts of the pattern). After the first match, no more patterns shall be expanded, and the compound-list shall be executed. The order of expansion and comparison of multiple patterns that label a compound-list statement is unspecified.

Exit Status
The exit status of case shall be zero if no patterns are matched. Otherwise, the exit status shall be the exit status of the last command executed in the compound-list.

The if Conditional Construct
The if command shall execute a compound-list and use its exit status to determine whether to execute another compound-list.

The format for the if construct is as follows:

if compound-list
then
    compound-list
[elif compound-list
then
    compound-list] ...
[else
    compound-list]
fi

The if compound-list shall be executed; if its exit status is zero, the then compound-list shall be executed and the command shall complete. Otherwise, each elif compound-list shall be executed, in turn, and if its exit status is zero, the then compound-list shall be executed and the command shall complete. Otherwise, the else compound-list shall be executed.

Exit Status
The exit status of the if command shall be the exit status of the then or else compound-list that was executed, or zero, if none was executed.

The while Loop
The while loop shall continuously execute one compound-list as long as another compound-list has a zero exit status.

The format of the while loop is as follows:

while compound-list-1
do
    compound-list-2
done

The compound-list-1 shall be executed, and if it has a non-zero exit status, the while command shall complete. Otherwise, the compound-list-2 shall be executed, and the process shall repeat.

Exit Status
The exit status of the while loop shall be the exit status of the last compound-list-2 executed, or zero if none was executed.

The until Loop
The until loop shall continuously execute one compound-list as long as another compound-list has a non-zero exit status.

The format of the until loop is as follows:

until compound-list-1
do
    compound-list-2
done

The compound-list-1 shall be executed, and if it has a zero exit status, the until command completes. Otherwise, the compound-list-2 shall be executed, and the process repeats.

Exit Status
The exit status of the until loop shall be the exit status of the last compound-list-2 executed, or zero if none was executed.

2.9.5 Function Definition Command
A function is a user-defined name that is used as a simple command to call a compound command with new positional parameters. A function is defined with a "function definition command".

The format of a function definition command is as follows:

fname ( ) compound-command [io-redirect ...]
The function is named fname; the application shall ensure that it is a name (see XBD Name) and that it is not the name of a special built-in utility. An implementation may allow other characters in a function name as an extension. The implementation shall maintain separate name spaces for functions and variables.

The argument compound-command represents a compound command, as described in Compound Commands.

When the function is declared, none of the expansions in wordexp shall be performed on the text in compound-command or io-redirect; all expansions shall be performed as normal each time the function is called. Similarly, the optional io-redirect redirections and any variable assignments within compound-command shall be performed during the execution of the function itself, not the function definition. See Consequences of Shell Errors for the consequences of failures of these operations on interactive and non-interactive shells.

When a function is executed, it shall have the syntax-error properties described for special built-in utilities in the first item in the enumerated list at the beginning of Special Built-In Utilities.

The compound-command shall be executed whenever the function name is specified as the name of a simple command (see C


<<< Previous	Home	Next >>>
The Open Group Base Specifications Issue 7
IEEE Std 1003.1-2008, 2016 Edition
Copyright  2001-2016 The IEEE and The Open Group
2. Shell Command Language
This chapter contains the definition of the Shell Command Language.

2.1 Shell Introduction
The shell is a command language interpreter. This chapter describes the syntax of that command language as it is used by the sh utility and the system() and popen() functions defined in the System Interfaces volume of POSIX.1-2008.

The shell operates according to the following general overview of operations. The specific details are included in the cited sections of this chapter.

The shell reads its input from a file (see sh), from the -c option or from the system() and popen() functions defined in the System Interfaces volume of POSIX.1-2008. If the first line of a file of shell commands starts with the characters "#!", the results are unspecified.

The shell breaks the input into tokens: words and operators; see Token Recognition.

The shell parses the input into simple commands (see Simple Commands) and compound commands (see Compound Commands).

The shell performs various expansions (separately) on different parts of each command, resulting in a list of pathnames and fields to be treated as a command and arguments; see wordexp.

The shell performs redirection (see Redirection) and removes redirection operators and their operands from the parameter list.

The shell executes a function (see Function Definition Command), built-in (see Special Built-In Utilities), executable file, or script, giving the names of the arguments as positional parameters numbered 1 to n, and the name of the command (or in the case of a function within a script, the name of the script) as the positional parameter numbered 0 (see Command Search and Execution).

The shell optionally waits for the command to complete and collects the exit status (see Exit Status for Commands).

2.2 Quoting
Quoting is used to remove the special meaning of certain characters or words to the shell. Quoting can be used to preserve the literal meaning of the special characters in the next paragraph, prevent reserved words from being recognized as such, and prevent parameter expansion and command substitution within here-document processing (see Here-Document).

The application shall quote the following characters if they are to represent themselves:

|  &  ;  <  >  (  )  $  `  \  "  '  <space>  <tab>  <newline>

and the following may need to be quoted under certain circumstances. That is, these characters may be special depending on conditions described elsewhere in this volume of POSIX.1-2008:

*   ?   [   #      =   %

The various quoting mechanisms are the escape character, single-quotes, and double-quotes. The here-document represents another form of quoting; see Here-Document.

2.2.1 Escape Character (Backslash)
A <backslash> that is not quoted shall preserve the literal value of the following character, with the exception of a <newline>. If a <newline> follows the <backslash>, the shell shall interpret this as line continuation. The <backslash> and <newline> shall be removed before splitting the input into tokens. Since the escaped <newline> is removed entirely from the input and is not replaced by any white space, it cannot serve as a token separator.

2.2.2 Single-Quotes
Enclosing characters in single-quotes ( '' ) shall preserve the literal value of each character within the single-quotes. A single-quote cannot occur within single-quotes.

2.2.3 Double-Quotes
Enclosing characters in double-quotes ( "" ) shall preserve the literal value of all characters within the double-quotes, with the exception of the characters backquote, <dollar-sign>, and <backslash>, as follows:

$
The <dollar-sign> shall retain its special meaning introducing parameter expansion (see Parameter Expansion), a form of command substitution (see Command Substitution), and arithmetic expansion (see Arithmetic Expansion).
The input characters within the quoted string that are also enclosed between "$(" and the matching ')' shall not be affected by the double-quotes, but rather shall define that command whose output replaces the "$(...)" when the word is expanded. The tokenizing rules in Token Recognition, not including the alias substitutions in Alias Substitution, shall be applied recursively to find the matching ')'.

Within the string of characters from an enclosed "${" to the matching '}', an even number of unescaped double-quotes or single-quotes, if any, shall occur. A preceding <backslash> character shall be used to escape a literal '{' or '}'. The rule in Parameter Expansion shall be used to determine the matching '}'.

`
The backquote shall retain its special meaning introducing the other form of command substitution (see Command Substitution). The portion of the quoted string from the initial backquote and the characters up to the next backquote that is not preceded by a <backslash>, having escape characters removed, defines that command whose output replaces "`...`" when the word is expanded. Either of the following cases produces undefined results:
A single-quoted or double-quoted string that begins, but does not end, within the "`...`" sequence

A "`...`" sequence that begins, but does not end, within the same double-quoted string

\
The <backslash> shall retain its special meaning as an escape character (see Escape Character (Backslash)) only when followed by one of the following characters when considered special:
$   `   "   \   <newline>

The application shall ensure that a double-quote is preceded by a <backslash> to be included within double-quotes. The parameter '@' has special meaning inside double-quotes and is described in Special Parameters .

2.3 Token Recognition
The shell shall read its input in terms of lines. (For details about how the shell reads its input, see the description of sh.) The input lines can be of unlimited length. These lines shall be parsed using two major modes: ordinary token recognition and processing of here-documents.

When an io_here token has been recognized by the grammar (see Shell Grammar), one or more of the subsequent lines immediately following the next NEWLINE token form the body of one or more here-documents and shall be parsed according to the rules of Here-Document.

When it is not processing an io_here, the shell shall break its input into tokens by applying the first applicable rule below to the next character in its input. The token shall be from the current position in the input until a token is delimited according to one of the rules below; the characters forming the token are exactly those in the input, including any quoting characters. If it is indicated that a token is delimited, and no characters have been included in a token, processing shall continue until an actual token is delimited.

If the end of input is recognized, the current token (if any) shall be delimited.

If the previous character was used as part of an operator and the current character is not quoted and can be used with the previous characters to form an operator, it shall be used as part of that (operator) token.

If the previous character was used as part of an operator and the current character cannot be used with the previous characters to form an operator, the operator containing the previous character shall be delimited.

If the current character is <backslash>, single-quote, or double-quote and it is not quoted, it shall affect quoting for subsequent characters up to the end of the quoted text. The rules for quoting are as described in Quoting . During token recognition no substitutions shall be actually performed, and the result token shall contain exactly the characters that appear in the input (except for <newline> joining), unmodified, including any embedded or enclosing quotes or substitution operators, between the <quotation-mark> and the end of the quoted text. The token shall not be delimited by the end of the quoted field.

If the current character is an unquoted '$' or '`', the shell shall identify the start of any candidates for parameter expansion (Parameter Expansion), command substitution (Command Substitution), or arithmetic expansion (Arithmetic Expansion) from their introductory unquoted character sequences: '$' or "${", "$(" or '`', and "$((", respectively. The shell shall read sufficient input to determine the end of the unit to be expanded (as explained in the cited sections). While processing the characters, if instances of expansions or quoting are found nested within the substitution, the shell shall recursively process them in the manner specified for the construct that is found. The characters found from the beginning of the substitution to its end, allowing for any recursion necessary to recognize embedded constructs, shall be included unmodified in the result token, including any embedded or enclosing substitution operators or quotes. The token shall not be delimited by the end of the substitution.

If the current character is not quoted and can be used as the first character of a new operator, the current token (if any) shall be delimited. The current character shall be used as the beginning of the next (operator) token.

If the current character is an unquoted <blank>, any token containing the previous character is delimited and the current character shall be discarded.

If the previous character was part of a word, the current character shall be appended to that word.

If the current character is a '#', it and all subsequent characters up to, but excluding, the next <newline> shall be discarded as a comment. The <newline> that ends the line is not considered part of the comment.

The current character is used as the start of a new word.

Once a token is delimited, it is categorized as required by the grammar in Shell Grammar.

2.3.1 Alias Substitution
After a token has been delimited, but before applying the grammatical rules in Shell Grammar, a resulting word that is identified to be the command name word of a simple command shall be examined to determine whether it is an unquoted, valid alias name. However, reserved words in correct grammatical context shall not be candidates for alias substitution. A valid alias name (see XBD Alias Name) shall be one that has been defined by the alias utility and not subsequently undefined using unalias. Implementations also may provide predefined valid aliases that are in effect when the shell is invoked. To prevent infinite loops in recursive aliasing, if the shell is not currently processing an alias of the same name, the word shall be replaced by the value of the alias; otherwise, it shall not be replaced.

If the value of the alias replacing the word ends in a <blank>, the shell shall check the next command word for alias substitution; this process shall continue until a word is found that is not a valid alias or an alias value does not end in a <blank>.

When used as specified by this volume of POSIX.1-2008, alias definitions shall not be inherited by separate invocations of the shell or by the utility execution environments invoked by the shell; see Shell Execution Environment.

2.4 Reserved Words
Reserved words are words that have special meaning to the shell; see Shell Commands. The following words shall be recognized as reserved words:


!
{
}
case


do
done
elif
else


esac
fi
for
if


in
then
until
while

This recognition shall only occur when none of the characters is quoted and when the word is used as:

The first word of a command

The first word following one of the reserved words other than case, for, or in

The third word in a case command (only in is valid in this case)

The third word in a for command (only in and do are valid in this case)

See the grammar in Shell Grammar.

The following words may be recognized as reserved words on some implementations (when none of the characters are quoted), causing unspecified results:

[[

]]

function

select

Words that are the concatenation of a name and a <colon> ( ':' ) are reserved; their use produces unspecified results.

2.5 Parameters and Variables
A parameter can be denoted by a name, a number, or one of the special characters listed in Special Parameters. A variable is a parameter denoted by a name.

A parameter is set if it has an assigned value (null is a valid value). Once a variable is set, it can only be unset by using the unset special built-in command.

2.5.1 Positional Parameters
A positional parameter is a parameter denoted by the decimal value represented by one or more digits, other than the single digit 0. The digits denoting the positional parameters shall always be interpreted as a decimal value, even if there is a leading zero. When a positional parameter with more than one digit is specified, the application shall enclose the digits in braces (see Parameter Expansion). Positional parameters are initially assigned when the shell is invoked (see sh), temporarily replaced when a shell function is invoked (see Function Definition Command), and can be reassigned with the set special built-in command.

2.5.2 Special Parameters
Listed below are the special parameters and the values to which they shall expand. Only the values of the special parameters are listed; see wordexp for a detailed summary of all the stages involved in expanding words.

@
Expands to the positional parameters, starting from one, initially producing one field for each positional parameter that is set. When the expansion occurs in a context where field splitting will be performed, any empty fields may be discarded and each of the non-empty fields shall be further split as described in Field Splitting. When the expansion occurs within double-quotes, the behavior is unspecified unless one of the following is true:
Field splitting as described in Field Splitting would be performed if the expansion were not within double-quotes (regardless of whether field splitting would have any effect; for example, if IFS is null).

The double-quotes are within the word of a ${parameter:-word} or a ${parameter:+word} expansion (with or without the <colon>; see Parameter Expansion) which would have been subject to field splitting if parameter had been expanded instead of word.

If one of these conditions is true, the initial fields shall be retained as separate fields, except that if the parameter being expanded was embedded within a word, the first field shall be joined with the beginning part of the original word and the last field shall be joined with the end part of the original word. In all other contexts the results of the expansion are unspecified. If there are no positional parameters, the expansion of '@' shall generate zero fields, even when '@' is within double-quotes; however, if the expansion is embedded within a word which contains one or more other parts that expand to a quoted null string, these null string(s) shall still produce an empty field, except that if the other parts are all within the same double-quotes as the '@', it is unspecified whether the result is zero fields or one empty field.

*
Expands to the positional parameters, starting from one, initially producing one field for each positional parameter that is set. When the expansion occurs in a context where field splitting will be performed, any empty fields may be discarded and each of the non-empty fields shall be further split as described in Field Splitting. When the expansion occurs in a context where field splitting will not be performed, the initial fields shall be joined to form a single field with the value of each parameter separated by the first character of the IFS variable if IFS contains at least one character, or separated by a <space> if IFS is unset, or with no separation if IFS is set to a null string.
#
Expands to the decimal number of positional parameters. The command name (parameter 0) shall not be counted in the number given by '#' because it is a special parameter, not a positional parameter.
?
Expands to the decimal exit status of the most recent pipeline (see Pipelines).
-
(Hyphen.) Expands to the current option flags (the single-letter option names concatenated into a string) as specified on invocation, by the set special built-in command, or implicitly by the shell.
$
Expands to the decimal process ID of the invoked shell. In a subshell (see Shell Execution Environment ), '$' shall expand to the same value as that of the current shell.
!
Expands to the decimal process ID of the most recent background command (see Lists) executed from the current shell. (For example, background commands executed from subshells do not affect the value of "$!" in the current shell environment.) For a pipeline, the process ID is that of the last command in the pipeline.
0
(Zero.) Expands to the name of the shell or shell script. See sh for a detailed description of how this name is derived.
See the description of the IFS variable in Shell Variables.

2.5.3 Shell Variables
Variables shall be initialized from the environment (as defined by XBD Environment Variables and the exec function in the System Interfaces volume of POSIX.1-2008) and can be given new values with variable assignment commands. If a variable is initialized from the environment, it shall be marked for export immediately; see the export special built-in. New variables can be defined and initialized with variable assignments, with the read or getopts utilities, with the name parameter in a for loop, with the ${ name= word} expansion, or with other mechanisms provided as implementation extensions.
The following variables shall affect the execution of the shell:

ENV
[UP] [Option Start] The processing of the ENV shell variable shall be supported if the system supports the User Portability Utilities option. [Option End]
This variable, when and only when an interactive shell is invoked, shall be subjected to parameter expansion (see Parameter Expansion) by the shell and the resulting value shall be used as a pathname of a file containing shell commands to execute in the current environment. The file need not be executable. If the expanded value of ENV is not an absolute pathname, the results are unspecified. ENV shall be ignored if the user's real and effective user IDs or real and effective group IDs are different.

HOME
The pathname of the user's home directory. The contents of HOME are used in tilde expansion (see Tilde Expansion).
IFS
A string treated as a list of characters that is used for field splitting, expansion of the '*' special parameter, and to split lines into fields with the read utility. If the value of IFS includes any bytes that do not form part of a valid character, the results of field splitting, expansion of '*', and use of the read utility are unspecified.
If IFS is not set, it shall behave as normal for an unset variable, except that field splitting by the shell and line splitting by the read utility shall be performed as if the value of IFS is <space> <tab> <newline>; see Field Splitting.

The shell shall set IFS to <space> <tab> <newline> when it is invoked.

LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD Internationalization Variables for the precedence of internationalization variables used to determine the values of locale categories.)
LC_ALL
The value of this variable overrides the LC_* variables and LANG, as described in XBD Environment Variables.
LC_COLLATE
Determine the behavior of range expressions, equivalence classes, and multi-character collating elements within pattern matching.
LC_CTYPE
Determine the interpretation of sequences of bytes of text data as characters (for example, single-byte as opposed to multi-byte characters), which characters are defined as letters (character class alpha) and <blank> characters (character class blank), and the behavior of character classes within pattern matching. Changing the value of LC_CTYPE after the shell has started shall not affect the lexical processing of shell commands in the current shell execution environment or its subshells. Invoking a shell script or performing exec sh subjects the new shell to the changes in LC_CTYPE.
LC_MESSAGES
Determine the language in which messages should be written.
LINENO
Set by the shell to a decimal number representing the current sequential line number (numbered starting with 1) within a script or function before it executes each command. If the user unsets or resets LINENO, the variable may lose its special meaning for the life of the shell. If the shell is not currently executing a script or function, the value of LINENO is unspecified. This volume of POSIX.1-2008 specifies the effects of the variable only for systems supporting the User Portability Utilities option.
NLSPATH
[XSI] [Option Start] Determine the location of message catalogs for the processing of LC_MESSAGES. [Option End]
PATH
A string formatted as described in XBD Environment Variables, used to effect command interpretation; see Command Search and Execution.
PPID
Set by the shell to the decimal value of its parent process ID during initialization of the shell. In a subshell (see Shell Execution Environment), PPID shall be set to the same value as that of the parent of the current shell. For example, echo $ PPID and (echo $ PPID) would produce the same value.
PS1
Each time an interactive shell is ready to read a command, the value of this variable shall be subjected to parameter expansion and written to standard error. The default value shall be "$ ". For users who have specific additional implementation-defined privileges, the default may be another, implementation-defined value. The shell shall replace each instance of the character '!' in PS1 with the history file number of the next command to be typed. Escaping the '!' with another '!' (that is, "!!" ) shall place the literal character '!' in the prompt. This volume of POSIX.1-2008 specifies the effects of the variable only for systems supporting the User Portability Utilities option.
PS2
Each time the user enters a <newline> prior to completing a command line in an interactive shell, the value of this variable shall be subjected to parameter expansion and written to standard error. The default value is "> ". This volume of POSIX.1-2008 specifies the effects of the variable only for systems supporting the User Portability Utilities option.
PS4
When an execution trace (set -x) is being performed in an interactive shell, before each line in the execution trace, the value of this variable shall be subjected to parameter expansion and written to standard error. The default value is "+ ". This volume of POSIX.1-2008 specifies the effects of the variable only for systems supporting the User Portability Utilities option.
PWD
Set by the shell and by the cd utility. In the shell the value shall be initialized from the environment as follows. If a value for PWD is passed to the shell in the environment when it is executed, the value is an absolute pathname of the current working directory that is no longer than {PATH_MAX} bytes including the terminating null byte, and the value does not contain any components that are dot or dot-dot, then the shell shall set PWD to the value from the environment. Otherwise, if a value for PWD is passed to the shell in the environment when it is executed, the value is an absolute pathname of the current working directory, and the value does not contain any components that are dot or dot-dot, then it is unspecified whether the shell sets PWD to the value from the environment or sets PWD to the pathname that would be output by pwd -P. Otherwise, the sh utility sets PWD to the pathname that would be output by pwd -P. In cases where PWD is set to the value from the environment, the value can contain components that refer to files of type symbolic link. In cases where PWD is set to the pathname that would be output by pwd -P, if there is insufficient permission on the current working directory, or on any parent of that directory, to determine what that pathname would be, the value of PWD is unspecified. Assignments to this variable may be ignored. If an application sets or unsets the value of PWD, the behaviors of the cd and pwd utilities are unspecified.
2.6 Word Expansions
This section describes the various expansions that are performed on words. Not all expansions are performed on every word, as explained in the following sections.

Tilde expansions, parameter expansions, command substitutions, arithmetic expansions, and quote removals that occur within a single word expand to a single field. It is only field splitting or pathname expansion that can create multiple fields from a single word. The single exception to this rule is the expansion of the special parameter '@' within double-quotes, as described in Special Parameters.

The order of word expansion shall be as follows:

Tilde expansion (see Tilde Expansion), parameter expansion (see Parameter Expansion), command substitution (see Command Substitution), and arithmetic expansion (see Arithmetic Expansion) shall be performed, beginning to end. See item 5 in Token Recognition.

Field splitting (see Field Splitting) shall be performed on the portions of the fields generated by step 1, unless IFS is null.

Pathname expansion (see Pathname Expansion) shall be performed, unless set -f is in effect.

Quote removal (see Quote Removal) shall always be performed last.

The expansions described in this section shall occur in the same shell environment as that in which the command is executed.

If the complete expansion appropriate for a word results in an empty field, that empty field shall be deleted from the list of fields that form the completely expanded command, unless the original word contained single-quote or double-quote characters.

The '$' character is used to introduce parameter expansion, command substitution, or arithmetic evaluation. If an unquoted '$' is followed by a character that is not one of the following:

A numeric character

The name of one of the special parameters (see Special Parameters)

A valid first character of a variable name

A <left-curly-bracket> ( '{' )

A <left-parenthesis>

the result is unspecified.

2.6.1 Tilde Expansion
A "tilde-prefix" consists of an unquoted <tilde> character at the beginning of a word, followed by all of the characters preceding the first unquoted <slash> in the word, or all the characters in the word if there is no <slash>. In an assignment (see XBD Variable Assignment), multiple tilde-prefixes can be used: at the beginning of the word (that is, following the <equals-sign> of the assignment), following any unquoted <colon>, or both. A tilde-prefix in an assignment is terminated by the first unquoted <colon> or <slash>. If none of the characters in the tilde-prefix are quoted, the characters in the tilde-prefix following the <tilde> are treated as a possible login name from the user database. A portable login name cannot contain characters outside the set given in the description of the LOGNAME environment variable in XBD Other Environment Variables. If the login name is null (that is, the tilde-prefix contains only the tilde), the tilde-prefix is replaced by the value of the variable HOME. If HOME is unset, the results are unspecified. Otherwise, the tilde-prefix shall be replaced by a pathname of the initial working directory associated with the login name obtained using the getpwnam() function as defined in the System Interfaces volume of POSIX.1-2008. If the system does not recognize the login name, the results are undefined.

The pathname resulting from tilde expansion shall be treated as if quoted to prevent it being altered by field splitting and pathname expansion.

2.6.2 Parameter Expansion
The format for parameter expansion is as follows:

${expression}

where expression consists of all characters until the matching '}'. Any '}' escaped by a <backslash> or within a quoted string, and characters in embedded arithmetic expansions, command substitutions, and variable expansions, shall not be examined in determining the matching '}'.

The simplest form for parameter expansion is:

${parameter}

The value, if any, of parameter shall be substituted.

The parameter name or symbol can be enclosed in braces, which are optional except for positional parameters with more than one digit or when parameter is a name and is followed by a character that could be interpreted as part of the name. The matching closing brace shall be determined by counting brace levels, skipping over enclosed quoted strings, and command substitutions.

If the parameter is not enclosed in braces, and is a name, the expansion shall use the longest valid name (see XBD Name), whether or not the variable represented by that name exists. Otherwise, the parameter is a single-character symbol, and behavior is unspecified if that character is neither a digit nor one of the special parameters (see Special Parameters).

If a parameter expansion occurs inside double-quotes:

Pathname expansion shall not be performed on the results of the expansion.

Field splitting shall not be performed on the results of the expansion.

In addition, a parameter expansion can be modified by using one of the following formats. In each case that a value of word is needed (based on the state of parameter, as described below), word shall be subjected to tilde expansion, parameter expansion, command substitution, and arithmetic expansion. If word is not needed, it shall not be expanded. The '}' character that delimits the following parameter expansion modifications shall be determined as described previously in this section and in Double-Quotes.

${parameter:-[word]}
Use Default Values. If parameter is unset or null, the expansion of word (or an empty string if word is omitted) shall be substituted; otherwise, the value of parameter shall be substituted.
${parameter:=[word]}
Assign Default Values. If parameter is unset or null, the expansion of word (or an empty string if word is omitted) shall be assigned to parameter. In all cases, the final value of parameter shall be substituted. Only variables, not positional parameters or special parameters, can be assigned in this way.
${parameter:?[word]}
Indicate Error if Null or Unset. If parameter is unset or null, the expansion of word (or a message indicating it is unset if word is omitted) shall be written to standard error and the shell exits with a non-zero exit status. Otherwise, the value of parameter shall be substituted. An interactive shell need not exit.
${parameter:+[word]}
Use Alternative Value. If parameter is unset or null, null shall be substituted; otherwise, the expansion of word (or an empty string if word is omitted) shall be substituted.
In the parameter expansions shown previously, use of the <colon> in the format shall result in a test for a parameter that is unset or null; omission of the <colon> shall result in a test for a parameter that is only unset. If parameter is '#' and the colon is omitted, the application shall ensure that word is specified (this is necessary to avoid ambiguity with the string length expansion). The following table summarizes the effect of the <colon>:

 

parameter
Set and Not Null

parameter
Set But Null

parameter
Unset

${parameter:-word}

substitute parameter

substitute word

substitute word

${parameter-word}

substitute parameter

substitute null

substitute word

${parameter:=word}

substitute parameter

assign word

assign word

${parameter=word}

substitute parameter

substitute null

assign word

${parameter:?word}

substitute parameter

error, exit

error, exit

${parameter?word}

substitute parameter

substitute null

error, exit

${parameter:+word}

substitute word

substitute null

substitute null

${parameter+word}

substitute word

substitute word

substitute null

In all cases shown with "substitute", the expression is replaced with the value shown. In all cases shown with "assign", parameter is assigned that value, which also replaces the expression.

${#parameter}
String Length. The length in characters of the value of parameter shall be substituted. If parameter is '*' or '@', the result of the expansion is unspecified. If parameter is unset and set -u is in effect, the expansion shall fail.
The following four varieties of parameter expansion provide for substring processing. In each case, pattern matching notation (see Pattern Matching Notation), rather than regular expression notation, shall be used to evaluate the patterns. If parameter is '#', '*', or '@', the result of the expansion is unspecified. If parameter is unset and set -u is in effect, the expansion shall fail. Enclosing the full parameter expansion string in double-quotes shall not cause the following four varieties of pattern characters to be quoted, whereas quoting characters within the braces shall have this effect. In each variety, if word is omitted, the empty pattern shall be used.

${parameter%[word]}
Remove Smallest Suffix Pattern. The word shall be expanded to produce a pattern. The parameter expansion shall then result in parameter, with the smallest portion of the suffix matched by the pattern deleted. If present, word shall not begin with an unquoted '%'.
${parameter%%[word]}
Remove Largest Suffix Pattern. The word shall be expanded to produce a pattern. The parameter expansion shall then result in parameter, with the largest portion of the suffix matched by the pattern deleted.
${parameter#[word]}
Remove Smallest Prefix Pattern. The word shall be expanded to produce a pattern. The parameter expansion shall then result in parameter, with the smallest portion of the prefix matched by the pattern deleted. If present, word shall not begin with an unquoted '#'.
${parameter##[word]}
Remove Largest Prefix Pattern. The word shall be expanded to produce a pattern. The parameter expansion shall then result in parameter, with the largest portion of the prefix matched by the pattern deleted.
The following sections are informative.
Examples
${parameter}
In this example, the effects of omitting braces are demonstrated.
a=1
set 2
echo ${a}b-$ab-${1}0-${10}-$10
1b--20--20
${parameter-word}
This example demonstrates the difference between unset and set to the empty string, as well as the rules for finding the delimiting close brace.
foo=asdf
echo ${foo-bar}xyz}
asdfxyz}foo=
echo ${foo-bar}xyz}
xyz}unset foo
echo ${foo-bar}xyz}
barxyz}
${parameter:-word}
In this example, ls is executed only if x is null or unset. (The $(ls) command substitution notation is explained in Command Substitution.)
${x:-$(ls)}

${parameter:=word}
unset X
echo ${X:=abc}
abc
${parameter:?word}
unset posix
echo ${posix:?}
sh: posix: parameter null or not set
${parameter:+word}
set a b c
echo ${3:+posix}
posix
${#parameter}
HOME=/usr/posix
echo ${#HOME}
10
${parameter%word}
x=file.c
echo ${x%.c}.o
file.o
${parameter%%word}
x=posix/src/std
echo ${x%%/*}
posix
${parameter#word}
x=$HOME/src/cmd
echo ${x#$HOME}
/src/cmd
${parameter##word}
x=/one/two/three
echo ${x##*/}
three
The double-quoting of patterns is different depending on where the double-quotes are placed:

"${x#*}"
The <asterisk> is a pattern character.
${x#"*"}
The literal <asterisk> is quoted and not special.
End of informative text.
2.6.3 Command Substitution
Command substitution allows the output of a command to be substituted in place of the command name itself. Command substitution shall occur when the command is enclosed as follows:

$(command)

or (backquoted version):

`command`

The shell shall expand the command substitution by executing command in a subshell environment (see Shell Execution Environment) and replacing the command substitution (the text of command plus the enclosing "$()" or backquotes) with the standard output of the command, removing sequences of one or more <newline> characters at the end of the substitution. Embedded <newline> characters before the end of the output shall not be removed; however, they may be treated as field delimiters and eliminated during field splitting, depending on the value of IFS and quoting that is in effect. If the output contains any null bytes, the behavior is unspecified.

Within the backquoted style of command substitution, <backslash> shall retain its literal meaning, except when followed by: '$', '`', or <backslash>. The search for the matching backquote shall be satisfied by the first unquoted non-escaped backquote; during this search, if a non-escaped backquote is encountered within a shell comment, a here-document, an embedded command substitution of the $(command) form, or a quoted string, undefined results occur. A single-quoted or double-quoted string that begins, but does not end, within the "`...`" sequence produces undefined results.

With the $(command) form, all characters following the open parenthesis to the matching closing parenthesis constitute the command. Any valid shell script can be used for command, except a script consisting solely of redirections which produces unspecified results.

The results of command substitution shall not be processed for further tilde expansion, parameter expansion, command substitution, or arithmetic expansion. If a command substitution occurs inside double-quotes, field splitting and pathname expansion shall not be performed on the results of the substitution.

Command substitution can be nested. To specify nesting within the backquoted version, the application shall precede the inner backquotes with <backslash> characters; for example:

\`command\`

The syntax of the shell command language has an ambiguity for expansions beginning with "$((", which can introduce an arithmetic expansion or a command substitution that starts with a subshell. Arithmetic expansion has precedence; that is, the shell shall first determine whether it can parse the expansion as an arithmetic expansion and shall only parse the expansion as a command substitution if it determines that it cannot parse the expansion as an arithmetic expansion. The shell need not evaluate nested expansions when performing this determination. If it encounters the end of input without already having determined that it cannot parse the expansion as an arithmetic expansion, the shell shall treat the expansion as an incomplete arithmetic expansion and report a syntax error. A conforming application shall ensure that it separates the "$(" and '(' into two tokens (that is, separate them with white space) in a command substitution that starts with a subshell. For example, a command substitution containing a single subshell could be written as:

$( (command) )

2.6.4 Arithmetic Expansion
Arithmetic expansion provides a mechanism for evaluating an arithmetic expression and substituting its value. The format for arithmetic expansion shall be as follows:

$((expression))

The expression shall be treated as if it were in double-quotes, except that a double-quote inside the expression is not treated specially. The shell shall expand all tokens in the expression for parameter expansion, command substitution, and quote removal.

Next, the shell shall treat this as an arithmetic expression and substitute the value of the expression. The arithmetic expression shall be processed according to the rules given in Arithmetic Precision and Operations, with the following exceptions:

Only signed long integer arithmetic is required.

Only the decimal-constant, octal-constant, and hexadecimal-constant constants specified in the ISO C standard, Section 6.4.4.1 are required to be recognized as constants.

The sizeof() operator and the prefix and postfix "++" and "--" operators are not required.

Selection, iteration, and jump statements are not supported.

All changes to variables in an arithmetic expression shall be in effect after the arithmetic expansion, as in the parameter expansion "${x=value}".

If the shell variable x contains a value that forms a valid integer constant, optionally including a leading <plus-sign> or <hyphen-minus>, then the arithmetic expansions "$((x))" and "$(($x))" shall return the same value.

As an extension, the shell may recognize arithmetic expressions beyond those listed. The shell may use a signed integer type with a rank larger than the rank of signed long. The shell may use a real-floating type instead of signed long as long as it does not affect the results in cases where there is no overflow. If the expression is invalid, or the contents of a shell variable used in the expression are not recognized by the shell, the expansion fails and the shell shall write a diagnostic message to standard error indicating the failure.

The following sections are informative.
Examples
A simple example using arithmetic expansion:

# repeat a command 100 times
x=100
while [ $x -gt 0 ]
do
    command    x=$(($x-1))
done

End of informative text.
2.6.5 Field Splitting
After parameter expansion (Parameter Expansion), command substitution (Command Substitution), and arithmetic expansion (Arithmetic Expansion), the shell shall scan the results of expansions and substitutions that did not occur in double-quotes for field splitting and multiple fields can result.

The shell shall treat each character of the IFS as a delimiter and use the delimiters as field terminators to split the results of parameter expansion, command substitution, and arithmetic expansion into fields.

If the value of IFS is a <space>, <tab>, and <newline>, or if it is unset, any sequence of <space>, <tab>, or <newline> characters at the beginning or end of the input shall be ignored and any sequence of those characters within the input shall delimit a field. For example, the input:

<newline><space><tab>foo<tab><tab>bar<space>

yields two fields, foo and bar.

If the value of IFS is null, no field splitting shall be performed.

Otherwise, the following rules shall be applied in sequence. The term " IFS white space" is used to mean any sequence (zero or more instances) of white-space characters that are in the IFS value (for example, if IFS contains <space>/ <comma>/ <tab>, any sequence of <space> and <tab> characters is considered IFS white space).

IFS white space shall be ignored at the beginning and end of the input.

Each occurrence in the input of an IFS character that is not IFS white space, along with any adjacent IFS white space, shall delimit a field, as described previously.

Non-zero-length IFS white space shall delimit a field.

2.6.6 Pathname Expansion
After field splitting, if set -f is not in effect, each field in the resulting command line shall be expanded using the algorithm described in Pattern Matching Notation, qualified by the rules in Patterns Used for Filename Expansion.

2.6.7 Quote Removal
The quote characters ( <backslash>, single-quote, and double-quote) that were present in the original word shall be removed unless they have themselves been quoted.

2.7 Redirection
Redirection is used to open and close files for the current shell execution environment (see Shell Execution Environment) or for any command. Redirection operators can be used with numbers representing file descriptors (see XBD File Descriptor) as described below.

The overall format used for redirection is:

[n]redir-op word
The number n is an optional decimal number designating the file descriptor number; the application shall ensure it is delimited from any preceding text and immediately precede the redirection operator redir-op. If n is quoted, the number shall not be recognized as part of the redirection expression. For example:

echo \2>a

writes the character 2 into file a. If any part of redir-op is quoted, no redirection expression is recognized. For example:

echo 2\>a

writes the characters 2>a to standard output. The optional number, redirection operator, and word shall not appear in the arguments provided to the command to be executed (if any).

Open files are represented by decimal numbers starting with zero. The largest possible value is implementation-defined; however, all implementations shall support at least 0 to 9, inclusive, for use by the application. These numbers are called "file descriptors". The values 0, 1, and 2 have special meaning and conventional uses and are implied by certain redirection operations; they are referred to as standard input, standard output, and standard error, respectively. Programs usually take their input from standard input, and write output on standard output. Error messages are usually written on standard error. The redirection operators can be preceded by one or more digits (with no intervening <blank> characters allowed) to designate the file descriptor number.

If the redirection operator is "<<" or "<<-", the word that follows the redirection operator shall be subjected to quote removal; it is unspecified whether any of the other expansions occur. For the other redirection operators, the word that follows the redirection operator shall be subjected to tilde expansion, parameter expansion, command substitution, arithmetic expansion, and quote removal. Pathname expansion shall not be performed on the word by a non-interactive shell; an interactive shell may perform it, but shall do so only when the expansion would result in one word.

If more than one redirection operator is specified with a command, the order of evaluation is from beginning to end.

A failure to open or create a file shall cause a redirection to fail.

2.7.1 Redirecting Input
Input redirection shall cause the file whose name results from the expansion of word to be opened for reading on the designated file descriptor, or standard input if the file descriptor is not specified.

The general format for redirecting input is:

[n]<word
where the optional n represents the file descriptor number. If the number is omitted, the redirection shall refer to standard input (file descriptor 0).

2.7.2 Redirecting Output
The two general formats for redirecting output are:

[n]>word
[n]>|word
where the optional n represents the file descriptor number. If the number is omitted, the redirection shall refer to standard output (file descriptor 1).

Output redirection using the '>' format shall fail if the noclobber option is set (see the description of set -C) and the file named by the expansion of word exists and is a regular file. Otherwise, redirection using the '>' or ">|" formats shall cause the file whose name results from the expansion of word to be created and opened for output on the designated file descriptor, or standard output if none is specified. If the file does not exist, it shall be created; otherwise, it shall be truncated to be an empty file after being opened.

2.7.3 Appending Redirected Output
Appended output redirection shall cause the file whose name results from the expansion of word to be opened for output on the designated file descriptor. The file is opened as if the open() function as defined in the System Interfaces volume of POSIX.1-2008 was called with the O_APPEND flag. If the file does not exist, it shall be created.

The general format for appending redirected output is as follows:

[n]>>word
where the optional n represents the file descriptor number. If the number is omitted, the redirection refers to standard output (file descriptor 1).

2.7.4 Here-Document
The redirection operators "<<" and "<<-" both allow redirection of subsequent lines read by the shell to the input of a command. The redirected lines are known as a "here-document".

The here-document shall be treated as a single word that begins after the next <newline> and continues until there is a line containing only the delimiter and a <newline>, with no <blank> characters in between. Then the next here-document starts, if there is one. The format is as follows:

[n]<<word
    here-document
delimiter
where the optional n represents the file descriptor number. If the number is omitted, the here-document refers to standard input (file descriptor 0). It is unspecified whether the file descriptor is opened as a regular file, a special file, or a pipe. Portable applications cannot rely on the file descriptor being seekable (see XSH lseek).

If any part of word is quoted, the delimiter shall be formed by performing quote removal on word, and the here-document lines shall not be expanded. Otherwise, the delimiter shall be the word itself.

If no part of word is quoted, all lines of the here-document shall be expanded for parameter expansion, command substitution, and arithmetic expansion. In this case, the <backslash> in the input behaves as the <backslash> inside double-quotes (see Double-Quotes). However, the double-quote character ( ' )' shall not be treated specially within a here-document, except when the double-quote appears within "$()", "``", or "${}".

If the redirection operator is "<<-", all leading <tab> characters shall be stripped from input lines and the line containing the trailing delimiter. If more than one "<<" or "<<-" operator is specified on a line, the here-document associated with the first operator shall be supplied first by the application and shall be read first by the shell.

When a here-document is read from a terminal device and the shell is interactive, it shall write the contents of the variable PS2, processed as described in Shell Variables, to standard error before reading each line of input until the delimiter has been recognized.

The following sections are informative.
Examples
An example of a here-document follows:

cat <<eof1; cat <<eof2
Hi,
eof1
Helene.
eof2

End of informative text.
2.7.5 Duplicating an Input File Descriptor
The redirection operator:

[n]<&word
shall duplicate one input file descriptor from another, or shall close one. If word evaluates to one or more digits, the file descriptor denoted by n, or standard input if n is not specified, shall be made to be a copy of the file descriptor denoted by word; if the digits in word do not represent a file descriptor already open for input, a redirection error shall result; see Consequences of Shell Errors. If word evaluates to '-', file descriptor n, or standard input if n is not specified, shall be closed. Attempts to close a file descriptor that is not open shall not constitute an error. If word evaluates to something else, the behavior is unspecified.

2.7.6 Duplicating an Output File Descriptor
The redirection operator:

[n]>&word
shall duplicate one output file descriptor from another, or shall close one. If word evaluates to one or more digits, the file descriptor denoted by n, or standard output if n is not specified, shall be made to be a copy of the file descriptor denoted by word; if the digits in word do not represent a file descriptor already open for output, a redirection error shall result; see Consequences of Shell Errors. If word evaluates to '-', file descriptor n, or standard output if n is not specified, is closed. Attempts to close a file descriptor that is not open shall not constitute an error. If word evaluates to something else, the behavior is unspecified.

2.7.7 Open File Descriptors for Reading and Writing
The redirection operator:

[n]<>word
shall cause the file whose name is the expansion of word to be opened for both reading and writing on the file descriptor denoted by n, or standard input if n is not specified. If the file does not exist, it shall be created.

2.8 Exit Status and Errors
2.8.1 Consequences of Shell Errors
Certain errors shall cause the shell to write a diagnostic message to standard error and exit as shown in the following table:

Error

Non-Interactive
Shell

Interactive Shell

Shell Diagnostic
Message Required

Shell language syntax error

shall exit

shall not exit

yes

Special built-in utility error

shall exit

shall not exit

no1

Other utility (not a special
built-in) error

shall not exit

shall not exit

no2

Redirection error with
special built-in utilities

shall exit

shall not exit

yes

Redirection error with
compound commands

may exit3

shall not exit

yes

Redirection error with
function execution

may exit3

shall not exit

yes

Redirection error with other
utilities (not special built-ins)

shall not exit

shall not exit

yes

Variable assignment error

shall exit

shall not exit

yes

Expansion error

shall exit

shall not exit

yes

Command not found

may exit

shall not exit

yes

Notes:
Although special built-ins are part of the shell, a diagnostic message written by a special built-in is not considered to be a shell diagnostic message, and can be redirected like any other utility.

The shell is not required to write a diagnostic message, but the utility itself shall write a diagnostic message if required to do so.

A future version of this standard may require the shell to not exit in this condition.

An expansion error is one that occurs when the shell expansions define in wordexp are carried out (for example, "${x!y}", because '!' is not a valid operator); an implementation may treat these as syntax errors if it is able to detect them during tokenization, rather than during expansion.

If any of the errors shown as "shall exit" or "may exit" occur in a subshell environment, the shell shall (respectively, may) exit from the subshell environment with a non-zero status and continue in the environment from which that subshell environment was invoked.

In all of the cases shown in the table where an interactive shell is required not to exit, the shell shall not perform any further processing of the command in which the error occurred.

2.8.2 Exit Status for Commands
Each command has an exit status that can influence the behavior of other shell commands. The exit status of commands that are not utilities is documented in this section. The exit status of the standard utilities is documented in their respective sections.

If a command is not found, the exit status shall be 127. If the command name is found, but it is not an executable utility, the exit status shall be 126. Applications that invoke utilities without using the shell should use these exit status values to report similar errors.

If a command fails during word expansion or redirection, its exit status shall be between 1 and 125 inclusive.

Internally, for purposes of deciding whether a command exits with a non-zero exit status, the shell shall recognize the entire status value retrieved for the command by the equivalent of the wait() function WEXITSTATUS macro (as defined in the System Interfaces volume of POSIX.1-2008). When reporting the exit status with the special parameter '?', the shell shall report the full eight bits of exit status available. The exit status of a command that terminated because it received a signal shall be reported as greater than 128.

2.9 Shell Commands
This section describes the basic structure of shell commands. The following command descriptions each describe a format of the command that is only used to aid the reader in recognizing the command type, and does not formally represent the syntax. In particular, the representations include spacing between tokens in some places where <blank>s would not be necessary (when one of the tokens is an operator). Each description discusses the semantics of the command; for a formal definition of the command language, consult Shell Grammar.

A command is one of the following:

Simple command (see Simple Commands)

Pipeline (see Pipelines)

List compound-list (see Lists)

Compound command (see Compound Commands)

Function definition (see Function Definition Command)

Unless otherwise stated, the exit status of a command shall be that of the last simple command executed by the command. There shall be no limit on the size of any shell command other than that imposed by the underlying system (memory constraints, {ARG_MAX}, and so on).

2.9.1 Simple Commands
A "simple command" is a sequence of optional variable assignments and redirections, in any sequence, optionally followed by words and redirections, terminated by a control operator.

When a given simple command is required to be executed (that is, when any conditional construct such as an AND-OR list or a case statement has not bypassed the simple command), the following expansions, assignments, and redirections shall all be performed from the beginning of the command text to the end:

The words that are recognized as variable assignments or redirections according to Shell Grammar Rules are saved for processing in steps 3 and 4.

The words that are not variable assignments or redirections shall be expanded. If any fields remain following their expansion, the first field shall be considered the command name and remaining fields are the arguments for the command.

Redirections shall be performed as described in Redirection.

Each variable assignment shall be expanded for tilde expansion, parameter expansion, command substitution, arithmetic expansion, and quote removal prior to assigning the value.

In the preceding list, the order of steps 3 and 4 may be reversed if no command name results from step 2 or if the command name matches the name of a special built-in utility; see Special Built-In Utilities.

Variable assignments shall be performed as follows:

If no command name results, variable assignments shall affect the current execution environment.

If the command name is not a special built-in utility or function, the variable assignments shall be exported for the execution environment of the command and shall not affect the current execution environment except as a side-effect of the expansions performed in step 4. In this case it is unspecified:

Whether or not the assignments are visible for subsequent expansions in step 4

Whether variable assignments made as side-effects of these expansions are visible for subsequent expansions in step 4, or in the current shell execution environment, or both

If the command name is a standard utility implemented as a function (see XBD Utility), the effect of variable assignments shall be as if the utility was not implemented as a function.

If the command name is a special built-in utility, variable assignments shall affect the current execution environment. Unless the set -a option is on (see set), it is unspecified:

Whether or not the variables gain the export attribute during the execution of the special built-in utility

Whether or not export attributes gained as a result of the variable assignments persist after the completion of the special built-in utility

If the command name is a function that is not a standard utility implemented as a function, variable assignments shall affect the current execution environment during the execution of the function. It is unspecified:

Whether or not the variable assignments persist after the completion of the function

Whether or not the variables gain the export attribute during the execution of the function

Whether or not export attributes gained as a result of the variable assignments persist after the completion of the function (if variable assignments persist after the completion of the function)

If any of the variable assignments attempt to assign a value to a variable for which the readonly attribute is set in the current shell environment (regardless of whether the assignment is made in that environment), a variable assignment error shall occur. See Consequences of Shell Errors for the consequences of these errors.

If there is no command name, any redirections shall be performed in a subshell environment; it is unspecified whether this subshell environment is the same one as that used for a command substitution within the command. (To affect the current execution environment, see the exec special built-in.) If any of the redirections performed in the current shell execution environment fail, the command shall immediately fail with an exit status greater than zero, and the shell shall write an error message indicating the failure. See Consequences of Shell Errors for the consequences of these failures on interactive and non-interactive shells.

If there is a command name, execution shall continue as described in Command Search and Execution . If there is no command name, but the command contained a command substitution, the command shall complete with the exit status of the last command substitution performed. Otherwise, the command shall complete with a zero exit status.

Command Search and Execution
If a simple command results in a command name and an optional list of arguments, the following actions shall be performed:

If the command name does not contain any <slash> characters, the first successful step in the following sequence shall occur:

If the command name matches the name of a special built-in utility, that special built-in utility shall be invoked.

If the command name matches the name of a utility listed in the following table, the results are unspecified.


alloc
autoload
bind
bindkey
builtin
bye
caller
cap
chdir
clone
 


comparguments
compcall
compctl
compdescribe
compfiles
compgen
compgroups
complete
compquote
comptags
 


comptry
compvalues
declare
dirs
disable
disown
dosh
echotc
echoti
help
 


history
hist
let
local
login
logout
map
mapfile
popd
print
 


pushd
readarray
repeat
savehistory
source
shopt
stop
suspend
typeset
whence
 

If the command name matches the name of a function known to this shell, the function shall be invoked as described in Function Definition Command. If the implementation has provided a standard utility in the form of a function, it shall not be recognized at this point. It shall be invoked in conjunction with the path search in step 1e.

If the command name matches the name [XSI] [Option Start]  of the type or ulimit utility, or [Option End]  of a utility listed in the following table, that utility shall be invoked.


alias
bg
cd
command
 


false
fc
fg
getopts
 


hash
jobs
kill
newgrp
 


pwd
read
true
umask
 


unalias
wait
 

Otherwise, the command shall be searched for using the PATH environment variable as described in XBD Environment Variables :

If the search is successful:

If the system has implemented the utility as a regular built-in or as a shell function, it shall be invoked at this point in the path search.

Otherwise, the shell executes the utility in a separate utility environment (see Shell Execution Environment) with actions equivalent to calling the execl() function as defined in the System Interfaces volume of POSIX.1-2008 with the path argument set to the pathname resulting from the search, arg0 set to the command name, and the remaining execl() arguments set to the command arguments (if any) and the null terminator.

If the execl() function fails due to an error equivalent to the [ENOEXEC] error defined in the System Interfaces volume of POSIX.1-2008, the shell shall execute a command equivalent to having a shell invoked with the pathname resulting from the search as its first operand, with any remaining arguments passed to the new shell, except that the value of "$0" in the new shell may be set to the command name. If the executable file is not a text file, the shell may bypass this command execution. In this case, it shall write an error message, and shall return an exit status of 126.

It is unspecified whether environment variables that were passed to the shell when it was invoked, but were not used to initialize shell variables (see Shell Variables) because they had invalid names, are included in the environment passed to execl() and (if execl() fails as described above) to the new shell.

Once a utility has been searched for and found (either as a result of this specific search or as part of an unspecified shell start-up activity), an implementation may remember its location and need not search for the utility again unless the PATH variable has been the subject of an assignment. If the remembered location fails for a subsequent invocation, the shell shall repeat the search to find the new location for the utility, if any.

If the search is unsuccessful, the command shall fail with an exit status of 127 and the shell shall write an error message.

If the command name contains at least one <slash>, the shell shall execute the utility in a separate utility environment with actions equivalent to calling the execl() function defined in the System Interfaces volume of POSIX.1-2008 with the path and arg0 arguments set to the command name, and the remaining execl() arguments set to the command arguments (if any) and the null terminator.

If the execl() function fails due to an error equivalent to the [ENOEXEC] error, the shell shall execute a command equivalent to having a shell invoked with the command name as its first operand, with any remaining arguments passed to the new shell. If the executable file is not a text file, the shell may bypass this command execution. In this case, it shall write an error message and shall return an exit status of 126.

It is unspecified whether environment variables that were passed to the shell when it was invoked, but were not used to initialize shell variables (see Shell Variables) because they had invalid names, are included in the environment passed to execl() and (if execl() fails as described above) to the new shell.

If the utility would be executed with file descriptor 0, 1, or 2 closed, implementations may execute the utility with the file descriptor open to an unspecified file. If a standard utility or a conforming application is executed with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for writing, the environment in which the utility or application is executed shall be deemed non-conforming, and consequently the utility or application might not behave as described in this standard.

2.9.2 Pipelines
A pipeline is a sequence of one or more commands separated by the control operator '|'. For each command but the last, the shell shall connect the standard output of the command to the standard input of the next command as if by creating a pipe and passing the write end of the pipe as the standard output of the command and the read end of the pipe as the standard input of the next command.

The format for a pipeline is:

[!] command1 [ | command2 ...]
If the pipeline begins with the reserved word ! and command1 is a subshell command, the application shall ensure that the ( operator at the beginning of command1 is separated from the ! by one or more <blank> characters. The behavior of the reserved word ! immediately followed by the ( operator is unspecified.

The standard output of command1 shall be connected to the standard input of command2. The standard input, standard output, or both of a command shall be considered to be assigned by the pipeline before any redirection specified by redirection operators that are part of the command (see Redirection).

If the pipeline is not in the background (see Asynchronous Lists), the shell shall wait for the last command specified in the pipeline to complete, and may also wait for all commands to complete.

Exit Status
If the pipeline does not begin with the ! reserved word, the exit status shall be the exit status of the last command specified in the pipeline. Otherwise, the exit status shall be the logical NOT of the exit status of the last command. That is, if the last command returns zero, the exit status shall be 1; if the last command returns greater than zero, the exit status shall be zero.

2.9.3 Lists
An AND-OR list is a sequence of one or more pipelines separated by the operators "&&" and "||" .

A list is a sequence of one or more AND-OR lists separated by the operators ';' and '&'.

The operators "&&" and "||" shall have equal precedence and shall be evaluated with left associativity. For example, both of the following commands write solely bar to standard output:

false && echo foo || echo bar
true || echo foo && echo bar

A ';' separator or a ';' or <newline> terminator shall cause the preceding AND-OR list to be executed sequentially; an '&' separator or terminator shall cause asynchronous execution of the preceding AND-OR list.

The term "compound-list" is derived from the grammar in Shell Grammar; it is equivalent to a sequence of lists, separated by <newline> characters, that can be preceded or followed by an arbitrary number of <newline> characters.

The following sections are informative.
Examples
The following is an example that illustrates <newline> characters in compound-lists:

while
    # a couple of <newline>s


    # a list
    date && who || ls; cat file
    # a couple of <newline>s


    # another list
    wc file > output & true


do
    # 2 lists
    ls
    cat file
done

End of informative text.
Asynchronous Lists
If a command is terminated by the control operator <ampersand> ( '&' ), the shell shall execute the command asynchronously in a subshell. This means that the shell shall not wait for the command to finish before executing the next command.

The format for running a command in the background is:

command1 & [command2 & ... ]
If job control is disabled (see set, -m), the standard input for an asynchronous list, before any explicit redirections are performed, shall be considered to be assigned to a file that has the same properties as /dev/null. This shall not happen if job control is enabled. In all cases, explicit redirection of standard input shall override this activity.

When an element of an asynchronous list (the portion of the list ended by an <ampersand>, such as command1, above) is started by the shell, the process ID of the last command in the asynchronous list element shall become known in the current shell execution environment; see Shell Execution Environment. This process ID shall remain known until:

The command terminates and the application waits for the process ID.

Another asynchronous list is invoked before "$!" (corresponding to the previous asynchronous list) is expanded in the current execution environment.

The implementation need not retain more than the {CHILD_MAX} most recent entries in its list of known process IDs in the current shell execution environment.

Exit Status
The exit status of an asynchronous list shall be zero.

Sequential Lists
Commands that are separated by a <semicolon> ( ';' ) shall be executed sequentially.

The format for executing commands sequentially shall be:

command1 [; command2] ...

Each command shall be expanded and executed in the order specified.

Exit Status
The exit status of a sequential list shall be the exit status of the last command in the list.

AND Lists
The control operator "&&" denotes an AND list. The format shall be:

command1 [ && command2] ...

First command1 shall be executed. If its exit status is zero, command2 shall be executed, and so on, until a command has a non-zero exit status or there are no more commands left to execute. The commands are expanded only if they are executed.

Exit Status
The exit status of an AND list shall be the exit status of the last command that is executed in the list.

OR Lists
The control operator "||" denotes an OR List. The format shall be:

command1 [ || command2] ...

First, command1 shall be executed. If its exit status is non-zero, command2 shall be executed, and so on, until a command has a zero exit status or there are no more commands left to execute.

Exit Status
The exit status of an OR list shall be the exit status of the last command that is executed in the list.

2.9.4 Compound Commands
The shell has several programming constructs that are "compound commands", which provide control flow for commands. Each of these compound commands has a reserved word or control operator at the beginning, and a corresponding terminator reserved word or operator at the end. In addition, each can be followed by redirections on the same line as the terminator. Each redirection shall apply to all the commands within the compound command that do not explicitly override that redirection.

Grouping Commands
The format for grouping commands is as follows:

( compound-list )
Execute compound-list in a subshell environment; see Shell Execution Environment. Variable assignments and built-in commands that affect the environment shall not remain in effect after the list finishes.
If a character sequence beginning with "((" would be parsed by the shell as an arithmetic expansion if preceded by a '$', shells which implement an extension whereby "((expression))" is evaluated as an arithmetic expression may treat the "((" as introducing as an arithmetic evaluation instead of a grouping command. A conforming application shall ensure that it separates the two leading '(' characters with white space to prevent the shell from performing an arithmetic evaluation.

{ compound-list ; }
Execute compound-list in the current process environment. The semicolon shown here is an example of a control operator delimiting the } reserved word. Other delimiters are possible, as shown in Shell Grammar; a <newline> is frequently used.
Exit Status
The exit status of a grouping command shall be the exit status of compound-list.

The for Loop
The for loop shall execute a sequence of commands for each member in a list of items. The for loop requires that the reserved words do and done be used to delimit the sequence of commands.

The format for the for loop is as follows:

for name [ in [word ... ]]
do
    compound-list
done

First, the list of words following in shall be expanded to generate a list of items. Then, the variable name shall be set to each item, in turn, and the compound-list executed each time. If no items result from the expansion, the compound-list shall not be executed. Omitting:

in word...
shall be equivalent to:

in "$@"

Exit Status
The exit status of a for command shall be the exit status of the last command that executes. If there are no items, the exit status shall be zero.

Case Conditional Construct
The conditional construct case shall execute the compound-list corresponding to the first one of several patterns (see Pattern Matching Notation) that is matched by the string resulting from the tilde expansion, parameter expansion, command substitution, arithmetic expansion, and quote removal of the given word. The reserved word in shall denote the beginning of the patterns to be matched. Multiple patterns with the same compound-list shall be delimited by the '|' symbol. The control operator ')' terminates a list of patterns corresponding to a given action. The compound-list for each list of patterns, with the possible exception of the last, shall be terminated with ";;". The case construct terminates with the reserved word esac (case reversed).
The format for the case construct is as follows:

case word in
    [(] pattern1 ) compound-list ;;
    [[(] pattern[ | pattern] ... ) compound-list ;;] ...
    [[(] pattern[ | pattern] ... ) compound-list]
esac

The ";;" is optional for the last compound-list.

In order from the beginning to the end of the case statement, each pattern that labels a compound-list shall be subjected to tilde expansion, parameter expansion, command substitution, and arithmetic expansion, and the result of these expansions shall be compared against the expansion of word, according to the rules described in Pattern Matching Notation (which also describes the effect of quoting parts of the pattern). After the first match, no more patterns shall be expanded, and the compound-list shall be executed. The order of expansion and comparison of multiple patterns that label a compound-list statement is unspecified.

Exit Status
The exit status of case shall be zero if no patterns are matched. Otherwise, the exit status shall be the exit status of the last command executed in the compound-list.

The if Conditional Construct
The if command shall execute a compound-list and use its exit status to determine whether to execute another compound-list.

The format for the if construct is as follows:

if compound-list
then
    compound-list
[elif compound-list
then
    compound-list] ...
[else
    compound-list]
fi

The if compound-list shall be executed; if its exit status is zero, the then compound-list shall be executed and the command shall complete. Otherwise, each elif compound-list shall be executed, in turn, and if its exit status is zero, the then compound-list shall be executed and the command shall complete. Otherwise, the else compound-list shall be executed.

Exit Status
The exit status of the if command shall be the exit status of the then or else compound-list that was executed, or zero, if none was executed.

The while Loop
The while loop shall continuously execute one compound-list as long as another compound-list has a zero exit status.

The format of the while loop is as follows:

while compound-list-1
do
    compound-list-2
done

The compound-list-1 shall be executed, and if it has a non-zero exit status, the while command shall complete. Otherwise, the compound-list-2 shall be executed, and the process shall repeat.

Exit Status
The exit status of the while loop shall be the exit status of the last compound-list-2 executed, or zero if none was executed.

The until Loop
The until loop shall continuously execute one compound-list as long as another compound-list has a non-zero exit status.

The format of the until loop is as follows:

until compound-list-1
do
    compound-list-2
done

The compound-list-1 shall be executed, and if it has a zero exit status, the until command completes. Otherwise, the compound-list-2 shall be executed, and the process repeats.

Exit Status
The exit status of the until loop shall be the exit status of the last compound-list-2 executed, or zero if none was executed.

2.9.5 Function Definition Command
A function is a user-defined name that is used as a simple command to call a compound command with new positional parameters. A function is defined with a "function definition command".

The format of a function definition command is as follows:

fname ( ) compound-command [io-redirect ...]
The function is named fname; the application shall ensure that it is a name (see XBD Name) and that it is not the name of a special built-in utility. An implementation may allow other characters in a function name as an extension. The implementation shall maintain separate name spaces for functions and variables.

The argument compound-command represents a compound command, as described in Compound Commands.

When the function is declared, none of the expansions in wordexp shall be performed on the text in compound-command or io-redirect; all expansions shall be performed as normal each time the function is called. Similarly, the optional io-redirect redirections and any variable assignments within compound-command shall be performed during the execution of the function itself, not the function definition. See Consequences of Shell Errors for the consequences of failures of these operations on interactive and non-interactive shells.

When a function is executed, it shall have the syntax-error properties described for special built-in utilities in the first item in the enumerated list at the beginning of Special Built-In Utilities.

The compound-command shall be executed whenever the function name is specified as the name of a simple command (see Command Search and Execution). The operands to the command temporarily shall become the positional parameters during the execution of the compound-command; the special parameter '#' also shall be changed to reflect the number of operands. The special parameter 0 shall be unchanged. When the function completes, the values of the positional parameters and the special parameter '#' shall be restored to the values they had before the function was executed. If the special built-in return (see return) is executed in the compound-command, the function completes and execution shall resume with the next command after the function call.

Exit Status
The exit status of a function definition shall be zero if the function was declared successfully; otherwise, it shall be greater than zero. The exit status of a function invocation shall be the exit status of the last command executed by the function.

2.10. Shell Grammar
The following grammar defines the Shell Command Language. This formal syntax shall take precedence over the preceding text syntax description.

2.10.1 Shell Grammar Lexical Conventions
The input language to the shell must be first recognized at the character level. The resulting tokens shall be classified by their immediate context according to the following rules (applied in order). These rules shall be used to determine what a "token" is that is subject to parsing at the token level. The rules for token recognition in Token Recognition shall apply.

If the token is an operator, the token identifier for that operator shall result.

If the string consists solely of digits and the delimiter character is one of '<' or '>', the token identifier IO_NUMBER shall be returned.

Otherwise, the token identifier TOKEN results.

Further distinction on TOKEN is context-dependent. It may be that the same TOKEN yields WORD, a NAME, an ASSIGNMENT_WORD, or one of the reserved words below, dependent upon the context. Some of the productions in the grammar below are annotated with a rule number from the following list. When a TOKEN is seen where one of those annotated productions could be used to reduce the symbol, the applicable rule shall be applied to convert the token identifier type of the TOKEN to a token identifier acceptable at that point in the grammar. The reduction shall then proceed based upon the token identifier type yielded by the rule applied. When more than one rule applies, the highest numbered rule shall apply (which in turn may refer to another rule). (Note that except in rule 7, the presence of an '=' in the token has no effect.)

The WORD tokens shall have the word expansion rules applied to them immediately before the associated command is executed, not at the time the command is parsed.

2.10.2 Shell Grammar Rules
[Command Name]

When the TOKEN is exactly a reserved word, the token identifier for that reserved word shall result. Otherwise, the token WORD shall be returned. Also, if the parser is in any state where only a reserved word could be the next correct token, proceed as above.

Note:
Because at this point <quotation-mark> characters are retained in the token, quoted strings cannot be recognized as reserved words. This rule also implies that reserved words are not recognized except in certain positions in the input, such as after a <newline> or <semicolon>; the grammar presumes that if the reserved word is intended, it is properly delimited by the user, and does not attempt to reflect that requirement directly. Also note that line joining is done before tokenization, as described in Escape Character (Backslash), so escaped <newline> characters are already removed at this point.
Rule 1 is not directly referenced in the grammar, but is referred to by other rules, or applies globally.

[Redirection to or from filename]

The expansions specified in Redirection shall occur. As specified there, exactly one field can result (or the result is unspecified), and there are additional requirements on pathname expansion.

[Redirection from here-document]

Quote removal shall be applied to the word to determine the delimiter that is used to find the end of the here-document that begins after the next <newline>.

[Case statement termination]

When the TOKEN is exactly the reserved word esac, the token identifier for esac shall result. Otherwise, the token WORD shall be returned.

[ NAME in for]

When the TOKEN meets the requirements for a name (see XBD Name ), the token identifier NAME shall result. Otherwise, the token WORD shall be returned.

[Third word of for and case]

[ case only]

When the TOKEN is exactly the reserved word in, the token identifier for in shall result. Otherwise, the token WORD shall be returned.

[ for only]

When the TOKEN is exactly the reserved word in or do, the token identifier for in or do shall result, respectively. Otherwise, the token WORD shall be returned.

(For a. and b.: As indicated in the grammar, a linebreak precedes the tokens in and do. If <newline> characters are present at the indicated location, it is the token after them that is treated in this fashion.)

[Assignment preceding command name]

[When the first word]

If the TOKEN does not contain the character '=', rule 1 is applied. Otherwise, 7b shall be applied.

[Not the first word]

If the TOKEN contains an unquoted (as determined while applying rule 4 from Token Recognition) <equals-sign> character that is not part of an embedded parameter expansion, command substitution, or arithmetic expansion construct (as determined while applying rule 5 from Token Recognition):

If the TOKEN begins with '=', then rule 1 shall be applied.

If all the characters in the TOKEN preceding the first such <equals-sign> form a valid name (see XBD Name), the token ASSIGNMENT_WORD shall be returned.

Otherwise, it is unspecified whether rule 1 is applied or ASSIGNMENT_WORD is returned.

Otherwise, rule 1 shall be applied.

Assignment to the name within a returned ASSIGNMENT_WORD token shall occur as specified in Simple Commands.

[ NAME in function]

When the TOKEN is exactly a reserved word, the token identifier for that reserved word shall result. Otherwise, when the TOKEN meets the requirements for a name, the token identifier NAME shall result. Otherwise, rule 7 applies.

[Body of function]

Word expansion and assignment shall never occur, even when required by the rules above, when this rule is being parsed. Each TOKEN that might either be expanded or have assignment applied to it shall instead be returned as a single WORD consisting only of characters that are exactly the token described in Token Recognition.


/* -------------------------------------------------------
   The grammar symbols
   ------------------------------------------------------- */
%token  WORD
%token  ASSIGNMENT_WORD
%token  NAME
%token  NEWLINE
%token  IO_NUMBER


/* The following are the operators (see XBD Operator)
   containing more than one character. */



%token  AND_IF    OR_IF    DSEMI
/*      '&&'      '||'     ';;'    */


%token  DLESS  DGREAT  LESSAND  GREATAND  LESSGREAT  DLESSDASH
/*      '<<'   '>>'    '<&'     '>&'      '<>'       '<<-'   */


%token  CLOBBER
/*      '>|'   */


/* The following are the reserved words. */


%token  If    Then    Else    Elif    Fi    Do    Done
/*      'if'  'then'  'else'  'elif'  'fi'  'do'  'done'   */


%token  Case    Esac    While    Until    For
/*      'case'  'esac'  'while'  'until'  'for'   */


/* These are reserved words, not operator tokens, and are
   recognized when reserved words are recognized. */


%token  Lbrace    Rbrace    Bang
/*      '{'       '}'       '!'   */


%token  In
/*      'in'   */


/* -------------------------------------------------------
   The Grammar
   ------------------------------------------------------- */
%start program
%%
program          : linebreak complete_commands linebreak
                 | linebreak
                 ;
complete_commands: complete_commands newline_list complete_command
                 |                                complete_command
                 ;
complete_command : list separator_op
                 | list
                 ;
list             : list separator_op and_or
                 |                   and_or
                 ;
and_or           :                         pipeline
                 | and_or AND_IF linebreak pipeline
                 | and_or OR_IF  linebreak pipeline
                 ;
pipeline         :      pipe_sequence
                 | Bang pipe_sequence
                 ;
pipe_sequence    :                             command
                 | pipe_sequence '|' linebreak command
                 ;
command          : simple_command
                 | compound_command
                 | compound_command redirect_list
                 | function_definition
                 ;
compound_command : brace_group
                 | subshell
                 | for_clause
                 | case_clause
                 | if_clause
                 | while_clause
                 | until_clause
                 ;
subshell         : '(' compound_list ')'
                 ;
compound_list    : linebreak term
                 | linebreak term separator
                 ;
term             : term separator and_or
                 |                and_or
                 ;
for_clause       : For name                                      do_group
                 | For name                       sequential_sep do_group
                 | For name linebreak in          sequential_sep do_group
                 | For name linebreak in wordlist sequential_sep do_group
                 ;
name             : NAME                     /* Apply rule 5 */
                 ;
in               : In                       /* Apply rule 6 */
                 ;
wordlist         : wordlist WORD
                 |          WORD
                 ;
case_clause      : Case WORD linebreak in linebreak case_list    Esac
                 | Case WORD linebreak in linebreak case_list_ns Esac
                 | Case WORD linebreak in linebreak              Esac
                 ;
case_list_ns     : case_list case_item_ns
                 |           case_item_ns
                 ;
case_list        : case_list case_item
                 |           case_item
                 ;
case_item_ns     :     pattern ')' linebreak
                 |     pattern ')' compound_list
                 | '(' pattern ')' linebreak
                 | '(' pattern ')' compound_list
                 ;
case_item        :     pattern ')' linebreak     DSEMI linebreak
                 |     pattern ')' compound_list DSEMI linebreak
                 | '(' pattern ')' linebreak     DSEMI linebreak
                 | '(' pattern ')' compound_list DSEMI linebreak
                 ;
pattern          :             WORD         /* Apply rule 4 */
                 | pattern '|' WORD         /* Do not apply rule 4 */
                 ;
if_clause        : If compound_list Then compound_list else_part Fi
                 | If compound_list Then compound_list           Fi
                 ;
else_part        : Elif compound_list Then compound_list
                 | Elif compound_list Then compound_list else_part
                 | Else compound_list
                 ;
while_clause     : While compound_list do_group
                 ;
until_clause     : Until compound_list do_group
                 ;
function_definition : fname '(' ')' linebreak function_body
                 ;
function_body    : compound_command                /* Apply rule 9 */
                 | compound_command redirect_list  /* Apply rule 9 */
                 ;
fname            : NAME                            /* Apply rule 8 */
                 ;
brace_group      : Lbrace compound_list Rbrace
                 ;
do_group         : Do compound_list Done           /* Apply rule 6 */
                 ;
simple_command   : cmd_prefix cmd_word cmd_suffix
                 | cmd_prefix cmd_word
                 | cmd_prefix
                 | cmd_name cmd_suffix
                 | cmd_name
                 ;
cmd_name         : WORD                   /* Apply rule 7a */
                 ;
cmd_word         : WORD                   /* Apply rule 7b */
                 ;
cmd_prefix       :            io_redirect
                 | cmd_prefix io_redirect
                 |            ASSIGNMENT_WORD
                 | cmd_prefix ASSIGNMENT_WORD
                 ;
cmd_suffix       :            io_redirect
                 | cmd_suffix io_redirect
                 |            WORD
                 | cmd_suffix WORD
                 ;
redirect_list    :               io_redirect
                 | redirect_list io_redirect
                 ;
io_redirect      :           io_file
                 | IO_NUMBER io_file
                 |           io_here
                 | IO_NUMBER io_here
                 ;
io_file          : '<'       filename
                 | LESSAND   filename
                 | '>'       filename
                 | GREATAND  filename
                 | DGREAT    filename
                 | LESSGREAT filename
                 | CLOBBER   filename
                 ;
filename         : WORD                      /* Apply rule 2 */
                 ;
io_here          : DLESS     here_end
                 | DLESSDASH here_end
                 ;
here_end         : WORD                      /* Apply rule 3 */
                 ;
newline_list     :              NEWLINE
                 | newline_list NEWLINE
                 ;
linebreak        : newline_list
                 | /* empty */
                 ;
separator_op     : '&'
                 | ';'
                 ;
separator        : separator_op linebreak
                 | newline_list
                 ;
sequential_sep   : ';' linebreak
                 | newline_list
                 ;

2.11. Signals and Error Handling
If job control is disabled (see the description of set -m) when the shell executes an asynchronous list, the commands in the list shall inherit from the shell a signal action of ignored (SIG_IGN) for the SIGINT and SIGQUIT signals. In all other cases, commands executed by the shell shall inherit the same signal actions as those inherited by the shell from its parent unless a signal action is modified by the trap special built-in (see trap)

When a signal for which a trap has been set is received while the shell is waiting for the completion of a utility executing a foreground command, the trap associated with that signal shall not be executed until after the foreground command has completed. When the shell is waiting, by means of the wait utility, for asynchronous commands to complete, the reception of a signal for which a trap has been set shall cause the wait utility to return immediately with an exit status >128, immediately after which the trap associated with that signal shall be taken.

If multiple signals are pending for the shell for which there are associated trap actions, the order of execution of trap actions is unspecified.

2.12. Shell Execution Environment
A shell execution environment consists of the following:

Open files inherited upon invocation of the shell, plus open files controlled by exec

Working directory as set by cd

File creation mask set by umask

[XSI] [Option Start] File size limit as set by ulimit [Option End]

Current traps set by trap

Shell parameters that are set by variable assignment (see the set special built-in) or from the System Interfaces volume of POSIX.1-2008 environment inherited by the shell when it begins (see the export special built-in)

Shell functions; see Function Definition Command

Options turned on at invocation or by set

Process IDs of the last commands in asynchronous lists known to this shell environment; see Asynchronous Lists

Shell aliases; see Alias Substitution

Utilities other than the special built-ins (see Special Built-In Utilities) shall be invoked in a separate environment that consists of the following. The initial value of these objects shall be the same as that for the parent shell, except as noted below.

Open files inherited on invocation of the shell, open files controlled by the exec special built-in plus any modifications, and additions specified by any redirections to the utility

Current working directory

File creation mask

If the utility is a shell script, traps caught by the shell shall be set to the default values and traps ignored by the shell shall be set to be ignored by the utility; if the utility is not a shell script, the trap actions (default or ignore) shall be mapped into the appropriate signal handling actions for the utility

Variables with the export attribute, along with those explicitly exported for the duration of the command, shall be passed to the utility environment variables

The environment of the shell process shall not be changed by the utility unless explicitly specified by the utility description (for example, cd and umask).

A subshell environment shall be created as a duplicate of the shell environment, except that signal traps that are not being ignored shall be set to the default action. Changes made to the subshell environment shall not affect the shell environment. Command substitution, commands that are grouped with parentheses, and asynchronous lists shall be executed in a subshell environment. Additionally, each command of a multi-command pipeline is in a subshell environment; as an extension, however, any or all commands in a pipeline may be executed in the current environment. All other commands shall be executed in the current shell environment.

2.13. Pattern Matching Notation
The pattern matching notation described in this section is used to specify patterns for matching strings in the shell. Historically, pattern matching notation is related to, but slightly different from, the regular expression notation described in XBD Regular Expressions. For this reason, the description of the rules for this pattern matching notation are based on the description of regular expression notation, modified to account for the differences.

2.13.1 Patterns Matching a Single Character
The following patterns matching a single character shall match a single character: ordinary characters, special pattern characters, and pattern bracket expressions. The pattern bracket expression also shall match a single collating element. A <backslash> character shall escape the following character. The escaping <backslash> shall be discarded. If a pattern ends with an unescaped <backslash>, it is unspecified whether the pattern does not match anything or the pattern is treated as invalid.

An ordinary character is a pattern that shall match itself. It can be any character in the supported character set except for NUL, those special shell characters in Quoting that require quoting, and the following three special pattern characters. Matching shall be based on the bit pattern used for encoding the character, not on the graphic representation of the character. If any character (ordinary, shell special, or pattern special) is quoted, that pattern shall match the character itself. The shell special characters always require quoting.

When unquoted and outside a bracket expression, the following three characters shall have special meaning in the specification of patterns:

?
A <question-mark> is a pattern that shall match any character.
*
An <asterisk> is a pattern that shall match multiple characters, as described in Patterns Matching Multiple Characters.
[
If an open bracket introduces a bracket expression as in XBD RE Bracket Expression, except that the <exclamation-mark> character ( '!' ) shall replace the <circumflex> character ( '^' ) in its role in a non-matching list in the regular expression notation, it shall introduce a pattern bracket expression. A bracket expression starting with an unquoted <circumflex> character produces unspecified results. Otherwise, '[' shall match the character itself.
When pattern matching is used where shell quote removal is not performed (such as in the argument to the find - name primary when find is being called using one of the exec functions as defined in the System Interfaces volume of POSIX.1-2008, or in the pattern argument to the fnmatch() function), special characters can be escaped to remove their special meaning by preceding them with a <backslash> character. This escaping <backslash> is discarded. The sequence "\\" represents one literal <backslash>. All of the requirements and effects of quoting on ordinary, shell special, and special pattern characters shall apply to escaping in this context.

2.13.2 Patterns Matching Multiple Characters
The following rules are used to construct patterns matching multiple characters from patterns matching a single character:

The <asterisk> ( '*' ) is a pattern that shall match any string, including the null string.

The concatenation of patterns matching a single character is a valid pattern that shall match the concatenation of the single characters or collating elements matched by each of the concatenated patterns.

The concatenation of one or more patterns matching a single character with one or more <asterisk> characters is a valid pattern. In such patterns, each <asterisk> shall match a string of zero or more characters, matching the greatest possible number of characters that still allows the remainder of the pattern to match the string.

2.13.3 Patterns Used for Filename Expansion
The rules described so far in Patterns Matching a Single Character and Patterns Matching Multiple Characters are qualified by the following rules that apply when pattern matching notation is used for filename expansion:

The <slash> character in a pathname shall be explicitly matched by using one or more <slash> characters in the pattern; it shall neither be matched by the <asterisk> or <question-mark> special characters nor by a bracket expression. <slash> characters in the pattern shall be identified before bracket expressions; thus, a <slash> cannot be included in a pattern bracket expression used for filename expansion. If a <slash> character is found following an unescaped <left-square-bracket> character before a corresponding <right-square-bracket> is found, the open bracket shall be treated as an ordinary character. For example, the pattern "a[b/c]d" does not match such pathnames as abd or a/d. It only matches a pathname of literally a[b/c]d.

If a filename begins with a <period> ( '.' ), the <period> shall be explicitly matched by using a <period> as the first character of the pattern or immediately following a <slash> character. The leading <period> shall not be matched by:

The <asterisk> or <question-mark> special characters

A bracket expression containing a non-matching list, such as "[!a]", a range expression, such as "[%-0]", or a character class expression, such as "[[:punct:]]"

It is unspecified whether an explicit <period> in a bracket expression matching list, such as "[.abc]", can match a leading <period> in a filename.

Specified patterns shall be matched against existing filenames and pathnames, as appropriate. Each component that contains a pattern character shall require read permission in the directory containing that component. Any component, except the last, that does not contain a pattern character shall require search permission. For example, given the pattern:

/foo/bar/x*/bam

search permission is needed for directories / and foo, search and read permissions are needed for directory bar, and search permission is needed for each x* directory. If the pattern matches any existing filenames or pathnames, the pattern shall be replaced with those filenames and pathnames, sorted according to the collating sequence in effect in the current locale. If this collating sequence does not have a total ordering of all characters (see XBD LC_COLLATE), any filenames or pathnames that collate equally should be further compared byte-by-byte using the collating sequence for the POSIX locale.

Note:
A future version of this standard may require the byte-by-byte further comparison described above.
If the pattern contains an open bracket ( '[' ) that does not introduce a bracket expression as in XBD RE Bracket Expression, it is unspecified whether other unquoted pattern matching characters within the same slash-delimited component of the pattern retain their special meanings or are treated as ordinary characters. For example, the pattern "a*[/b*" may match all filenames beginning with 'b' in the directory "a*[" or it may match all filenames beginning with 'b' in all directories with names beginning with 'a' and ending with '['.

If the pattern does not match any existing filenames or pathnames, the pattern string shall be left unchanged.

2.14. Special Built-In Utilities
The following "special built-in" utilities shall be supported in the shell command language. The output of each command, if any, shall be written to standard output, subject to the normal redirection and piping possible with all commands.

The term "built-in" implies that the shell can execute the utility directly and does not need to search for it. An implementation may choose to make any utility a built-in; however, the special built-in utilities described here differ from regular built-in utilities in two respects:

An error in a special built-in utility may cause a shell executing that utility to abort, while an error in a regular built-in utility shall not cause a shell executing that utility to abort. (See Consequences of Shell Errors for the consequences of errors on interactive and non-interactive shells.) If a special built-in utility encountering an error does not abort the shell, its exit value shall be non-zero.

As described in Simple Commands, variable assignments preceding the invocation of a special built-in utility remain in effect after the built-in completes; this shall not be the case with a regular built-in or other utility.

The special built-in utilities in this section need not be provided in a manner accessible via the exec family of functions defined in the System Interfaces volume of POSIX.1-2008.

Some of the special built-ins are described as conforming to XBD Utility Syntax Guidelines. For those that are not, the requirement in Utility Description Defaults that "--" be recognized as a first argument to be discarded does not apply and a conforming application shall not use that argument.

<<< Previous	Home	Next >>>
 

return to top of page
UNIX  is a registered Trademark of The Open Group.
POSIX  is a registered Trademark of The IEEE.
Copyright  2001-2016 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT ]
NAME
break - exit from for, while, or until loop
SYNOPSIS
break [n]

DESCRIPTION
If n is specified, the break utility shall exit from the nth enclosing for, while, or until loop. If n is not specified, break shall behave as if n was specified as 1. Execution shall continue with the command immediately following the exited loop. The value of n is a positive decimal integer. If n is greater than the number of enclosing loops, the outermost enclosing loop shall be exited. If there is no enclosing loop, the behavior is unspecified.

A loop shall enclose a break or continue command if the loop lexically encloses the command. A loop lexically encloses a break or continue command if the command is:

Executing in the same execution environment (see Shell Execution Environment) as the compound-list of the loop's do-group (see Shell Grammar Rules), and

Contained in a compound-list associated with the loop (either in the compound-list of the loop's do-group or, if the loop is a while or until loop, in the compound-list following the while or until reserved word), and

Not in the body of a function whose function definition command (see Function Definition Command) is contained in a compound-list associated with the loop.

If n is greater than the number of lexically enclosing loops and there is a non-lexically enclosing loop in progress in the same execution environment as the break or continue command, it is unspecified whether that loop encloses the command.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
Successful completion.
>0
The n value was not an unsigned decimal integer greater than or equal to 1.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
for i in *
do
    if test -d "$i"
    then break
    fi
done

The results of running the following example are unspecified: there are two loops in progress when the break command is executed, and they are in the same execution environment, but neither loop is lexically enclosing the break command. (There are no loops lexically enclosing the continue commands, either.)

foo() {
    for j in 1 2; do
        echo 'break 2' >/tmp/do_break
        echo "  sourcing /tmp/do_break ($j)..."
        # the behavior of the break from running the following command
        # results in unspecified behavior:
        . /tmp/do_break


        do_continue() { continue 2; }
        echo "  running do_continue ($j)..."
        # the behavior of the continue in the following function call
        # results in unspecified behavior (if execution reaches this
        # point):
        do_continue


        trap 'continue 2' USR1
        echo "  sending SIGUSR1 to self ($j)..."
        # the behavior of the continue in the trap invoked from the
        # following signal results in unspecified behavior (if
        # execution reaches this point):
        kill -s USR1 $$
        sleep 1
    done
}
for i in 1 2; do
    echo "running foo ($i)..."
    foo
done

RATIONALE
In early proposals, consideration was given to expanding the syntax of break and continue to refer to a label associated with the appropriate loop as a preferable alternative to the n method. However, this volume of POSIX.1-2008 does reserve the name space of command names ending with a <colon>. It is anticipated that a future implementation could take advantage of this and provide something like:

outofloop: for i in a b c d e
do
    for j in 0 1 2 3 4 5 6 7 8 9
    do
        if test -r "${i}${j}"
        then break outofloop
        fi
    done
done

and that this might be standardized after implementation experience is achieved.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0046 [842] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
colon - null utility
SYNOPSIS
: [argument...]

DESCRIPTION
This utility shall only expand command arguments. It is used when a command is needed, as in the then condition of an if command, but nothing is to be done by the command.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
Zero.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
: ${X=abc}
if     false
then   :
else   echo $X
fi
abc

As with any of the special built-ins, the null utility can also have variable assignments and redirections associated with it, such as:

x=y : > z

which sets variable x to the value y (so that it persists after the null utility completes) and creates or truncates file z.

RATIONALE
None.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

End of informative text.
<<< Previous	Home	Next >>>
NAME
continue - continue for, while, or until loop
SYNOPSIS
continue [n]

DESCRIPTION
If n is specified, the continue utility shall return to the top of the nth enclosing for, while, or until loop. If n is not specified, continue shall behave as if n was specified as 1. Returning to the top of the loop involves repeating the condition list of a while or until loop or performing the next assignment of a for loop, and re-executing the loop if appropriate.

The value of n is a positive decimal integer. If n is greater than the number of enclosing loops, the outermost enclosing loop shall be used. If there is no enclosing loop, the behavior is unspecified.

The meaning of "enclosing" shall be as specified in the description of the break utility.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
Successful completion.
>0
The n value was not an unsigned decimal integer greater than or equal to 1.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
for i in *
do
    if test -d "$i"
    then continue
    fi
    printf '"%s" is not a directory.\n' "$i"
done

RATIONALE
None.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
The example is changed to use the printf utility rather than echo.

POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0046 [842] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
dot - execute commands in the current environment
SYNOPSIS
. file

DESCRIPTION
The shell shall execute commands from the file in the current environment.

If file does not contain a <slash>, the shell shall use the search path specified by PATH to find the directory containing file. Unlike normal command search, however, the file searched for by the dot utility need not be executable. If no readable file is found, a non-interactive shell shall abort; an interactive shell shall write a diagnostic message to standard error, but this condition shall not be considered a syntax error.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
See the DESCRIPTION.

ENVIRONMENT VARIABLES
See the DESCRIPTION.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
If no readable file was found or if the commands in the file could not be parsed, and the shell is interactive (and therefore does not abort; see Consequences of Shell Errors), the exit status shall be non-zero. Otherwise, return the value of the last command executed, or a zero exit status if no command is executed.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
cat foobar
foo=hello bar=world
. ./foobar
echo $foo $bar
hello world

RATIONALE
Some older implementations searched the current directory for the file, even if the value of PATH disallowed it. This behavior was omitted from this volume of POSIX.1-2008 due to concerns about introducing the susceptibility to trojan horses that the user might be trying to avoid by leaving dot out of PATH.

The KornShell version of dot takes optional arguments that are set to the positional parameters. This is a valid extension that allows a dot script to behave identically to a function.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities, return

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-164 is applied.

POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0038 [114] and XCU/TC1-2008/0039 [214] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
eval - construct command by concatenating arguments
SYNOPSIS
eval [argument...]

DESCRIPTION
The eval utility shall construct a command by concatenating arguments together, separating each with a <space> character. The constructed command shall be read and executed by the shell.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
If there are no arguments, or only null arguments, eval shall return a zero exit status; otherwise, it shall return the exit status of the command defined by the string of concatenated arguments separated by <space> characters, or a non-zero exit status if the concatenation could not be parsed as a command and the shell is interactive (and therefore did not abort).

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
Since eval is not required to recognize the "--" end of options delimiter, in cases where the argument(s) to eval might begin with '-' it is recommended that the first argument is prefixed by a string that will not alter the commands to be executed, such as a <space> character:

eval " $commands"

or:

eval " $(some_command)"

EXAMPLES
foo=10 x=foo
y='$'$x
echo $y
$foo
eval y='$'$x
echo $y
10

RATIONALE
This standard allows, but does not require, eval to recognize "--". Although this means applications cannot use "--" to protect against options supported as an extension (or errors reported for unsupported options), the nature of the eval utility is such that other means can be used to provide this protection (see APPLICATION USAGE above).

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0040 [114], XCU/TC1-2008/0041 [163], and XCU/TC1-2008/0042 [163] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
exec - execute commands and open, close, or copy file descriptors
SYNOPSIS
exec [command [argument...]]

DESCRIPTION
The exec utility shall open, close, and/or copy file descriptors as specified by any redirections as part of the command.

If exec is specified without command or arguments, and any file descriptors with numbers greater than 2 are opened with associated redirection statements, it is unspecified whether those file descriptors remain open when the shell invokes another utility. Scripts concerned that child shells could misuse open file descriptors can always close them explicitly, as shown in one of the following examples.

If exec is specified with command, it shall replace the shell with command without creating a new process. If arguments are specified, they shall be arguments to command. Redirection affects the current shell execution environment.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
If command is specified, exec shall not return to the shell; rather, the exit status of the process shall be the exit status of the program implementing command, which overlaid the shell. If command is not found, the exit status shall be 127. If command is found, but it is not an executable utility, the exit status shall be 126. If a redirection error occurs (see Consequences of Shell Errors), the shell shall exit with a value in the range 1-125. Otherwise, exec shall return a zero exit status.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
Open readfile as file descriptor 3 for reading:

exec 3< readfile

Open writefile as file descriptor 4 for writing:

exec 4> writefile

Make file descriptor 5 a copy of file descriptor 0:

exec 5<&0

Close file descriptor 3:

exec 3<&-

Cat the file maggie by replacing the current shell with the cat utility:

exec cat maggie

RATIONALE
Most historical implementations were not conformant in that:

foo=bar exec cmd

did not pass foo to cmd.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

End of informative text.
<<< Previous	Home	Next >>>
NAME
exit - cause the shell to exit
SYNOPSIS
exit [n]

DESCRIPTION
The exit utility shall cause the shell to exit from its current execution environment with the exit status specified by the unsigned decimal integer n. If the current execution environment is a subshell environment, the shell shall exit from the subshell environment with the specified exit status and continue in the environment from which that subshell environment was invoked; otherwise, the shell utility shall terminate with the specified exit status. If n is specified, but its value is not between 0 and 255 inclusively, the exit status is undefined.

A trap on EXIT shall be executed before the shell terminates, except when the exit utility is invoked in that trap itself, in which case the shell shall exit immediately.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
The exit status shall be n, if specified, except that the behavior is unspecified if n is not an unsigned decimal integer or is greater than 255. Otherwise, the value shall be the exit value of the last command executed, or zero if no command was executed. When exit is executed in a trap action, the last command is considered to be the command that executed immediately preceding the trap action.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
Exit with a true value:

exit 0

Exit with a false value:

exit 1

Propagate error handling from within a subshell:

(
    command1 || exit 1
    command2 || exit 1
    exec command3
) > outputfile || exit 1
echo "outputfile created successfully"

RATIONALE
As explained in other sections, certain exit status values have been reserved for special uses and should be used by applications only for those purposes:

 126
A file to be executed was found, but it was not an executable utility.
 127
A utility to be executed was not found.
>128
A command was interrupted by a signal.
The behavior of exit when given an invalid argument or unknown option is unspecified, because of differing practices in the various historical implementations. A value larger than 255 might be truncated by the shell, and be unavailable even to a parent process that uses waitid() to get the full exit value. It is recommended that implementations that detect any usage error should cause a non-zero exit status (or, if the shell is interactive and the error does not cause the shell to abort, store a non-zero value in "$?" ), but even this was not done historically in all shells.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0047 [717], XCU/TC2-2008/0048 [960], XCU/TC2-2008/0049 [717], and XCU/TC2-2008/0050 [960] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
export - set the export attribute for variables
SYNOPSIS
export name[=word]...
 
export -p

DESCRIPTION
The shell shall give the export attribute to the variables corresponding to the specified names, which shall cause them to be in the environment of subsequently executed commands. If the name of a variable is followed by = word, then the value of that variable shall be set to word.

The export special built-in shall support XBD Utility Syntax Guidelines.

When -p is specified, export shall write to the standard output the names and values of all exported variables, in the following format:

"export %s=%s\n", <name>, <value>

if name is set, and:

"export %s\n", <name>

if name is unset.

The shell shall format the output, including the proper use of quoting, so that it is suitable for reinput to the shell as commands that achieve the same exporting results, except:

Read-only variables with values cannot be reset.

Variables that were unset at the time they were output need not be reset to the unset state if a value is assigned to the variable between the time the state was saved and the time at which the saved output is reinput to the shell.

When no arguments are given, the results are unspecified.

OPTIONS
See the DESCRIPTION.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
See the DESCRIPTION.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
All name operands were successfully exported.
>0
At least one name could not be exported, or the -p option was specified and an error occurred.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
Note that, unless X was previously marked readonly, the value of "$?" after:

export X=$(false)

will be 0 (because export successfully set X to the empty string) and that execution continues, even if set -e is in effect. In order to detect command substitution failures, a user must separate the assignment from the export, as in:

X=$(false)
export X

EXAMPLES
Export PWD and HOME variables:

export PWD HOME

Set and export the PATH variable:

export PATH=/local/bin:$PATH

Save and restore all exported variables:

export -p > temp-file
unset a lot of variables
... processing
. temp-file

RATIONALE
Some historical shells use the no-argument case as the functional equivalent of what is required here with -p. This feature was left unspecified because it is not historical practice in all shells, and some scripts may rely on the now-unspecified results on their implementations. Attempts to specify the -p output as the default case were unsuccessful in achieving consensus. The -p option was added to allow portable access to the values that can be saved and then later restored using; for example, a dot script.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

XBD Utility Syntax Guidelines

CHANGE HISTORY
Issue 6
IEEE PASC Interpretation 1003.2 #203 is applied, clarifying the format when a variable is unset.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/6 is applied, adding the following text to the end of the first paragraph of the DESCRIPTION: "If the name of a variable is followed by = word, then the value of that variable shall be set to word.". The reason for this change is that the SYNOPSIS for export includes:

export name[=word]...

but the meaning of the optional "= word" is never explained in the text.

Issue 7
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0043 [352] is applied.

POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0051 [654] and XCU/TC2-2008/0052 [960] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
readonly - set the readonly attribute for variables
SYNOPSIS
readonly name[=word]...
 
readonly -p

DESCRIPTION
The variables whose names are specified shall be given the readonly attribute. The values of variables with the readonly attribute cannot be changed by subsequent assignment, nor can those variables be unset by the unset utility. If the name of a variable is followed by = word, then the value of that variable shall be set to word.

The readonly special built-in shall support XBD Utility Syntax Guidelines.

When -p is specified, readonly writes to the standard output the names and values of all read-only variables, in the following format:

"readonly %s=%s\n", <name>, <value>

if name is set, and

"readonly %s\n", <name>

if name is unset.

The shell shall format the output, including the proper use of quoting, so that it is suitable for reinput to the shell as commands that achieve the same value and readonly attribute-setting results in a shell execution environment in which:

Variables with values at the time they were output do not have the readonly attribute set.

Variables that were unset at the time they were output do not have a value at the time at which the saved output is reinput to the shell.

When no arguments are given, the results are unspecified.

OPTIONS
See the DESCRIPTION.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
See the DESCRIPTION.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
All name operands were successfully marked readonly.
>0
At least one name could not be marked readonly, or the -p option was specified and an error occurred.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
readonly HOME PWD

RATIONALE
Some historical shells preserve the readonly attribute across separate invocations. This volume of POSIX.1-2008 allows this behavior, but does not require it.

The -p option allows portable access to the values that can be saved and then later restored using, for example, a dot script. Also see the RATIONALE for export for a description of the no-argument and -p output cases and a related example.

Read-only functions were considered, but they were omitted as not being historical practice or particularly useful. Furthermore, functions must not be read-only across invocations to preclude "spoofing" (spoofing is the term for the practice of creating a program that acts like a well-known utility with the intent of subverting the real intent of the user) of administrative or security-relevant (or security-conscious) shell scripts.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

XBD Utility Syntax Guidelines

CHANGE HISTORY
Issue 6
IEEE PASC Interpretation 1003.2 #203 is applied, clarifying the format when a variable is unset.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/7 is applied, adding the following text to the end of the first paragraph of the DESCRIPTION: "If the name of a variable is followed by = word, then the value of that variable shall be set to word.". The reason for this change is that the SYNOPSIS for readonly includes:
readonly name[=word]...

but the meaning of the optional "= word" is never explained in the text.

Issue 7
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0052 [960] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
return - return from a function or dot script
SYNOPSIS
return [n]

DESCRIPTION
The return utility shall cause the shell to stop executing the current function or dot script. If the shell is not currently executing a function or dot script, the results are unspecified.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
The value of the special parameter '?' shall be set to n, an unsigned decimal integer, or to the exit status of the last command executed if n is not specified. If n is not an unsigned decimal integer, or is greater than 255, the results are unspecified. When return is executed in a trap action, the last command is considered to be the command that executed immediately preceding the trap action.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
None.

RATIONALE
The behavior of return when not in a function or dot script differs between the System V shell and the KornShell. In the System V shell this is an error, whereas in the KornShell, the effect is the same as exit.

The results of returning a number greater than 255 are undefined because of differing practices in the various historical implementations. Some shells AND out all but the low-order 8 bits; others allow larger values, but not of unlimited size.

See the discussion of appropriate exit status values under exit.

FUTURE DIRECTIONS
None.

SEE ALSO
Function Definition Command, Special Built-In Utilities, dot

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0044 [214] and XCU/TC1-2008/0045 [214] are applied.

POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0052 [960] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
set - set or unset options and positional parameters
SYNOPSIS
set [-abCefhmnuvx] [-o option] [argument...]
 
set [+abCefhmnuvx] [+o option] [argument...]
 
set -- [argument...]
 
set -o
 
set +o

DESCRIPTION
If no options or arguments are specified, set shall write the names and values of all shell variables in the collation sequence of the current locale. Each name shall start on a separate line, using the format:

"%s=%s\n", <name>, <value>

The value string shall be written with appropriate quoting; see the description of shell quoting in Quoting. The output shall be suitable for reinput to the shell, setting or resetting, as far as possible, the variables that are currently set; read-only variables cannot be reset.

When options are specified, they shall set or unset attributes of the shell, as described below. When arguments are specified, they cause positional parameters to be set or unset, as described below. Setting or unsetting attributes and positional parameters are not necessarily related actions, but they can be combined in a single invocation of set.

The set special built-in shall support XBD Utility Syntax Guidelines except that options can be specified with either a leading <hyphen-minus> (meaning enable the option) or <plus-sign> (meaning disable it) unless otherwise specified.

Implementations shall support the options in the following list in both their <hyphen-minus> and <plus-sign> forms. These options can also be specified as options to sh.

-a
When this option is on, the export attribute shall be set for each variable to which an assignment is performed; see XBD Variable Assignment. If the assignment precedes a utility name in a command, the export attribute shall not persist in the current execution environment after the utility completes, with the exception that preceding one of the special built-in utilities causes the export attribute to persist after the built-in has completed. If the assignment does not precede a utility name in the command, or if the assignment is a result of the operation of the getopts or read utilities, the export attribute shall persist until the variable is unset.
-b
This option shall be supported if the implementation supports the User Portability Utilities option. It shall cause the shell to notify the user asynchronously of background job completions. The following message is written to standard error:
"[%d]%c %s%s\n", <job-number>, <current>, <status>, <job-name>

where the fields shall be as follows:

<current>
The character '+' identifies the job that would be used as a default for the fg or bg utilities; this job can also be specified using the job_id "%+" or "%%". The character '-' identifies the job that would become the default if the current default job were to exit; this job can also be specified using the job_id "%-". For other jobs, this field is a <space>. At most one job can be identified with '+' and at most one job can be identified with '-'. If there is any suspended job, then the current job shall be a suspended job. If there are at least two suspended jobs, then the previous job also shall be a suspended job.
<job-number>
A number that can be used to identify the process group to the wait, fg, bg, and kill utilities. Using these utilities, the job can be identified by prefixing the job number with '%'.
<status>
Unspecified.
<job-name>
Unspecified.
When the shell notifies the user a job has been completed, it may remove the job's process ID from the list of those known in the current shell execution environment; see Asynchronous Lists. Asynchronous notification shall not be enabled by default.

-C
(Uppercase C.) Prevent existing files from being overwritten by the shell's '>' redirection operator (see Redirecting Output); the ">|" redirection operator shall override this noclobber option for an individual file.
-e
When this option is on, when any command fails (for any of the reasons listed in Consequences of Shell Errors or by returning an exit status greater than zero), the shell immediately shall exit, as if by executing the exit special built-in utility with no arguments, with the following exceptions:
The failure of any individual command in a multi-command pipeline shall not cause the shell to exit. Only the failure of the pipeline itself shall be considered.

The -e setting shall be ignored when executing the compound list following the while, until, if, or elif reserved word, a pipeline beginning with the ! reserved word, or any command of an AND-OR list other than the last.

If the exit status of a compound command other than a subshell command was the result of a failure while -e was being ignored, then -e shall not apply to this command.

This requirement applies to the shell environment and each subshell environment separately. For example, in:

set -e; (false; echo one) | cat; echo two

the false command causes the subshell to exit without executing echo one; however, echo two is executed because the exit status of the pipeline (false; echo one) | cat is zero.

-f
The shell shall disable pathname expansion.
-h
Locate and remember utilities invoked by functions as those functions are defined (the utilities are normally located when the function is executed).
-m
This option shall be supported if the implementation supports the User Portability Utilities option. All jobs shall be run in their own process groups. Immediately before the shell issues a prompt after completion of the background job, a message reporting the exit status of the background job shall be written to standard error. If a foreground job stops, the shell shall write a message to standard error to that effect, formatted as described by the jobs utility. In addition, if a job changes status other than exiting (for example, if it stops for input or output or is stopped by a SIGSTOP signal), the shell shall write a similar message immediately prior to writing the next prompt. This option is enabled by default for interactive shells.
-n
The shell shall read commands but does not execute them; this can be used to check for shell script syntax errors. An interactive shell may ignore this option.
-o
Write the current settings of the options to standard output in an unspecified format.
+o
Write the current option settings to standard output in a format that is suitable for reinput to the shell as commands that achieve the same options settings.
-o  option
This option is supported if the system supports the User Portability Utilities option. It shall set various options, many of which shall be equivalent to the single option letters. The following values of option shall be supported:
allexport
Equivalent to -a.
errexit
Equivalent to -e.
ignoreeof
Prevent an interactive shell from exiting on end-of-file. This setting prevents accidental logouts when <control>-D is entered. A user shall explicitly exit to leave the interactive shell.
monitor
Equivalent to -m. This option is supported if the system supports the User Portability Utilities option.
noclobber
Equivalent to -C (uppercase C).
noglob
Equivalent to -f.
noexec
Equivalent to -n.
nolog
Prevent the entry of function definitions into the command history; see Command History List.
notify
Equivalent to -b.
nounset
Equivalent to -u.
verbose
Equivalent to -v.
vi
Allow shell command line editing using the built-in vi editor. Enabling vi mode shall disable any other command line editing mode provided as an implementation extension.
It need not be possible to set vi mode on for certain block-mode terminals.

xtrace
Equivalent to -x.
-u
When the shell tries to expand an unset parameter other than the '@' and '*' special parameters, it shall write a message to standard error and the expansion shall fail with the consequences specified in Consequences of Shell Errors.
-v
The shell shall write its input to standard error as it is read.
-x
The shell shall write to standard error a trace for each command after it expands the command and before it executes it. It is unspecified whether the command that turns tracing off is traced.
The default for all these options shall be off (unset) unless stated otherwise in the description of the option or unless the shell was invoked with them on; see sh.

The remaining arguments shall be assigned in order to the positional parameters. The special parameter '#' shall be set to reflect the number of positional parameters. All positional parameters shall be unset before any new values are assigned.

If the first argument is '-', the results are unspecified.

The special argument "--" immediately following the set command name can be used to delimit the arguments if the first argument begins with '+' or '-', or to prevent inadvertent listing of all shell variables when there are no arguments. The command set -- without argument shall unset all positional parameters and set the special parameter '#' to zero.

OPTIONS
See the DESCRIPTION.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
See the DESCRIPTION.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
Successful completion.
>0
An invalid option was specified, or an error occurred.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
Application writers should avoid relying on set -e within functions. For example, in the following script:

set -e
start() {
    some_server
    echo some_server started successfully
}
start || echo >&2 some_server failed

the -e setting is ignored within the function body (because the function is a command in an AND-OR list other than the last). Therefore, if some_server fails, the function carries on to echo "some_server started successfully", and the exit status of the function is zero (which means "some_server failed" is not output).

EXAMPLES
Write out all variables and their values:

set

Set $1, $2, and $3 and set "$#" to 3:

set c a b

Turn on the -x and -v options:

set -xv

Unset all positional parameters:

set --

Set $1 to the value of x, even if it begins with '-' or '+' :

set -- "$x"

Set the positional parameters to the expansion of x, even if x expands with a leading '-' or '+' :

set -- $x

RATIONALE
The set -- form is listed specifically in the SYNOPSIS even though this usage is implied by the Utility Syntax Guidelines. The explanation of this feature removes any ambiguity about whether the set -- form might be misinterpreted as being equivalent to set without any options or arguments. The functionality of this form has been adopted from the KornShell. In System V, set -- only unsets parameters if there is at least one argument; the only way to unset all parameters is to use shift. Using the KornShell version should not affect System V scripts because there should be no reason to issue it without arguments deliberately; if it were issued as, for example:

set -- "$@"

and there were in fact no arguments resulting from "$@", unsetting the parameters would have no result.

The set + form in early proposals was omitted as being an unnecessary duplication of set alone and not widespread historical practice.

The noclobber option was changed to allow set -C as well as the set -o noclobber option. The single-letter version was added so that the historical "$-" paradigm would not be broken; see Special Parameters.

The description of the -e option is intended to match the behavior of the 1988 version of the KornShell.

The -h flag is related to command name hashing. See hash.

The following set flags were omitted intentionally with the following rationale:

-k
The -k flag was originally added by the author of the Bourne shell to make it easier for users of pre-release versions of the shell. In early versions of the Bourne shell the construct set name= value had to be used to assign values to shell variables. The problem with -k is that the behavior affects parsing, virtually precluding writing any compilers. To explain the behavior of -k, it is necessary to describe the parsing algorithm, which is implementation-defined. For example:
set -k; echo name=value
and:

set -k
echo name=value
behave differently. The interaction with functions is even more complex. What is more, the -k flag is never needed, since the command line could have been reordered.

-t
The -t flag is hard to specify and almost never used. The only known use could be done with here-documents. Moreover, the behavior with ksh and sh differs. The reference page says that it exits after reading and executing one command. What is one command? If the input is date; date, sh executes both date commands while ksh does only the first.
Consideration was given to rewriting set to simplify its confusing syntax. A specific suggestion was that the unset utility should be used to unset options instead of using the non- getopt() -able + option syntax. However, the conclusion was reached that the historical practice of using + option was satisfactory and that there was no compelling reason to modify such widespread historical practice.

The -o option was adopted from the KornShell to address user needs. In addition to its generally friendly interface, -o is needed to provide the vi command line editing mode, for which historical practice yields no single-letter option name. (Although it might have been possible to invent such a letter, it was recognized that other editing modes would be developed and -o provides ample name space for describing such extensions.)

Historical implementations are inconsistent in the format used for -o option status reporting. The +o format without an option-argument was added to allow portable access to the options that can be saved and then later restored using, for instance, a dot script.

Historically, sh did trace the command set +x, but ksh did not.

The ignoreeof setting prevents accidental logouts when the end-of-file character (typically <control>-D) is entered. A user shall explicitly exit to leave the interactive shell.

The set -m option was added to apply only to the UPE because it applies primarily to interactive use, not shell script applications.

The ability to do asynchronous notification became available in the 1988 version of the KornShell. To have it occur, the user had to issue the command:

trap "jobs -n" CLD

The C shell provides two different levels of an asynchronous notification capability. The environment variable notify is analogous to what is done in set -b or set -o notify. When set, it notifies the user immediately of background job completions. When unset, this capability is turned off.

The other notification ability comes through the built-in utility notify. The syntax is:

notify [%job ... ]
By issuing notify with no operands, it causes the C shell to notify the user asynchronously when the state of the current job changes. If given operands, notify asynchronously informs the user of changes in the states of the specified jobs.

To add asynchronous notification to the POSIX shell, neither the KornShell extensions to trap, nor the C shell notify environment variable seemed appropriate (notify is not a proper POSIX environment variable name).

The set -b option was selected as a compromise.

The notify built-in was considered to have more functionality than was required for simple asynchronous notification.

Historically, some shells applied the -u option to all parameters including $@ and $*. The standard developers felt that this was a misfeature since it is normal and common for $@ and $* to be used in shell scripts regardless of whether they were passed any arguments. Treating these uses as an error when no arguments are passed reduces the value of -u for its intended purpose of finding spelling mistakes in variable names and uses of unset positional parameters.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities, hash

XBD Variable Assignment, Utility Syntax Guidelines

CHANGE HISTORY
Issue 6
The obsolescent set command name followed by '-' has been removed.

The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:

The nolog option is added to set -o.

IEEE PASC Interpretation 1003.2 #167 is applied, clarifying that the options default also takes into account the description of the option.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/8 is applied, changing the square brackets in the example in RATIONALE to be in bold, which is the typeface used for optional items.

Issue 7
Austin Group Interpretation 1003.1-2001 #027 is applied, clarifying the behavior if the first argument is '-'.

SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

XSI shading is removed from the -h functionality.

POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0046 [52], XCU/TC1-2008/0047 [155,280], XCU/TC1-2008/0048 [52], XCU/TC1-2008/0049 [52], and XCU/TC1-2008/0050 [155,430] are applied.

POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0053 [584], XCU/TC2-2008/0054 [717], XCU/TC2-2008/0055 [717], and XCU/TC2-2008/0056 [960] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
shift - shift positional parameters
SYNOPSIS
shift [n]

DESCRIPTION
The positional parameters shall be shifted. Positional parameter 1 shall be assigned the value of parameter (1+n), parameter 2 shall be assigned the value of parameter (2+n), and so on. The parameters represented by the numbers "$#" down to "$#-n+1" shall be unset, and the parameter '#' is updated to reflect the new number of positional parameters.

The value n shall be an unsigned decimal integer less than or equal to the value of the special parameter '#'. If n is not given, it shall be assumed to be 1. If n is 0, the positional and special parameters are not changed.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
If the n operand is invalid or is greater than "$#", this may be considered a syntax error and a non-interactive shell may exit; if the shell does not exit in this case, a non-zero exit status shall be returned. Otherwise, zero shall be returned.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
$ set a b c d e
$ shift 2
$ echo $*
c d e

RATIONALE
None.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0051 [459] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
times - write process times
SYNOPSIS
times

DESCRIPTION
The times utility shall write the accumulated user and system times for the shell and for all of its child processes, in the following POSIX locale format:

"%dm%fs %dm%fs\n%dm%fs %dm%fs\n", <shell user minutes>,
    <shell user seconds>, <shell system minutes>,
    <shell system seconds>, <children user minutes>,
    <children user seconds>, <children system minutes>,
    <children system seconds>

The four pairs of times shall correspond to the members of the <sys/times.h> tms structure (defined in XBD Headers) as returned by times(): tms_utime, tms_stime, tms_cutime, and tms_cstime, respectively.

OPTIONS
None.

OPERANDS
None.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
See the DESCRIPTION.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
$ times
0m0.43s 0m1.11s
8m44.18s 1m43.23s

RATIONALE
The times special built-in from the Single UNIX Specification is now required for all conforming shells.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

XBD <sys/times.h>

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/9 is applied, changing text in the DESCRIPTION from: "Write the accumulated user and system times for the shell and for all of its child processes ..." to: "The times utility shall write the accumulated user and system times for the shell and for all of its child processes ...".

Issue 7
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0056 [960] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
trap - trap signals
SYNOPSIS
trap n [condition...]trap [action condition...]

DESCRIPTION
If the first operand is an unsigned decimal integer, the shell shall treat all operands as conditions, and shall reset each condition to the default value. Otherwise, if there are operands, the first is treated as an action and the remaining as conditions.

If action is '-', the shell shall reset each condition to the default value. If action is null ( "" ), the shell shall ignore each specified condition if it arises. Otherwise, the argument action shall be read and executed by the shell when one of the corresponding conditions arises. The action of trap shall override a previous action (either default action or one explicitly set). The value of "$?" after the trap action completes shall be the value it had before trap was invoked.

The condition can be EXIT, 0 (equivalent to EXIT), or a signal specified using a symbolic name, without the SIG prefix, as listed in the tables of signal names in the <signal.h> header defined in XBD Headers; for example, HUP, INT, QUIT, TERM. Implementations may permit names with the SIG prefix or ignore case in signal names as an extension. Setting a trap for SIGKILL or SIGSTOP produces undefined results.

The environment in which the shell executes a trap on EXIT shall be identical to the environment immediately after the last command executed before the trap on EXIT was taken.

Each time trap is invoked, the action argument shall be processed in a manner equivalent to:

eval action
Signals that were ignored on entry to a non-interactive shell cannot be trapped or reset, although no error need be reported when attempting to do so. An interactive shell may reset or catch signals ignored on entry. Traps shall remain in place for a given shell until explicitly changed with another trap command.

When a subshell is entered, traps that are not being ignored shall be set to the default actions, except in the case of a command substitution containing only a single trap command, when the traps need not be altered. Implementations may check for this case using only lexical analysis; for example, if `trap` and $( trap -- ) do not alter the traps in the subshell, cases such as assigning var=trap and then using $($var) may still alter them. This does not imply that the trap command cannot be used within the subshell to set new traps.

The trap command with no operands shall write to standard output a list of commands associated with each condition. If the command is executed in a subshell, the implementation does not perform the optional check described above for a command substitution containing only a single trap command, and no trap commands with operands have been executed since entry to the subshell, the list shall contain the commands that were associated with each condition immediately before the subshell environment was entered. Otherwise, the list shall contain the commands currently associated with each condition. The format shall be:

"trap -- %s %s ...\n", <action>, <condition> ...

The shell shall format the output, including the proper use of quoting, so that it is suitable for reinput to the shell as commands that achieve the same trapping results. For example:

save_traps=$(trap)
...
eval "$save_traps"

[XSI] [Option Start] XSI-conformant systems also allow numeric signal numbers for the conditions corresponding to the following signal names:

1
SIGHUP
2
SIGINT
3
SIGQUIT
6
SIGABRT
9
SIGKILL
14
SIGALRM
15
SIGTERM
[Option End]
The trap special built-in shall conform to XBD Utility Syntax Guidelines.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
See the DESCRIPTION.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
If the trap name [XSI] [Option Start]  or number [Option End] is invalid, a non-zero exit status shall be returned; otherwise, zero shall be returned. For both interactive and non-interactive shells, invalid signal names [XSI] [Option Start]  or numbers [Option End] shall not be considered a syntax error and do not cause the shell to abort.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
Write out a list of all traps and actions:

trap

Set a trap so the logout utility in the directory referred to by the HOME environment variable executes when the shell terminates:

trap '"$HOME"/logout' EXIT

or:

trap '"$HOME"/logout' 0

Unset traps on INT, QUIT, TERM, and EXIT:

trap - INT QUIT TERM EXIT

RATIONALE
Implementations may permit lowercase signal names as an extension. Implementations may also accept the names with the SIG prefix; no known historical shell does so. The trap and kill utilities in this volume of POSIX.1-2008 are now consistent in their omission of the SIG prefix for signal names. Some kill implementations do not allow the prefix, and kill -l lists the signals without prefixes.

Trapping SIGKILL or SIGSTOP is syntactically accepted by some historical implementations, but it has no effect. Portable POSIX applications cannot attempt to trap these signals.

The output format is not historical practice. Since the output of historical trap commands is not portable (because numeric signal values are not portable) and had to change to become so, an opportunity was taken to format the output in a way that a shell script could use to save and then later reuse a trap if it wanted.

The KornShell uses an ERR trap that is triggered whenever set -e would cause an exit. This is allowable as an extension, but was not mandated, as other shells have not used it.

The text about the environment for the EXIT trap invalidates the behavior of some historical versions of interactive shells which, for example, close the standard input before executing a trap on 0. For example, in some historical interactive shell sessions the following trap on 0 would always print "--" :

trap 'read foo; echo "-$foo-"' 0

The command:

trap 'eval " $cmd"' 0

causes the contents of the shell variable cmd to be executed as a command when the shell exits. Using:

trap '$cmd' 0

does not work correctly if cmd contains any special characters such as quoting or redirections. Using:

trap " $cmd" 0

also works (the leading <space> character protects against unlikely cases where cmd is a decimal integer or begins with '-' ), but it expands the cmd variable when the trap command is executed, not when the exit action is executed.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

XBD Utility Syntax Guidelines, <signal.h>

CHANGE HISTORY
Issue 6
XSI-conforming implementations provide the mapping of signal names to numbers given above (previously this had been marked obsolescent). Other implementations need not provide this optional mapping.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

Austin Group Interpretation 1003.1-2001 #116 is applied.

POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0052 [53,268,440], XCU/TC1-2008/0053 [53,268,440], XCU/TC1-2008/0054 [163], XCU/TC1-2008/0055 [163], and XCU/TC1-2008/0056 [163] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
unset - unset values and attributes of variables and functions
SYNOPSIS
unset [-fv] name...

DESCRIPTION
Each variable or function specified by name shall be unset.

If -v is specified, name refers to a variable name and the shell shall unset it and remove it from the environment. Read-only variables cannot be unset.

If -f is specified, name refers to a function and the shell shall unset the function definition.

If neither -f nor -v is specified, name refers to a variable; if a variable by that name does not exist, it is unspecified whether a function by that name, if any, shall be unset.

Unsetting a variable or function that was not previously set shall not be considered an error and does not cause the shell to abort.

The unset special built-in shall support XBD Utility Syntax Guidelines.

Note that:

VARIABLE=

is not equivalent to an unset of VARIABLE; in the example, VARIABLE is set to "". Also, the variables that can be unset should not be misinterpreted to include the special parameters (see Special Parameters).

OPTIONS
See the DESCRIPTION.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
All name operands were successfully unset.
>0
At least one name could not be unset.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
Unset VISUAL variable:

unset -v VISUAL

Unset the functions foo and bar:

unset -f foo bar

RATIONALE
Consideration was given to omitting the -f option in favor of an unfunction utility, but the standard developers decided to retain historical practice.

The -v option was introduced because System V historically used one name space for both variables and functions. When unset is used without options, System V historically unset either a function or a variable, and there was no confusion about which one was intended. A portable POSIX application can use unset without an option to unset a variable, but not a function; the -f option must be used.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

XBD Utility Syntax Guidelines

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

End of informative text.
<<< Previous	Home	Next >>>


<<< Previous	Home	Next >>>
The Open Group Base Specifications Issue 7
IEEE Std 1003.1-2008, 2016 Edition
Copyright  2001-2016 The IEEE and The Open Group
2. Shell Command Language
This chapter contains the definition of the Shell Command Language.

2.1 Shell Introduction
The shell is a command language interpreter. This chapter describes the syntax of that command language as it is used by the sh utility and the system() and popen() functions defined in the System Interfaces volume of POSIX.1-2008.

The shell operates according to the following general overview of operations. The specific details are included in the cited sections of this chapter.

The shell reads its input from a file (see sh), from the -c option or from the system() and popen() functions defined in the System Interfaces volume of POSIX.1-2008. If the first line of a file of shell commands starts with the characters "#!", the results are unspecified.

The shell breaks the input into tokens: words and operators; see Token Recognition.

The shell parses the input into simple commands (see Simple Commands) and compound commands (see Compound Commands).

The shell performs various expansions (separately) on different parts of each command, resulting in a list of pathnames and fields to be treated as a command and arguments; see wordexp.

The shell performs redirection (see Redirection) and removes redirection operators and their operands from the parameter list.

The shell executes a function (see Function Definition Command), built-in (see Special Built-In Utilities), executable file, or script, giving the names of the arguments as positional parameters numbered 1 to n, and the name of the command (or in the case of a function within a script, the name of the script) as the positional parameter numbered 0 (see Command Search and Execution).

The shell optionally waits for the command to complete and collects the exit status (see Exit Status for Commands).

2.2 Quoting
Quoting is used to remove the special meaning of certain characters or words to the shell. Quoting can be used to preserve the literal meaning of the special characters in the next paragraph, prevent reserved words from being recognized as such, and prevent parameter expansion and command substitution within here-document processing (see Here-Document).

The application shall quote the following characters if they are to represent themselves:

|  &  ;  <  >  (  )  $  `  \  "  '  <space>  <tab>  <newline>

and the following may need to be quoted under certain circumstances. That is, these characters may be special depending on conditions described elsewhere in this volume of POSIX.1-2008:

*   ?   [   #      =   %

The various quoting mechanisms are the escape character, single-quotes, and double-quotes. The here-document represents another form of quoting; see Here-Document.

2.2.1 Escape Character (Backslash)
A <backslash> that is not quoted shall preserve the literal value of the following character, with the exception of a <newline>. If a <newline> follows the <backslash>, the shell shall interpret this as line continuation. The <backslash> and <newline> shall be removed before splitting the input into tokens. Since the escaped <newline> is removed entirely from the input and is not replaced by any white space, it cannot serve as a token separator.

2.2.2 Single-Quotes
Enclosing characters in single-quotes ( '' ) shall preserve the literal value of each character within the single-quotes. A single-quote cannot occur within single-quotes.

2.2.3 Double-Quotes
Enclosing characters in double-quotes ( "" ) shall preserve the literal value of all characters within the double-quotes, with the exception of the characters backquote, <dollar-sign>, and <backslash>, as follows:

$
The <dollar-sign> shall retain its special meaning introducing parameter expansion (see Parameter Expansion), a form of command substitution (see Command Substitution), and arithmetic expansion (see Arithmetic Expansion).
The input characters within the quoted string that are also enclosed between "$(" and the matching ')' shall not be affected by the double-quotes, but rather shall define that command whose output replaces the "$(...)" when the word is expanded. The tokenizing rules in Token Recognition, not including the alias substitutions in Alias Substitution, shall be applied recursively to find the matching ')'.

Within the string of characters from an enclosed "${" to the matching '}', an even number of unescaped double-quotes or single-quotes, if any, shall occur. A preceding <backslash> character shall be used to escape a literal '{' or '}'. The rule in Parameter Expansion shall be used to determine the matching '}'.

`
The backquote shall retain its special meaning introducing the other form of command substitution (see Command Substitution). The portion of the quoted string from the initial backquote and the characters up to the next backquote that is not preceded by a <backslash>, having escape characters removed, defines that command whose output replaces "`...`" when the word is expanded. Either of the following cases produces undefined results:
A single-quoted or double-quoted string that begins, but does not end, within the "`...`" sequence

A "`...`" sequence that begins, but does not end, within the same double-quoted string

\
The <backslash> shall retain its special meaning as an escape character (see Escape Character (Backslash)) only when followed by one of the following characters when considered special:
$   `   "   \   <newline>

The application shall ensure that a double-quote is preceded by a <backslash> to be included within double-quotes. The parameter '@' has special meaning inside double-quotes and is described in Special Parameters .

2.3 Token Recognition
The shell shall read its input in terms of lines. (For details about how the shell reads its input, see the description of sh.) The input lines can be of unlimited length. These lines shall be parsed using two major modes: ordinary token recognition and processing of here-documents.

When an io_here token has been recognized by the grammar (see Shell Grammar), one or more of the subsequent lines immediately following the next NEWLINE token form the body of one or more here-documents and shall be parsed according to the rules of Here-Document.

When it is not processing an io_here, the shell shall break its input into tokens by applying the first applicable rule below to the next character in its input. The token shall be from the current position in the input until a token is delimited according to one of the rules below; the characters forming the token are exactly those in the input, including any quoting characters. If it is indicated that a token is delimited, and no characters have been included in a token, processing shall continue until an actual token is delimited.

If the end of input is recognized, the current token (if any) shall be delimited.

If the previous character was used as part of an operator and the current character is not quoted and can be used with the previous characters to form an operator, it shall be used as part of that (operator) token.

If the previous character was used as part of an operator and the current character cannot be used with the previous characters to form an operator, the operator containing the previous character shall be delimited.

If the current character is <backslash>, single-quote, or double-quote and it is not quoted, it shall affect quoting for subsequent characters up to the end of the quoted text. The rules for quoting are as described in Quoting . During token recognition no substitutions shall be actually performed, and the result token shall contain exactly the characters that appear in the input (except for <newline> joining), unmodified, including any embedded or enclosing quotes or substitution operators, between the <quotation-mark> and the end of the quoted text. The token shall not be delimited by the end of the quoted field.

If the current character is an unquoted '$' or '`', the shell shall identify the start of any candidates for parameter expansion (Parameter Expansion), command substitution (Command Substitution), or arithmetic expansion (Arithmetic Expansion) from their introductory unquoted character sequences: '$' or "${", "$(" or '`', and "$((", respectively. The shell shall read sufficient input to determine the end of the unit to be expanded (as explained in the cited sections). While processing the characters, if instances of expansions or quoting are found nested within the substitution, the shell shall recursively process them in the manner specified for the construct that is found. The characters found from the beginning of the substitution to its end, allowing for any recursion necessary to recognize embedded constructs, shall be included unmodified in the result token, including any embedded or enclosing substitution operators or quotes. The token shall not be delimited by the end of the substitution.

If the current character is not quoted and can be used as the first character of a new operator, the current token (if any) shall be delimited. The current character shall be used as the beginning of the next (operator) token.

If the current character is an unquoted <blank>, any token containing the previous character is delimited and the current character shall be discarded.

If the previous character was part of a word, the current character shall be appended to that word.

If the current character is a '#', it and all subsequent characters up to, but excluding, the next <newline> shall be discarded as a comment. The <newline> that ends the line is not considered part of the comment.

The current character is used as the start of a new word.

Once a token is delimited, it is categorized as required by the grammar in Shell Grammar.

2.3.1 Alias Substitution
After a token has been delimited, but before applying the grammatical rules in Shell Grammar, a resulting word that is identified to be the command name word of a simple command shall be examined to determine whether it is an unquoted, valid alias name. However, reserved words in correct grammatical context shall not be candidates for alias substitution. A valid alias name (see XBD Alias Name) shall be one that has been defined by the alias utility and not subsequently undefined using unalias. Implementations also may provide predefined valid aliases that are in effect when the shell is invoked. To prevent infinite loops in recursive aliasing, if the shell is not currently processing an alias of the same name, the word shall be replaced by the value of the alias; otherwise, it shall not be replaced.

If the value of the alias replacing the word ends in a <blank>, the shell shall check the next command word for alias substitution; this process shall continue until a word is found that is not a valid alias or an alias value does not end in a <blank>.

When used as specified by this volume of POSIX.1-2008, alias definitions shall not be inherited by separate invocations of the shell or by the utility execution environments invoked by the shell; see Shell Execution Environment.

2.4 Reserved Words
Reserved words are words that have special meaning to the shell; see Shell Commands. The following words shall be recognized as reserved words:


!
{
}
case


do
done
elif
else


esac
fi
for
if


in
then
until
while

This recognition shall only occur when none of the characters is quoted and when the word is used as:

The first word of a command

The first word following one of the reserved words other than case, for, or in

The third word in a case command (only in is valid in this case)

The third word in a for command (only in and do are valid in this case)

See the grammar in Shell Grammar.

The following words may be recognized as reserved words on some implementations (when none of the characters are quoted), causing unspecified results:

[[

]]

function

select

Words that are the concatenation of a name and a <colon> ( ':' ) are reserved; their use produces unspecified results.

2.5 Parameters and Variables
A parameter can be denoted by a name, a number, or one of the special characters listed in Special Parameters. A variable is a parameter denoted by a name.

A parameter is set if it has an assigned value (null is a valid value). Once a variable is set, it can only be unset by using the unset special built-in command.

2.5.1 Positional Parameters
A positional parameter is a parameter denoted by the decimal value represented by one or more digits, other than the single digit 0. The digits denoting the positional parameters shall always be interpreted as a decimal value, even if there is a leading zero. When a positional parameter with more than one digit is specified, the application shall enclose the digits in braces (see Parameter Expansion). Positional parameters are initially assigned when the shell is invoked (see sh), temporarily replaced when a shell function is invoked (see Function Definition Command), and can be reassigned with the set special built-in command.

2.5.2 Special Parameters
Listed below are the special parameters and the values to which they shall expand. Only the values of the special parameters are listed; see wordexp for a detailed summary of all the stages involved in expanding words.

@
Expands to the positional parameters, starting from one, initially producing one field for each positional parameter that is set. When the expansion occurs in a context where field splitting will be performed, any empty fields may be discarded and each of the non-empty fields shall be further split as described in Field Splitting. When the expansion occurs within double-quotes, the behavior is unspecified unless one of the following is true:
Field splitting as described in Field Splitting would be performed if the expansion were not within double-quotes (regardless of whether field splitting would have any effect; for example, if IFS is null).

The double-quotes are within the word of a ${parameter:-word} or a ${parameter:+word} expansion (with or without the <colon>; see Parameter Expansion) which would have been subject to field splitting if parameter had been expanded instead of word.

If one of these conditions is true, the initial fields shall be retained as separate fields, except that if the parameter being expanded was embedded within a word, the first field shall be joined with the beginning part of the original word and the last field shall be joined with the end part of the original word. In all other contexts the results of the expansion are unspecified. If there are no positional parameters, the expansion of '@' shall generate zero fields, even when '@' is within double-quotes; however, if the expansion is embedded within a word which contains one or more other parts that expand to a quoted null string, these null string(s) shall still produce an empty field, except that if the other parts are all within the same double-quotes as the '@', it is unspecified whether the result is zero fields or one empty field.

*
Expands to the positional parameters, starting from one, initially producing one field for each positional parameter that is set. When the expansion occurs in a context where field splitting will be performed, any empty fields may be discarded and each of the non-empty fields shall be further split as described in Field Splitting. When the expansion occurs in a context where field splitting will not be performed, the initial fields shall be joined to form a single field with the value of each parameter separated by the first character of the IFS variable if IFS contains at least one character, or separated by a <space> if IFS is unset, or with no separation if IFS is set to a null string.
#
Expands to the decimal number of positional parameters. The command name (parameter 0) shall not be counted in the number given by '#' because it is a special parameter, not a positional parameter.
?
Expands to the decimal exit status of the most recent pipeline (see Pipelines).
-
(Hyphen.) Expands to the current option flags (the single-letter option names concatenated into a string) as specified on invocation, by the set special built-in command, or implicitly by the shell.
$
Expands to the decimal process ID of the invoked shell. In a subshell (see Shell Execution Environment ), '$' shall expand to the same value as that of the current shell.
!
Expands to the decimal process ID of the most recent background command (see Lists) executed from the current shell. (For example, background commands executed from subshells do not affect the value of "$!" in the current shell environment.) For a pipeline, the process ID is that of the last command in the pipeline.
0
(Zero.) Expands to the name of the shell or shell script. See sh for a detailed description of how this name is derived.
See the description of the IFS variable in Shell Variables.

2.5.3 Shell Variables
Variables shall be initialized from the environment (as defined by XBD Environment Variables and the exec function in the System Interfaces volume of POSIX.1-2008) and can be given new values with variable assignment commands. If a variable is initialized from the environment, it shall be marked for export immediately; see the export special built-in. New variables can be defined and initialized with variable assignments, with the read or getopts utilities, with the name parameter in a for loop, with the ${ name= word} expansion, or with other mechanisms provided as implementation extensions.
The following variables shall affect the execution of the shell:

ENV
[UP] [Option Start] The processing of the ENV shell variable shall be supported if the system supports the User Portability Utilities option. [Option End]
This variable, when and only when an interactive shell is invoked, shall be subjected to parameter expansion (see Parameter Expansion) by the shell and the resulting value shall be used as a pathname of a file containing shell commands to execute in the current environment. The file need not be executable. If the expanded value of ENV is not an absolute pathname, the results are unspecified. ENV shall be ignored if the user's real and effective user IDs or real and effective group IDs are different.

HOME
The pathname of the user's home directory. The contents of HOME are used in tilde expansion (see Tilde Expansion).
IFS
A string treated as a list of characters that is used for field splitting, expansion of the '*' special parameter, and to split lines into fields with the read utility. If the value of IFS includes any bytes that do not form part of a valid character, the results of field splitting, expansion of '*', and use of the read utility are unspecified.
If IFS is not set, it shall behave as normal for an unset variable, except that field splitting by the shell and line splitting by the read utility shall be performed as if the value of IFS is <space> <tab> <newline>; see Field Splitting.

The shell shall set IFS to <space> <tab> <newline> when it is invoked.

LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD Internationalization Variables for the precedence of internationalization variables used to determine the values of locale categories.)
LC_ALL
The value of this variable overrides the LC_* variables and LANG, as described in XBD Environment Variables.
LC_COLLATE
Determine the behavior of range expressions, equivalence classes, and multi-character collating elements within pattern matching.
LC_CTYPE
Determine the interpretation of sequences of bytes of text data as characters (for example, single-byte as opposed to multi-byte characters), which characters are defined as letters (character class alpha) and <blank> characters (character class blank), and the behavior of character classes within pattern matching. Changing the value of LC_CTYPE after the shell has started shall not affect the lexical processing of shell commands in the current shell execution environment or its subshells. Invoking a shell script or performing exec sh subjects the new shell to the changes in LC_CTYPE.
LC_MESSAGES
Determine the language in which messages should be written.
LINENO
Set by the shell to a decimal number representing the current sequential line number (numbered starting with 1) within a script or function before it executes each command. If the user unsets or resets LINENO, the variable may lose its special meaning for the life of the shell. If the shell is not currently executing a script or function, the value of LINENO is unspecified. This volume of POSIX.1-2008 specifies the effects of the variable only for systems supporting the User Portability Utilities option.
NLSPATH
[XSI] [Option Start] Determine the location of message catalogs for the processing of LC_MESSAGES. [Option End]
PATH
A string formatted as described in XBD Environment Variables, used to effect command interpretation; see Command Search and Execution.
PPID
Set by the shell to the decimal value of its parent process ID during initialization of the shell. In a subshell (see Shell Execution Environment), PPID shall be set to the same value as that of the parent of the current shell. For example, echo $ PPID and (echo $ PPID) would produce the same value.
PS1
Each time an interactive shell is ready to read a command, the value of this variable shall be subjected to parameter expansion and written to standard error. The default value shall be "$ ". For users who have specific additional implementation-defined privileges, the default may be another, implementation-defined value. The shell shall replace each instance of the character '!' in PS1 with the history file number of the next command to be typed. Escaping the '!' with another '!' (that is, "!!" ) shall place the literal character '!' in the prompt. This volume of POSIX.1-2008 specifies the effects of the variable only for systems supporting the User Portability Utilities option.
PS2
Each time the user enters a <newline> prior to completing a command line in an interactive shell, the value of this variable shall be subjected to parameter expansion and written to standard error. The default value is "> ". This volume of POSIX.1-2008 specifies the effects of the variable only for systems supporting the User Portability Utilities option.
PS4
When an execution trace (set -x) is being performed in an interactive shell, before each line in the execution trace, the value of this variable shall be subjected to parameter expansion and written to standard error. The default value is "+ ". This volume of POSIX.1-2008 specifies the effects of the variable only for systems supporting the User Portability Utilities option.
PWD
Set by the shell and by the cd utility. In the shell the value shall be initialized from the environment as follows. If a value for PWD is passed to the shell in the environment when it is executed, the value is an absolute pathname of the current working directory that is no longer than {PATH_MAX} bytes including the terminating null byte, and the value does not contain any components that are dot or dot-dot, then the shell shall set PWD to the value from the environment. Otherwise, if a value for PWD is passed to the shell in the environment when it is executed, the value is an absolute pathname of the current working directory, and the value does not contain any components that are dot or dot-dot, then it is unspecified whether the shell sets PWD to the value from the environment or sets PWD to the pathname that would be output by pwd -P. Otherwise, the sh utility sets PWD to the pathname that would be output by pwd -P. In cases where PWD is set to the value from the environment, the value can contain components that refer to files of type symbolic link. In cases where PWD is set to the pathname that would be output by pwd -P, if there is insufficient permission on the current working directory, or on any parent of that directory, to determine what that pathname would be, the value of PWD is unspecified. Assignments to this variable may be ignored. If an application sets or unsets the value of PWD, the behaviors of the cd and pwd utilities are unspecified.
2.6 Word Expansions
This section describes the various expansions that are performed on words. Not all expansions are performed on every word, as explained in the following sections.

Tilde expansions, parameter expansions, command substitutions, arithmetic expansions, and quote removals that occur within a single word expand to a single field. It is only field splitting or pathname expansion that can create multiple fields from a single word. The single exception to this rule is the expansion of the special parameter '@' within double-quotes, as described in Special Parameters.

The order of word expansion shall be as follows:

Tilde expansion (see Tilde Expansion), parameter expansion (see Parameter Expansion), command substitution (see Command Substitution), and arithmetic expansion (see Arithmetic Expansion) shall be performed, beginning to end. See item 5 in Token Recognition.

Field splitting (see Field Splitting) shall be performed on the portions of the fields generated by step 1, unless IFS is null.

Pathname expansion (see Pathname Expansion) shall be performed, unless set -f is in effect.

Quote removal (see Quote Removal) shall always be performed last.

The expansions described in this section shall occur in the same shell environment as that in which the command is executed.

If the complete expansion appropriate for a word results in an empty field, that empty field shall be deleted from the list of fields that form the completely expanded command, unless the original word contained single-quote or double-quote characters.

The '$' character is used to introduce parameter expansion, command substitution, or arithmetic evaluation. If an unquoted '$' is followed by a character that is not one of the following:

A numeric character

The name of one of the special parameters (see Special Parameters)

A valid first character of a variable name

A <left-curly-bracket> ( '{' )

A <left-parenthesis>

the result is unspecified.

2.6.1 Tilde Expansion
A "tilde-prefix" consists of an unquoted <tilde> character at the beginning of a word, followed by all of the characters preceding the first unquoted <slash> in the word, or all the characters in the word if there is no <slash>. In an assignment (see XBD Variable Assignment), multiple tilde-prefixes can be used: at the beginning of the word (that is, following the <equals-sign> of the assignment), following any unquoted <colon>, or both. A tilde-prefix in an assignment is terminated by the first unquoted <colon> or <slash>. If none of the characters in the tilde-prefix are quoted, the characters in the tilde-prefix following the <tilde> are treated as a possible login name from the user database. A portable login name cannot contain characters outside the set given in the description of the LOGNAME environment variable in XBD Other Environment Variables. If the login name is null (that is, the tilde-prefix contains only the tilde), the tilde-prefix is replaced by the value of the variable HOME. If HOME is unset, the results are unspecified. Otherwise, the tilde-prefix shall be replaced by a pathname of the initial working directory associated with the login name obtained using the getpwnam() function as defined in the System Interfaces volume of POSIX.1-2008. If the system does not recognize the login name, the results are undefined.

The pathname resulting from tilde expansion shall be treated as if quoted to prevent it being altered by field splitting and pathname expansion.

2.6.2 Parameter Expansion
The format for parameter expansion is as follows:

${expression}

where expression consists of all characters until the matching '}'. Any '}' escaped by a <backslash> or within a quoted string, and characters in embedded arithmetic expansions, command substitutions, and variable expansions, shall not be examined in determining the matching '}'.

The simplest form for parameter expansion is:

${parameter}

The value, if any, of parameter shall be substituted.

The parameter name or symbol can be enclosed in braces, which are optional except for positional parameters with more than one digit or when parameter is a name and is followed by a character that could be interpreted as part of the name. The matching closing brace shall be determined by counting brace levels, skipping over enclosed quoted strings, and command substitutions.

If the parameter is not enclosed in braces, and is a name, the expansion shall use the longest valid name (see XBD Name), whether or not the variable represented by that name exists. Otherwise, the parameter is a single-character symbol, and behavior is unspecified if that character is neither a digit nor one of the special parameters (see Special Parameters).

If a parameter expansion occurs inside double-quotes:

Pathname expansion shall not be performed on the results of the expansion.

Field splitting shall not be performed on the results of the expansion.

In addition, a parameter expansion can be modified by using one of the following formats. In each case that a value of word is needed (based on the state of parameter, as described below), word shall be subjected to tilde expansion, parameter expansion, command substitution, and arithmetic expansion. If word is not needed, it shall not be expanded. The '}' character that delimits the following parameter expansion modifications shall be determined as described previously in this section and in Double-Quotes.

${parameter:-[word]}
Use Default Values. If parameter is unset or null, the expansion of word (or an empty string if word is omitted) shall be substituted; otherwise, the value of parameter shall be substituted.
${parameter:=[word]}
Assign Default Values. If parameter is unset or null, the expansion of word (or an empty string if word is omitted) shall be assigned to parameter. In all cases, the final value of parameter shall be substituted. Only variables, not positional parameters or special parameters, can be assigned in this way.
${parameter:?[word]}
Indicate Error if Null or Unset. If parameter is unset or null, the expansion of word (or a message indicating it is unset if word is omitted) shall be written to standard error and the shell exits with a non-zero exit status. Otherwise, the value of parameter shall be substituted. An interactive shell need not exit.
${parameter:+[word]}
Use Alternative Value. If parameter is unset or null, null shall be substituted; otherwise, the expansion of word (or an empty string if word is omitted) shall be substituted.
In the parameter expansions shown previously, use of the <colon> in the format shall result in a test for a parameter that is unset or null; omission of the <colon> shall result in a test for a parameter that is only unset. If parameter is '#' and the colon is omitted, the application shall ensure that word is specified (this is necessary to avoid ambiguity with the string length expansion). The following table summarizes the effect of the <colon>:

 

parameter
Set and Not Null

parameter
Set But Null

parameter
Unset

${parameter:-word}

substitute parameter

substitute word

substitute word

${parameter-word}

substitute parameter

substitute null

substitute word

${parameter:=word}

substitute parameter

assign word

assign word

${parameter=word}

substitute parameter

substitute null

assign word

${parameter:?word}

substitute parameter

error, exit

error, exit

${parameter?word}

substitute parameter

substitute null

error, exit

${parameter:+word}

substitute word

substitute null

substitute null

${parameter+word}

substitute word

substitute word

substitute null

In all cases shown with "substitute", the expression is replaced with the value shown. In all cases shown with "assign", parameter is assigned that value, which also replaces the expression.

${#parameter}
String Length. The length in characters of the value of parameter shall be substituted. If parameter is '*' or '@', the result of the expansion is unspecified. If parameter is unset and set -u is in effect, the expansion shall fail.
The following four varieties of parameter expansion provide for substring processing. In each case, pattern matching notation (see Pattern Matching Notation), rather than regular expression notation, shall be used to evaluate the patterns. If parameter is '#', '*', or '@', the result of the expansion is unspecified. If parameter is unset and set -u is in effect, the expansion shall fail. Enclosing the full parameter expansion string in double-quotes shall not cause the following four varieties of pattern characters to be quoted, whereas quoting characters within the braces shall have this effect. In each variety, if word is omitted, the empty pattern shall be used.

${parameter%[word]}
Remove Smallest Suffix Pattern. The word shall be expanded to produce a pattern. The parameter expansion shall then result in parameter, with the smallest portion of the suffix matched by the pattern deleted. If present, word shall not begin with an unquoted '%'.
${parameter%%[word]}
Remove Largest Suffix Pattern. The word shall be expanded to produce a pattern. The parameter expansion shall then result in parameter, with the largest portion of the suffix matched by the pattern deleted.
${parameter#[word]}
Remove Smallest Prefix Pattern. The word shall be expanded to produce a pattern. The parameter expansion shall then result in parameter, with the smallest portion of the prefix matched by the pattern deleted. If present, word shall not begin with an unquoted '#'.
${parameter##[word]}
Remove Largest Prefix Pattern. The word shall be expanded to produce a pattern. The parameter expansion shall then result in parameter, with the largest portion of the prefix matched by the pattern deleted.
The following sections are informative.
Examples
${parameter}
In this example, the effects of omitting braces are demonstrated.
a=1
set 2
echo ${a}b-$ab-${1}0-${10}-$10
1b--20--20
${parameter-word}
This example demonstrates the difference between unset and set to the empty string, as well as the rules for finding the delimiting close brace.
foo=asdf
echo ${foo-bar}xyz}
asdfxyz}foo=
echo ${foo-bar}xyz}
xyz}unset foo
echo ${foo-bar}xyz}
barxyz}
${parameter:-word}
In this example, ls is executed only if x is null or unset. (The $(ls) command substitution notation is explained in Command Substitution.)
${x:-$(ls)}

${parameter:=word}
unset X
echo ${X:=abc}
abc
${parameter:?word}
unset posix
echo ${posix:?}
sh: posix: parameter null or not set
${parameter:+word}
set a b c
echo ${3:+posix}
posix
${#parameter}
HOME=/usr/posix
echo ${#HOME}
10
${parameter%word}
x=file.c
echo ${x%.c}.o
file.o
${parameter%%word}
x=posix/src/std
echo ${x%%/*}
posix
${parameter#word}
x=$HOME/src/cmd
echo ${x#$HOME}
/src/cmd
${parameter##word}
x=/one/two/three
echo ${x##*/}
three
The double-quoting of patterns is different depending on where the double-quotes are placed:

"${x#*}"
The <asterisk> is a pattern character.
${x#"*"}
The literal <asterisk> is quoted and not special.
End of informative text.
2.6.3 Command Substitution
Command substitution allows the output of a command to be substituted in place of the command name itself. Command substitution shall occur when the command is enclosed as follows:

$(command)

or (backquoted version):

`command`

The shell shall expand the command substitution by executing command in a subshell environment (see Shell Execution Environment) and replacing the command substitution (the text of command plus the enclosing "$()" or backquotes) with the standard output of the command, removing sequences of one or more <newline> characters at the end of the substitution. Embedded <newline> characters before the end of the output shall not be removed; however, they may be treated as field delimiters and eliminated during field splitting, depending on the value of IFS and quoting that is in effect. If the output contains any null bytes, the behavior is unspecified.

Within the backquoted style of command substitution, <backslash> shall retain its literal meaning, except when followed by: '$', '`', or <backslash>. The search for the matching backquote shall be satisfied by the first unquoted non-escaped backquote; during this search, if a non-escaped backquote is encountered within a shell comment, a here-document, an embedded command substitution of the $(command) form, or a quoted string, undefined results occur. A single-quoted or double-quoted string that begins, but does not end, within the "`...`" sequence produces undefined results.

With the $(command) form, all characters following the open parenthesis to the matching closing parenthesis constitute the command. Any valid shell script can be used for command, except a script consisting solely of redirections which produces unspecified results.

The results of command substitution shall not be processed for further tilde expansion, parameter expansion, command substitution, or arithmetic expansion. If a command substitution occurs inside double-quotes, field splitting and pathname expansion shall not be performed on the results of the substitution.

Command substitution can be nested. To specify nesting within the backquoted version, the application shall precede the inner backquotes with <backslash> characters; for example:

\`command\`

The syntax of the shell command language has an ambiguity for expansions beginning with "$((", which can introduce an arithmetic expansion or a command substitution that starts with a subshell. Arithmetic expansion has precedence; that is, the shell shall first determine whether it can parse the expansion as an arithmetic expansion and shall only parse the expansion as a command substitution if it determines that it cannot parse the expansion as an arithmetic expansion. The shell need not evaluate nested expansions when performing this determination. If it encounters the end of input without already having determined that it cannot parse the expansion as an arithmetic expansion, the shell shall treat the expansion as an incomplete arithmetic expansion and report a syntax error. A conforming application shall ensure that it separates the "$(" and '(' into two tokens (that is, separate them with white space) in a command substitution that starts with a subshell. For example, a command substitution containing a single subshell could be written as:

$( (command) )

2.6.4 Arithmetic Expansion
Arithmetic expansion provides a mechanism for evaluating an arithmetic expression and substituting its value. The format for arithmetic expansion shall be as follows:

$((expression))

The expression shall be treated as if it were in double-quotes, except that a double-quote inside the expression is not treated specially. The shell shall expand all tokens in the expression for parameter expansion, command substitution, and quote removal.

Next, the shell shall treat this as an arithmetic expression and substitute the value of the expression. The arithmetic expression shall be processed according to the rules given in Arithmetic Precision and Operations, with the following exceptions:

Only signed long integer arithmetic is required.

Only the decimal-constant, octal-constant, and hexadecimal-constant constants specified in the ISO C standard, Section 6.4.4.1 are required to be recognized as constants.

The sizeof() operator and the prefix and postfix "++" and "--" operators are not required.

Selection, iteration, and jump statements are not supported.

All changes to variables in an arithmetic expression shall be in effect after the arithmetic expansion, as in the parameter expansion "${x=value}".

If the shell variable x contains a value that forms a valid integer constant, optionally including a leading <plus-sign> or <hyphen-minus>, then the arithmetic expansions "$((x))" and "$(($x))" shall return the same value.

As an extension, the shell may recognize arithmetic expressions beyond those listed. The shell may use a signed integer type with a rank larger than the rank of signed long. The shell may use a real-floating type instead of signed long as long as it does not affect the results in cases where there is no overflow. If the expression is invalid, or the contents of a shell variable used in the expression are not recognized by the shell, the expansion fails and the shell shall write a diagnostic message to standard error indicating the failure.

The following sections are informative.
Examples
A simple example using arithmetic expansion:

# repeat a command 100 times
x=100
while [ $x -gt 0 ]
do
    command    x=$(($x-1))
done

End of informative text.
2.6.5 Field Splitting
After parameter expansion (Parameter Expansion), command substitution (Command Substitution), and arithmetic expansion (Arithmetic Expansion), the shell shall scan the results of expansions and substitutions that did not occur in double-quotes for field splitting and multiple fields can result.

The shell shall treat each character of the IFS as a delimiter and use the delimiters as field terminators to split the results of parameter expansion, command substitution, and arithmetic expansion into fields.

If the value of IFS is a <space>, <tab>, and <newline>, or if it is unset, any sequence of <space>, <tab>, or <newline> characters at the beginning or end of the input shall be ignored and any sequence of those characters within the input shall delimit a field. For example, the input:

<newline><space><tab>foo<tab><tab>bar<space>

yields two fields, foo and bar.

If the value of IFS is null, no field splitting shall be performed.

Otherwise, the following rules shall be applied in sequence. The term " IFS white space" is used to mean any sequence (zero or more instances) of white-space characters that are in the IFS value (for example, if IFS contains <space>/ <comma>/ <tab>, any sequence of <space> and <tab> characters is considered IFS white space).

IFS white space shall be ignored at the beginning and end of the input.

Each occurrence in the input of an IFS character that is not IFS white space, along with any adjacent IFS white space, shall delimit a field, as described previously.

Non-zero-length IFS white space shall delimit a field.

2.6.6 Pathname Expansion
After field splitting, if set -f is not in effect, each field in the resulting command line shall be expanded using the algorithm described in Pattern Matching Notation, qualified by the rules in Patterns Used for Filename Expansion.

2.6.7 Quote Removal
The quote characters ( <backslash>, single-quote, and double-quote) that were present in the original word shall be removed unless they have themselves been quoted.

2.7 Redirection
Redirection is used to open and close files for the current shell execution environment (see Shell Execution Environment) or for any command. Redirection operators can be used with numbers representing file descriptors (see XBD File Descriptor) as described below.

The overall format used for redirection is:

[n]redir-op word
The number n is an optional decimal number designating the file descriptor number; the application shall ensure it is delimited from any preceding text and immediately precede the redirection operator redir-op. If n is quoted, the number shall not be recognized as part of the redirection expression. For example:

echo \2>a

writes the character 2 into file a. If any part of redir-op is quoted, no redirection expression is recognized. For example:

echo 2\>a

writes the characters 2>a to standard output. The optional number, redirection operator, and word shall not appear in the arguments provided to the command to be executed (if any).

Open files are represented by decimal numbers starting with zero. The largest possible value is implementation-defined; however, all implementations shall support at least 0 to 9, inclusive, for use by the application. These numbers are called "file descriptors". The values 0, 1, and 2 have special meaning and conventional uses and are implied by certain redirection operations; they are referred to as standard input, standard output, and standard error, respectively. Programs usually take their input from standard input, and write output on standard output. Error messages are usually written on standard error. The redirection operators can be preceded by one or more digits (with no intervening <blank> characters allowed) to designate the file descriptor number.

If the redirection operator is "<<" or "<<-", the word that follows the redirection operator shall be subjected to quote removal; it is unspecified whether any of the other expansions occur. For the other redirection operators, the word that follows the redirection operator shall be subjected to tilde expansion, parameter expansion, command substitution, arithmetic expansion, and quote removal. Pathname expansion shall not be performed on the word by a non-interactive shell; an interactive shell may perform it, but shall do so only when the expansion would result in one word.

If more than one redirection operator is specified with a command, the order of evaluation is from beginning to end.

A failure to open or create a file shall cause a redirection to fail.

2.7.1 Redirecting Input
Input redirection shall cause the file whose name results from the expansion of word to be opened for reading on the designated file descriptor, or standard input if the file descriptor is not specified.

The general format for redirecting input is:

[n]<word
where the optional n represents the file descriptor number. If the number is omitted, the redirection shall refer to standard input (file descriptor 0).

2.7.2 Redirecting Output
The two general formats for redirecting output are:

[n]>word
[n]>|word
where the optional n represents the file descriptor number. If the number is omitted, the redirection shall refer to standard output (file descriptor 1).

Output redirection using the '>' format shall fail if the noclobber option is set (see the description of set -C) and the file named by the expansion of word exists and is a regular file. Otherwise, redirection using the '>' or ">|" formats shall cause the file whose name results from the expansion of word to be created and opened for output on the designated file descriptor, or standard output if none is specified. If the file does not exist, it shall be created; otherwise, it shall be truncated to be an empty file after being opened.

2.7.3 Appending Redirected Output
Appended output redirection shall cause the file whose name results from the expansion of word to be opened for output on the designated file descriptor. The file is opened as if the open() function as defined in the System Interfaces volume of POSIX.1-2008 was called with the O_APPEND flag. If the file does not exist, it shall be created.

The general format for appending redirected output is as follows:

[n]>>word
where the optional n represents the file descriptor number. If the number is omitted, the redirection refers to standard output (file descriptor 1).

2.7.4 Here-Document
The redirection operators "<<" and "<<-" both allow redirection of subsequent lines read by the shell to the input of a command. The redirected lines are known as a "here-document".

The here-document shall be treated as a single word that begins after the next <newline> and continues until there is a line containing only the delimiter and a <newline>, with no <blank> characters in between. Then the next here-document starts, if there is one. The format is as follows:

[n]<<word
    here-document
delimiter
where the optional n represents the file descriptor number. If the number is omitted, the here-document refers to standard input (file descriptor 0). It is unspecified whether the file descriptor is opened as a regular file, a special file, or a pipe. Portable applications cannot rely on the file descriptor being seekable (see XSH lseek).

If any part of word is quoted, the delimiter shall be formed by performing quote removal on word, and the here-document lines shall not be expanded. Otherwise, the delimiter shall be the word itself.

If no part of word is quoted, all lines of the here-document shall be expanded for parameter expansion, command substitution, and arithmetic expansion. In this case, the <backslash> in the input behaves as the <backslash> inside double-quotes (see Double-Quotes). However, the double-quote character ( ' )' shall not be treated specially within a here-document, except when the double-quote appears within "$()", "``", or "${}".

If the redirection operator is "<<-", all leading <tab> characters shall be stripped from input lines and the line containing the trailing delimiter. If more than one "<<" or "<<-" operator is specified on a line, the here-document associated with the first operator shall be supplied first by the application and shall be read first by the shell.

When a here-document is read from a terminal device and the shell is interactive, it shall write the contents of the variable PS2, processed as described in Shell Variables, to standard error before reading each line of input until the delimiter has been recognized.

The following sections are informative.
Examples
An example of a here-document follows:

cat <<eof1; cat <<eof2
Hi,
eof1
Helene.
eof2

End of informative text.
2.7.5 Duplicating an Input File Descriptor
The redirection operator:

[n]<&word
shall duplicate one input file descriptor from another, or shall close one. If word evaluates to one or more digits, the file descriptor denoted by n, or standard input if n is not specified, shall be made to be a copy of the file descriptor denoted by word; if the digits in word do not represent a file descriptor already open for input, a redirection error shall result; see Consequences of Shell Errors. If word evaluates to '-', file descriptor n, or standard input if n is not specified, shall be closed. Attempts to close a file descriptor that is not open shall not constitute an error. If word evaluates to something else, the behavior is unspecified.

2.7.6 Duplicating an Output File Descriptor
The redirection operator:

[n]>&word
shall duplicate one output file descriptor from another, or shall close one. If word evaluates to one or more digits, the file descriptor denoted by n, or standard output if n is not specified, shall be made to be a copy of the file descriptor denoted by word; if the digits in word do not represent a file descriptor already open for output, a redirection error shall result; see Consequences of Shell Errors. If word evaluates to '-', file descriptor n, or standard output if n is not specified, is closed. Attempts to close a file descriptor that is not open shall not constitute an error. If word evaluates to something else, the behavior is unspecified.

2.7.7 Open File Descriptors for Reading and Writing
The redirection operator:

[n]<>word
shall cause the file whose name is the expansion of word to be opened for both reading and writing on the file descriptor denoted by n, or standard input if n is not specified. If the file does not exist, it shall be created.

2.8 Exit Status and Errors
2.8.1 Consequences of Shell Errors
Certain errors shall cause the shell to write a diagnostic message to standard error and exit as shown in the following table:

Error

Non-Interactive
Shell

Interactive Shell

Shell Diagnostic
Message Required

Shell language syntax error

shall exit

shall not exit

yes

Special built-in utility error

shall exit

shall not exit

no1

Other utility (not a special
built-in) error

shall not exit

shall not exit

no2

Redirection error with
special built-in utilities

shall exit

shall not exit

yes

Redirection error with
compound commands

may exit3

shall not exit

yes

Redirection error with
function execution

may exit3

shall not exit

yes

Redirection error with other
utilities (not special built-ins)

shall not exit

shall not exit

yes

Variable assignment error

shall exit

shall not exit

yes

Expansion error

shall exit

shall not exit

yes

Command not found

may exit

shall not exit

yes

Notes:
Although special built-ins are part of the shell, a diagnostic message written by a special built-in is not considered to be a shell diagnostic message, and can be redirected like any other utility.

The shell is not required to write a diagnostic message, but the utility itself shall write a diagnostic message if required to do so.

A future version of this standard may require the shell to not exit in this condition.

An expansion error is one that occurs when the shell expansions define in wordexp are carried out (for example, "${x!y}", because '!' is not a valid operator); an implementation may treat these as syntax errors if it is able to detect them during tokenization, rather than during expansion.

If any of the errors shown as "shall exit" or "may exit" occur in a subshell environment, the shell shall (respectively, may) exit from the subshell environment with a non-zero status and continue in the environment from which that subshell environment was invoked.

In all of the cases shown in the table where an interactive shell is required not to exit, the shell shall not perform any further processing of the command in which the error occurred.

2.8.2 Exit Status for Commands
Each command has an exit status that can influence the behavior of other shell commands. The exit status of commands that are not utilities is documented in this section. The exit status of the standard utilities is documented in their respective sections.

If a command is not found, the exit status shall be 127. If the command name is found, but it is not an executable utility, the exit status shall be 126. Applications that invoke utilities without using the shell should use these exit status values to report similar errors.

If a command fails during word expansion or redirection, its exit status shall be between 1 and 125 inclusive.

Internally, for purposes of deciding whether a command exits with a non-zero exit status, the shell shall recognize the entire status value retrieved for the command by the equivalent of the wait() function WEXITSTATUS macro (as defined in the System Interfaces volume of POSIX.1-2008). When reporting the exit status with the special parameter '?', the shell shall report the full eight bits of exit status available. The exit status of a command that terminated because it received a signal shall be reported as greater than 128.

2.9 Shell Commands
This section describes the basic structure of shell commands. The following command descriptions each describe a format of the command that is only used to aid the reader in recognizing the command type, and does not formally represent the syntax. In particular, the representations include spacing between tokens in some places where <blank>s would not be necessary (when one of the tokens is an operator). Each description discusses the semantics of the command; for a formal definition of the command language, consult Shell Grammar.

A command is one of the following:

Simple command (see Simple Commands)

Pipeline (see Pipelines)

List compound-list (see Lists)

Compound command (see Compound Commands)

Function definition (see Function Definition Command)

Unless otherwise stated, the exit status of a command shall be that of the last simple command executed by the command. There shall be no limit on the size of any shell command other than that imposed by the underlying system (memory constraints, {ARG_MAX}, and so on).

2.9.1 Simple Commands
A "simple command" is a sequence of optional variable assignments and redirections, in any sequence, optionally followed by words and redirections, terminated by a control operator.

When a given simple command is required to be executed (that is, when any conditional construct such as an AND-OR list or a case statement has not bypassed the simple command), the following expansions, assignments, and redirections shall all be performed from the beginning of the command text to the end:

The words that are recognized as variable assignments or redirections according to Shell Grammar Rules are saved for processing in steps 3 and 4.

The words that are not variable assignments or redirections shall be expanded. If any fields remain following their expansion, the first field shall be considered the command name and remaining fields are the arguments for the command.

Redirections shall be performed as described in Redirection.

Each variable assignment shall be expanded for tilde expansion, parameter expansion, command substitution, arithmetic expansion, and quote removal prior to assigning the value.

In the preceding list, the order of steps 3 and 4 may be reversed if no command name results from step 2 or if the command name matches the name of a special built-in utility; see Special Built-In Utilities.

Variable assignments shall be performed as follows:

If no command name results, variable assignments shall affect the current execution environment.

If the command name is not a special built-in utility or function, the variable assignments shall be exported for the execution environment of the command and shall not affect the current execution environment except as a side-effect of the expansions performed in step 4. In this case it is unspecified:

Whether or not the assignments are visible for subsequent expansions in step 4

Whether variable assignments made as side-effects of these expansions are visible for subsequent expansions in step 4, or in the current shell execution environment, or both

If the command name is a standard utility implemented as a function (see XBD Utility), the effect of variable assignments shall be as if the utility was not implemented as a function.

If the command name is a special built-in utility, variable assignments shall affect the current execution environment. Unless the set -a option is on (see set), it is unspecified:

Whether or not the variables gain the export attribute during the execution of the special built-in utility

Whether or not export attributes gained as a result of the variable assignments persist after the completion of the special built-in utility

If the command name is a function that is not a standard utility implemented as a function, variable assignments shall affect the current execution environment during the execution of the function. It is unspecified:

Whether or not the variable assignments persist after the completion of the function

Whether or not the variables gain the export attribute during the execution of the function

Whether or not export attributes gained as a result of the variable assignments persist after the completion of the function (if variable assignments persist after the completion of the function)

If any of the variable assignments attempt to assign a value to a variable for which the readonly attribute is set in the current shell environment (regardless of whether the assignment is made in that environment), a variable assignment error shall occur. See Consequences of Shell Errors for the consequences of these errors.

If there is no command name, any redirections shall be performed in a subshell environment; it is unspecified whether this subshell environment is the same one as that used for a command substitution within the command. (To affect the current execution environment, see the exec special built-in.) If any of the redirections performed in the current shell execution environment fail, the command shall immediately fail with an exit status greater than zero, and the shell shall write an error message indicating the failure. See Consequences of Shell Errors for the consequences of these failures on interactive and non-interactive shells.

If there is a command name, execution shall continue as described in Command Search and Execution . If there is no command name, but the command contained a command substitution, the command shall complete with the exit status of the last command substitution performed. Otherwise, the command shall complete with a zero exit status.

Command Search and Execution
If a simple command results in a command name and an optional list of arguments, the following actions shall be performed:

If the command name does not contain any <slash> characters, the first successful step in the following sequence shall occur:

If the command name matches the name of a special built-in utility, that special built-in utility shall be invoked.

If the command name matches the name of a utility listed in the following table, the results are unspecified.


alloc
autoload
bind
bindkey
builtin
bye
caller
cap
chdir
clone
 


comparguments
compcall
compctl
compdescribe
compfiles
compgen
compgroups
complete
compquote
comptags
 


comptry
compvalues
declare
dirs
disable
disown
dosh
echotc
echoti
help
 


history
hist
let
local
login
logout
map
mapfile
popd
print
 


pushd
readarray
repeat
savehistory
source
shopt
stop
suspend
typeset
whence
 

If the command name matches the name of a function known to this shell, the function shall be invoked as described in Function Definition Command. If the implementation has provided a standard utility in the form of a function, it shall not be recognized at this point. It shall be invoked in conjunction with the path search in step 1e.

If the command name matches the name [XSI] [Option Start]  of the type or ulimit utility, or [Option End]  of a utility listed in the following table, that utility shall be invoked.


alias
bg
cd
command
 


false
fc
fg
getopts
 


hash
jobs
kill
newgrp
 


pwd
read
true
umask
 


unalias
wait
 

Otherwise, the command shall be searched for using the PATH environment variable as described in XBD Environment Variables :

If the search is successful:

If the system has implemented the utility as a regular built-in or as a shell function, it shall be invoked at this point in the path search.

Otherwise, the shell executes the utility in a separate utility environment (see Shell Execution Environment) with actions equivalent to calling the execl() function as defined in the System Interfaces volume of POSIX.1-2008 with the path argument set to the pathname resulting from the search, arg0 set to the command name, and the remaining execl() arguments set to the command arguments (if any) and the null terminator.

If the execl() function fails due to an error equivalent to the [ENOEXEC] error defined in the System Interfaces volume of POSIX.1-2008, the shell shall execute a command equivalent to having a shell invoked with the pathname resulting from the search as its first operand, with any remaining arguments passed to the new shell, except that the value of "$0" in the new shell may be set to the command name. If the executable file is not a text file, the shell may bypass this command execution. In this case, it shall write an error message, and shall return an exit status of 126.

It is unspecified whether environment variables that were passed to the shell when it was invoked, but were not used to initialize shell variables (see Shell Variables) because they had invalid names, are included in the environment passed to execl() and (if execl() fails as described above) to the new shell.

Once a utility has been searched for and found (either as a result of this specific search or as part of an unspecified shell start-up activity), an implementation may remember its location and need not search for the utility again unless the PATH variable has been the subject of an assignment. If the remembered location fails for a subsequent invocation, the shell shall repeat the search to find the new location for the utility, if any.

If the search is unsuccessful, the command shall fail with an exit status of 127 and the shell shall write an error message.

If the command name contains at least one <slash>, the shell shall execute the utility in a separate utility environment with actions equivalent to calling the execl() function defined in the System Interfaces volume of POSIX.1-2008 with the path and arg0 arguments set to the command name, and the remaining execl() arguments set to the command arguments (if any) and the null terminator.

If the execl() function fails due to an error equivalent to the [ENOEXEC] error, the shell shall execute a command equivalent to having a shell invoked with the command name as its first operand, with any remaining arguments passed to the new shell. If the executable file is not a text file, the shell may bypass this command execution. In this case, it shall write an error message and shall return an exit status of 126.

It is unspecified whether environment variables that were passed to the shell when it was invoked, but were not used to initialize shell variables (see Shell Variables) because they had invalid names, are included in the environment passed to execl() and (if execl() fails as described above) to the new shell.

If the utility would be executed with file descriptor 0, 1, or 2 closed, implementations may execute the utility with the file descriptor open to an unspecified file. If a standard utility or a conforming application is executed with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for writing, the environment in which the utility or application is executed shall be deemed non-conforming, and consequently the utility or application might not behave as described in this standard.

2.9.2 Pipelines
A pipeline is a sequence of one or more commands separated by the control operator '|'. For each command but the last, the shell shall connect the standard output of the command to the standard input of the next command as if by creating a pipe and passing the write end of the pipe as the standard output of the command and the read end of the pipe as the standard input of the next command.

The format for a pipeline is:

[!] command1 [ | command2 ...]
If the pipeline begins with the reserved word ! and command1 is a subshell command, the application shall ensure that the ( operator at the beginning of command1 is separated from the ! by one or more <blank> characters. The behavior of the reserved word ! immediately followed by the ( operator is unspecified.

The standard output of command1 shall be connected to the standard input of command2. The standard input, standard output, or both of a command shall be considered to be assigned by the pipeline before any redirection specified by redirection operators that are part of the command (see Redirection).

If the pipeline is not in the background (see Asynchronous Lists), the shell shall wait for the last command specified in the pipeline to complete, and may also wait for all commands to complete.

Exit Status
If the pipeline does not begin with the ! reserved word, the exit status shall be the exit status of the last command specified in the pipeline. Otherwise, the exit status shall be the logical NOT of the exit status of the last command. That is, if the last command returns zero, the exit status shall be 1; if the last command returns greater than zero, the exit status shall be zero.

2.9.3 Lists
An AND-OR list is a sequence of one or more pipelines separated by the operators "&&" and "||" .

A list is a sequence of one or more AND-OR lists separated by the operators ';' and '&'.

The operators "&&" and "||" shall have equal precedence and shall be evaluated with left associativity. For example, both of the following commands write solely bar to standard output:

false && echo foo || echo bar
true || echo foo && echo bar

A ';' separator or a ';' or <newline> terminator shall cause the preceding AND-OR list to be executed sequentially; an '&' separator or terminator shall cause asynchronous execution of the preceding AND-OR list.

The term "compound-list" is derived from the grammar in Shell Grammar; it is equivalent to a sequence of lists, separated by <newline> characters, that can be preceded or followed by an arbitrary number of <newline> characters.

The following sections are informative.
Examples
The following is an example that illustrates <newline> characters in compound-lists:

while
    # a couple of <newline>s


    # a list
    date && who || ls; cat file
    # a couple of <newline>s


    # another list
    wc file > output & true


do
    # 2 lists
    ls
    cat file
done

End of informative text.
Asynchronous Lists
If a command is terminated by the control operator <ampersand> ( '&' ), the shell shall execute the command asynchronously in a subshell. This means that the shell shall not wait for the command to finish before executing the next command.

The format for running a command in the background is:

command1 & [command2 & ... ]
If job control is disabled (see set, -m), the standard input for an asynchronous list, before any explicit redirections are performed, shall be considered to be assigned to a file that has the same properties as /dev/null. This shall not happen if job control is enabled. In all cases, explicit redirection of standard input shall override this activity.

When an element of an asynchronous list (the portion of the list ended by an <ampersand>, such as command1, above) is started by the shell, the process ID of the last command in the asynchronous list element shall become known in the current shell execution environment; see Shell Execution Environment. This process ID shall remain known until:

The command terminates and the application waits for the process ID.

Another asynchronous list is invoked before "$!" (corresponding to the previous asynchronous list) is expanded in the current execution environment.

The implementation need not retain more than the {CHILD_MAX} most recent entries in its list of known process IDs in the current shell execution environment.

Exit Status
The exit status of an asynchronous list shall be zero.

Sequential Lists
Commands that are separated by a <semicolon> ( ';' ) shall be executed sequentially.

The format for executing commands sequentially shall be:

command1 [; command2] ...

Each command shall be expanded and executed in the order specified.

Exit Status
The exit status of a sequential list shall be the exit status of the last command in the list.

AND Lists
The control operator "&&" denotes an AND list. The format shall be:

command1 [ && command2] ...

First command1 shall be executed. If its exit status is zero, command2 shall be executed, and so on, until a command has a non-zero exit status or there are no more commands left to execute. The commands are expanded only if they are executed.

Exit Status
The exit status of an AND list shall be the exit status of the last command that is executed in the list.

OR Lists
The control operator "||" denotes an OR List. The format shall be:

command1 [ || command2] ...

First, command1 shall be executed. If its exit status is non-zero, command2 shall be executed, and so on, until a command has a zero exit status or there are no more commands left to execute.

Exit Status
The exit status of an OR list shall be the exit status of the last command that is executed in the list.

2.9.4 Compound Commands
The shell has several programming constructs that are "compound commands", which provide control flow for commands. Each of these compound commands has a reserved word or control operator at the beginning, and a corresponding terminator reserved word or operator at the end. In addition, each can be followed by redirections on the same line as the terminator. Each redirection shall apply to all the commands within the compound command that do not explicitly override that redirection.

Grouping Commands
The format for grouping commands is as follows:

( compound-list )
Execute compound-list in a subshell environment; see Shell Execution Environment. Variable assignments and built-in commands that affect the environment shall not remain in effect after the list finishes.
If a character sequence beginning with "((" would be parsed by the shell as an arithmetic expansion if preceded by a '$', shells which implement an extension whereby "((expression))" is evaluated as an arithmetic expression may treat the "((" as introducing as an arithmetic evaluation instead of a grouping command. A conforming application shall ensure that it separates the two leading '(' characters with white space to prevent the shell from performing an arithmetic evaluation.

{ compound-list ; }
Execute compound-list in the current process environment. The semicolon shown here is an example of a control operator delimiting the } reserved word. Other delimiters are possible, as shown in Shell Grammar; a <newline> is frequently used.
Exit Status
The exit status of a grouping command shall be the exit status of compound-list.

The for Loop
The for loop shall execute a sequence of commands for each member in a list of items. The for loop requires that the reserved words do and done be used to delimit the sequence of commands.

The format for the for loop is as follows:

for name [ in [word ... ]]
do
    compound-list
done

First, the list of words following in shall be expanded to generate a list of items. Then, the variable name shall be set to each item, in turn, and the compound-list executed each time. If no items result from the expansion, the compound-list shall not be executed. Omitting:

in word...
shall be equivalent to:

in "$@"

Exit Status
The exit status of a for command shall be the exit status of the last command that executes. If there are no items, the exit status shall be zero.

Case Conditional Construct
The conditional construct case shall execute the compound-list corresponding to the first one of several patterns (see Pattern Matching Notation) that is matched by the string resulting from the tilde expansion, parameter expansion, command substitution, arithmetic expansion, and quote removal of the given word. The reserved word in shall denote the beginning of the patterns to be matched. Multiple patterns with the same compound-list shall be delimited by the '|' symbol. The control operator ')' terminates a list of patterns corresponding to a given action. The compound-list for each list of patterns, with the possible exception of the last, shall be terminated with ";;". The case construct terminates with the reserved word esac (case reversed).
The format for the case construct is as follows:

case word in
    [(] pattern1 ) compound-list ;;
    [[(] pattern[ | pattern] ... ) compound-list ;;] ...
    [[(] pattern[ | pattern] ... ) compound-list]
esac

The ";;" is optional for the last compound-list.

In order from the beginning to the end of the case statement, each pattern that labels a compound-list shall be subjected to tilde expansion, parameter expansion, command substitution, and arithmetic expansion, and the result of these expansions shall be compared against the expansion of word, according to the rules described in Pattern Matching Notation (which also describes the effect of quoting parts of the pattern). After the first match, no more patterns shall be expanded, and the compound-list shall be executed. The order of expansion and comparison of multiple patterns that label a compound-list statement is unspecified.

Exit Status
The exit status of case shall be zero if no patterns are matched. Otherwise, the exit status shall be the exit status of the last command executed in the compound-list.

The if Conditional Construct
The if command shall execute a compound-list and use its exit status to determine whether to execute another compound-list.

The format for the if construct is as follows:

if compound-list
then
    compound-list
[elif compound-list
then
    compound-list] ...
[else
    compound-list]
fi

The if compound-list shall be executed; if its exit status is zero, the then compound-list shall be executed and the command shall complete. Otherwise, each elif compound-list shall be executed, in turn, and if its exit status is zero, the then compound-list shall be executed and the command shall complete. Otherwise, the else compound-list shall be executed.

Exit Status
The exit status of the if command shall be the exit status of the then or else compound-list that was executed, or zero, if none was executed.

The while Loop
The while loop shall continuously execute one compound-list as long as another compound-list has a zero exit status.

The format of the while loop is as follows:

while compound-list-1
do
    compound-list-2
done

The compound-list-1 shall be executed, and if it has a non-zero exit status, the while command shall complete. Otherwise, the compound-list-2 shall be executed, and the process shall repeat.

Exit Status
The exit status of the while loop shall be the exit status of the last compound-list-2 executed, or zero if none was executed.

The until Loop
The until loop shall continuously execute one compound-list as long as another compound-list has a non-zero exit status.

The format of the until loop is as follows:

until compound-list-1
do
    compound-list-2
done

The compound-list-1 shall be executed, and if it has a zero exit status, the until command completes. Otherwise, the compound-list-2 shall be executed, and the process repeats.

Exit Status
The exit status of the until loop shall be the exit status of the last compound-list-2 executed, or zero if none was executed.

2.9.5 Function Definition Command
A function is a user-defined name that is used as a simple command to call a compound command with new positional parameters. A function is defined with a "function definition command".

The format of a function definition command is as follows:

fname ( ) compound-command [io-redirect ...]
The function is named fname; the application shall ensure that it is a name (see XBD Name) and that it is not the name of a special built-in utility. An implementation may allow other characters in a function name as an extension. The implementation shall maintain separate name spaces for functions and variables.

The argument compound-command represents a compound command, as described in Compound Commands.

When the function is declared, none of the expansions in wordexp shall be performed on the text in compound-command or io-redirect; all expansions shall be performed as normal each time the function is called. Similarly, the optional io-redirect redirections and any variable assignments within compound-command shall be performed during the execution of the function itself, not the function definition. See Consequences of Shell Errors for the consequences of failures of these operations on interactive and non-interactive shells.

When a function is executed, it shall have the syntax-error properties described for special built-in utilities in the first item in the enumerated list at the beginning of Special Built-In Utilities.

The compound-command shall be executed whenever the function name is specified as the name of a simple command (see Command Search and Execution). The operands to the command temporarily shall become the positional parameters during the execution of the compound-command; the special parameter '#' also shall be changed to reflect the number of operands. The special parameter 0 shall be unchanged. When the function completes, the values of the positional parameters and the special parameter '#' shall be restored to the values they had before the function was executed. If the special built-in return (see return) is executed in the compound-command, the function completes and execution shall resume with the next command after the function call.

Exit Status
The exit status of a function definition shall be zero if the function was declared successfully; otherwise, it shall be greater than zero. The exit status of a function invocation shall be the exit status of the last command executed by the function.

2.10. Shell Grammar
The following grammar defines the Shell Command Language. This formal syntax shall take precedence over the preceding text syntax description.

2.10.1 Shell Grammar Lexical Conventions
The input language to the shell must be first recognized at the character level. The resulting tokens shall be classified by their immediate context according to the following rules (applied in order). These rules shall be used to determine what a "token" is that is subject to parsing at the token level. The rules for token recognition in Token Recognition shall apply.

If the token is an operator, the token identifier for that operator shall result.

If the string consists solely of digits and the delimiter character is one of '<' or '>', the token identifier IO_NUMBER shall be returned.

Otherwise, the token identifier TOKEN results.

Further distinction on TOKEN is context-dependent. It may be that the same TOKEN yields WORD, a NAME, an ASSIGNMENT_WORD, or one of the reserved words below, dependent upon the context. Some of the productions in the grammar below are annotated with a rule number from the following list. When a TOKEN is seen where one of those annotated productions could be used to reduce the symbol, the applicable rule shall be applied to convert the token identifier type of the TOKEN to a token identifier acceptable at that point in the grammar. The reduction shall then proceed based upon the token identifier type yielded by the rule applied. When more than one rule applies, the highest numbered rule shall apply (which in turn may refer to another rule). (Note that except in rule 7, the presence of an '=' in the token has no effect.)

The WORD tokens shall have the word expansion rules applied to them immediately before the associated command is executed, not at the time the command is parsed.

2.10.2 Shell Grammar Rules
[Command Name]

When the TOKEN is exactly a reserved word, the token identifier for that reserved word shall result. Otherwise, the token WORD shall be returned. Also, if the parser is in any state where only a reserved word could be the next correct token, proceed as above.

Note:
Because at this point <quotation-mark> characters are retained in the token, quoted strings cannot be recognized as reserved words. This rule also implies that reserved words are not recognized except in certain positions in the input, such as after a <newline> or <semicolon>; the grammar presumes that if the reserved word is intended, it is properly delimited by the user, and does not attempt to reflect that requirement directly. Also note that line joining is done before tokenization, as described in Escape Character (Backslash), so escaped <newline> characters are already removed at this point.
Rule 1 is not directly referenced in the grammar, but is referred to by other rules, or applies globally.

[Redirection to or from filename]

The expansions specified in Redirection shall occur. As specified there, exactly one field can result (or the result is unspecified), and there are additional requirements on pathname expansion.

[Redirection from here-document]

Quote removal shall be applied to the word to determine the delimiter that is used to find the end of the here-document that begins after the next <newline>.

[Case statement termination]

When the TOKEN is exactly the reserved word esac, the token identifier for esac shall result. Otherwise, the token WORD shall be returned.

[ NAME in for]

When the TOKEN meets the requirements for a name (see XBD Name ), the token identifier NAME shall result. Otherwise, the token WORD shall be returned.

[Third word of for and case]

[ case only]

When the TOKEN is exactly the reserved word in, the token identifier for in shall result. Otherwise, the token WORD shall be returned.

[ for only]

When the TOKEN is exactly the reserved word in or do, the token identifier for in or do shall result, respectively. Otherwise, the token WORD shall be returned.

(For a. and b.: As indicated in the grammar, a linebreak precedes the tokens in and do. If <newline> characters are present at the indicated location, it is the token after them that is treated in this fashion.)

[Assignment preceding command name]

[When the first word]

If the TOKEN does not contain the character '=', rule 1 is applied. Otherwise, 7b shall be applied.

[Not the first word]

If the TOKEN contains an unquoted (as determined while applying rule 4 from Token Recognition) <equals-sign> character that is not part of an embedded parameter expansion, command substitution, or arithmetic expansion construct (as determined while applying rule 5 from Token Recognition):

If the TOKEN begins with '=', then rule 1 shall be applied.

If all the characters in the TOKEN preceding the first such <equals-sign> form a valid name (see XBD Name), the token ASSIGNMENT_WORD shall be returned.

Otherwise, it is unspecified whether rule 1 is applied or ASSIGNMENT_WORD is returned.

Otherwise, rule 1 shall be applied.

Assignment to the name within a returned ASSIGNMENT_WORD token shall occur as specified in Simple Commands.

[ NAME in function]

When the TOKEN is exactly a reserved word, the token identifier for that reserved word shall result. Otherwise, when the TOKEN meets the requirements for a name, the token identifier NAME shall result. Otherwise, rule 7 applies.

[Body of function]

Word expansion and assignment shall never occur, even when required by the rules above, when this rule is being parsed. Each TOKEN that might either be expanded or have assignment applied to it shall instead be returned as a single WORD consisting only of characters that are exactly the token described in Token Recognition.


/* -------------------------------------------------------
   The grammar symbols
   ------------------------------------------------------- */
%token  WORD
%token  ASSIGNMENT_WORD
%token  NAME
%token  NEWLINE
%token  IO_NUMBER


/* The following are the operators (see XBD Operator)
   containing more than one character. */



%token  AND_IF    OR_IF    DSEMI
/*      '&&'      '||'     ';;'    */


%token  DLESS  DGREAT  LESSAND  GREATAND  LESSGREAT  DLESSDASH
/*      '<<'   '>>'    '<&'     '>&'      '<>'       '<<-'   */


%token  CLOBBER
/*      '>|'   */


/* The following are the reserved words. */


%token  If    Then    Else    Elif    Fi    Do    Done
/*      'if'  'then'  'else'  'elif'  'fi'  'do'  'done'   */


%token  Case    Esac    While    Until    For
/*      'case'  'esac'  'while'  'until'  'for'   */


/* These are reserved words, not operator tokens, and are
   recognized when reserved words are recognized. */


%token  Lbrace    Rbrace    Bang
/*      '{'       '}'       '!'   */


%token  In
/*      'in'   */


/* -------------------------------------------------------
   The Grammar
   ------------------------------------------------------- */
%start program
%%
program          : linebreak complete_commands linebreak
                 | linebreak
                 ;
complete_commands: complete_commands newline_list complete_command
                 |                                complete_command
                 ;
complete_command : list separator_op
                 | list
                 ;
list             : list separator_op and_or
                 |                   and_or
                 ;
and_or           :                         pipeline
                 | and_or AND_IF linebreak pipeline
                 | and_or OR_IF  linebreak pipeline
                 ;
pipeline         :      pipe_sequence
                 | Bang pipe_sequence
                 ;
pipe_sequence    :                             command
                 | pipe_sequence '|' linebreak command
                 ;
command          : simple_command
                 | compound_command
                 | compound_command redirect_list
                 | function_definition
                 ;
compound_command : brace_group
                 | subshell
                 | for_clause
                 | case_clause
                 | if_clause
                 | while_clause
                 | until_clause
                 ;
subshell         : '(' compound_list ')'
                 ;
compound_list    : linebreak term
                 | linebreak term separator
                 ;
term             : term separator and_or
                 |                and_or
                 ;
for_clause       : For name                                      do_group
                 | For name                       sequential_sep do_group
                 | For name linebreak in          sequential_sep do_group
                 | For name linebreak in wordlist sequential_sep do_group
                 ;
name             : NAME                     /* Apply rule 5 */
                 ;
in               : In                       /* Apply rule 6 */
                 ;
wordlist         : wordlist WORD
                 |          WORD
                 ;
case_clause      : Case WORD linebreak in linebreak case_list    Esac
                 | Case WORD linebreak in linebreak case_list_ns Esac
                 | Case WORD linebreak in linebreak              Esac
                 ;
case_list_ns     : case_list case_item_ns
                 |           case_item_ns
                 ;
case_list        : case_list case_item
                 |           case_item
                 ;
case_item_ns     :     pattern ')' linebreak
                 |     pattern ')' compound_list
                 | '(' pattern ')' linebreak
                 | '(' pattern ')' compound_list
                 ;
case_item        :     pattern ')' linebreak     DSEMI linebreak
                 |     pattern ')' compound_list DSEMI linebreak
                 | '(' pattern ')' linebreak     DSEMI linebreak
                 | '(' pattern ')' compound_list DSEMI linebreak
                 ;
pattern          :             WORD         /* Apply rule 4 */
                 | pattern '|' WORD         /* Do not apply rule 4 */
                 ;
if_clause        : If compound_list Then compound_list else_part Fi
                 | If compound_list Then compound_list           Fi
                 ;
else_part        : Elif compound_list Then compound_list
                 | Elif compound_list Then compound_list else_part
                 | Else compound_list
                 ;
while_clause     : While compound_list do_group
                 ;
until_clause     : Until compound_list do_group
                 ;
function_definition : fname '(' ')' linebreak function_body
                 ;
function_body    : compound_command                /* Apply rule 9 */
                 | compound_command redirect_list  /* Apply rule 9 */
                 ;
fname            : NAME                            /* Apply rule 8 */
                 ;
brace_group      : Lbrace compound_list Rbrace
                 ;
do_group         : Do compound_list Done           /* Apply rule 6 */
                 ;
simple_command   : cmd_prefix cmd_word cmd_suffix
                 | cmd_prefix cmd_word
                 | cmd_prefix
                 | cmd_name cmd_suffix
                 | cmd_name
                 ;
cmd_name         : WORD                   /* Apply rule 7a */
                 ;
cmd_word         : WORD                   /* Apply rule 7b */
                 ;
cmd_prefix       :            io_redirect
                 | cmd_prefix io_redirect
                 |            ASSIGNMENT_WORD
                 | cmd_prefix ASSIGNMENT_WORD
                 ;
cmd_suffix       :            io_redirect
                 | cmd_suffix io_redirect
                 |            WORD
                 | cmd_suffix WORD
                 ;
redirect_list    :               io_redirect
                 | redirect_list io_redirect
                 ;
io_redirect      :           io_file
                 | IO_NUMBER io_file
                 |           io_here
                 | IO_NUMBER io_here
                 ;
io_file          : '<'       filename
                 | LESSAND   filename
                 | '>'       filename
                 | GREATAND  filename
                 | DGREAT    filename
                 | LESSGREAT filename
                 | CLOBBER   filename
                 ;
filename         : WORD                      /* Apply rule 2 */
                 ;
io_here          : DLESS     here_end
                 | DLESSDASH here_end
                 ;
here_end         : WORD                      /* Apply rule 3 */
                 ;
newline_list     :              NEWLINE
                 | newline_list NEWLINE
                 ;
linebreak        : newline_list
                 | /* empty */
                 ;
separator_op     : '&'
                 | ';'
                 ;
separator        : separator_op linebreak
                 | newline_list
                 ;
sequential_sep   : ';' linebreak
                 | newline_list
                 ;

2.11. Signals and Error Handling
If job control is disabled (see the description of set -m) when the shell executes an asynchronous list, the commands in the list shall inherit from the shell a signal action of ignored (SIG_IGN) for the SIGINT and SIGQUIT signals. In all other cases, commands executed by the shell shall inherit the same signal actions as those inherited by the shell from its parent unless a signal action is modified by the trap special built-in (see trap)

When a signal for which a trap has been set is received while the shell is waiting for the completion of a utility executing a foreground command, the trap associated with that signal shall not be executed until after the foreground command has completed. When the shell is waiting, by means of the wait utility, for asynchronous commands to complete, the reception of a signal for which a trap has been set shall cause the wait utility to return immediately with an exit status >128, immediately after which the trap associated with that signal shall be taken.

If multiple signals are pending for the shell for which there are associated trap actions, the order of execution of trap actions is unspecified.

2.12. Shell Execution Environment
A shell execution environment consists of the following:

Open files inherited upon invocation of the shell, plus open files controlled by exec

Working directory as set by cd

File creation mask set by umask

[XSI] [Option Start] File size limit as set by ulimit [Option End]

Current traps set by trap

Shell parameters that are set by variable assignment (see the set special built-in) or from the System Interfaces volume of POSIX.1-2008 environment inherited by the shell when it begins (see the export special built-in)

Shell functions; see Function Definition Command

Options turned on at invocation or by set

Process IDs of the last commands in asynchronous lists known to this shell environment; see Asynchronous Lists

Shell aliases; see Alias Substitution

Utilities other than the special built-ins (see Special Built-In Utilities) shall be invoked in a separate environment that consists of the following. The initial value of these objects shall be the same as that for the parent shell, except as noted below.

Open files inherited on invocation of the shell, open files controlled by the exec special built-in plus any modifications, and additions specified by any redirections to the utility

Current working directory

File creation mask

If the utility is a shell script, traps caught by the shell shall be set to the default values and traps ignored by the shell shall be set to be ignored by the utility; if the utility is not a shell script, the trap actions (default or ignore) shall be mapped into the appropriate signal handling actions for the utility

Variables with the export attribute, along with those explicitly exported for the duration of the command, shall be passed to the utility environment variables

The environment of the shell process shall not be changed by the utility unless explicitly specified by the utility description (for example, cd and umask).

A subshell environment shall be created as a duplicate of the shell environment, except that signal traps that are not being ignored shall be set to the default action. Changes made to the subshell environment shall not affect the shell environment. Command substitution, commands that are grouped with parentheses, and asynchronous lists shall be executed in a subshell environment. Additionally, each command of a multi-command pipeline is in a subshell environment; as an extension, however, any or all commands in a pipeline may be executed in the current environment. All other commands shall be executed in the current shell environment.

2.13. Pattern Matching Notation
The pattern matching notation described in this section is used to specify patterns for matching strings in the shell. Historically, pattern matching notation is related to, but slightly different from, the regular expression notation described in XBD Regular Expressions. For this reason, the description of the rules for this pattern matching notation are based on the description of regular expression notation, modified to account for the differences.

2.13.1 Patterns Matching a Single Character
The following patterns matching a single character shall match a single character: ordinary characters, special pattern characters, and pattern bracket expressions. The pattern bracket expression also shall match a single collating element. A <backslash> character shall escape the following character. The escaping <backslash> shall be discarded. If a pattern ends with an unescaped <backslash>, it is unspecified whether the pattern does not match anything or the pattern is treated as invalid.

An ordinary character is a pattern that shall match itself. It can be any character in the supported character set except for NUL, those special shell characters in Quoting that require quoting, and the following three special pattern characters. Matching shall be based on the bit pattern used for encoding the character, not on the graphic representation of the character. If any character (ordinary, shell special, or pattern special) is quoted, that pattern shall match the character itself. The shell special characters always require quoting.

When unquoted and outside a bracket expression, the following three characters shall have special meaning in the specification of patterns:

?
A <question-mark> is a pattern that shall match any character.
*
An <asterisk> is a pattern that shall match multiple characters, as described in Patterns Matching Multiple Characters.
[
If an open bracket introduces a bracket expression as in XBD RE Bracket Expression, except that the <exclamation-mark> character ( '!' ) shall replace the <circumflex> character ( '^' ) in its role in a non-matching list in the regular expression notation, it shall introduce a pattern bracket expression. A bracket expression starting with an unquoted <circumflex> character produces unspecified results. Otherwise, '[' shall match the character itself.
When pattern matching is used where shell quote removal is not performed (such as in the argument to the find - name primary when find is being called using one of the exec functions as defined in the System Interfaces volume of POSIX.1-2008, or in the pattern argument to the fnmatch() function), special characters can be escaped to remove their special meaning by preceding them with a <backslash> character. This escaping <backslash> is discarded. The sequence "\\" represents one literal <backslash>. All of the requirements and effects of quoting on ordinary, shell special, and special pattern characters shall apply to escaping in this context.

2.13.2 Patterns Matching Multiple Characters
The following rules are used to construct patterns matching multiple characters from patterns matching a single character:

The <asterisk> ( '*' ) is a pattern that shall match any string, including the null string.

The concatenation of patterns matching a single character is a valid pattern that shall match the concatenation of the single characters or collating elements matched by each of the concatenated patterns.

The concatenation of one or more patterns matching a single character with one or more <asterisk> characters is a valid pattern. In such patterns, each <asterisk> shall match a string of zero or more characters, matching the greatest possible number of characters that still allows the remainder of the pattern to match the string.

2.13.3 Patterns Used for Filename Expansion
The rules described so far in Patterns Matching a Single Character and Patterns Matching Multiple Characters are qualified by the following rules that apply when pattern matching notation is used for filename expansion:

The <slash> character in a pathname shall be explicitly matched by using one or more <slash> characters in the pattern; it shall neither be matched by the <asterisk> or <question-mark> special characters nor by a bracket expression. <slash> characters in the pattern shall be identified before bracket expressions; thus, a <slash> cannot be included in a pattern bracket expression used for filename expansion. If a <slash> character is found following an unescaped <left-square-bracket> character before a corresponding <right-square-bracket> is found, the open bracket shall be treated as an ordinary character. For example, the pattern "a[b/c]d" does not match such pathnames as abd or a/d. It only matches a pathname of literally a[b/c]d.

If a filename begins with a <period> ( '.' ), the <period> shall be explicitly matched by using a <period> as the first character of the pattern or immediately following a <slash> character. The leading <period> shall not be matched by:

The <asterisk> or <question-mark> special characters

A bracket expression containing a non-matching list, such as "[!a]", a range expression, such as "[%-0]", or a character class expression, such as "[[:punct:]]"

It is unspecified whether an explicit <period> in a bracket expression matching list, such as "[.abc]", can match a leading <period> in a filename.

Specified patterns shall be matched against existing filenames and pathnames, as appropriate. Each component that contains a pattern character shall require read permission in the directory containing that component. Any component, except the last, that does not contain a pattern character shall require search permission. For example, given the pattern:

/foo/bar/x*/bam

search permission is needed for directories / and foo, search and read permissions are needed for directory bar, and search permission is needed for each x* directory. If the pattern matches any existing filenames or pathnames, the pattern shall be replaced with those filenames and pathnames, sorted according to the collating sequence in effect in the current locale. If this collating sequence does not have a total ordering of all characters (see XBD LC_COLLATE), any filenames or pathnames that collate equally should be further compared byte-by-byte using the collating sequence for the POSIX locale.

Note:
A future version of this standard may require the byte-by-byte further comparison described above.
If the pattern contains an open bracket ( '[' ) that does not introduce a bracket expression as in XBD RE Bracket Expression, it is unspecified whether other unquoted pattern matching characters within the same slash-delimited component of the pattern retain their special meanings or are treated as ordinary characters. For example, the pattern "a*[/b*" may match all filenames beginning with 'b' in the directory "a*[" or it may match all filenames beginning with 'b' in all directories with names beginning with 'a' and ending with '['.

If the pattern does not match any existing filenames or pathnames, the pattern string shall be left unchanged.

2.14. Special Built-In Utilities
The following "special built-in" utilities shall be supported in the shell command language. The output of each command, if any, shall be written to standard output, subject to the normal redirection and piping possible with all commands.

The term "built-in" implies that the shell can execute the utility directly and does not need to search for it. An implementation may choose to make any utility a built-in; however, the special built-in utilities described here differ from regular built-in utilities in two respects:

An error in a special built-in utility may cause a shell executing that utility to abort, while an error in a regular built-in utility shall not cause a shell executing that utility to abort. (See Consequences of Shell Errors for the consequences of errors on interactive and non-interactive shells.) If a special built-in utility encountering an error does not abort the shell, its exit value shall be non-zero.

As described in Simple Commands, variable assignments preceding the invocation of a special built-in utility remain in effect after the built-in completes; this shall not be the case with a regular built-in or other utility.

The special built-in utilities in this section need not be provided in a manner accessible via the exec family of functions defined in the System Interfaces volume of POSIX.1-2008.

Some of the special built-ins are described as conforming to XBD Utility Syntax Guidelines. For those that are not, the requirement in Utility Description Defaults that "--" be recognized as a first argument to be discarded does not apply and a conforming application shall not use that argument.

<<< Previous	Home	Next >>>
 

return to top of page
UNIX  is a registered Trademark of The Open Group.
POSIX  is a registered Trademark of The IEEE.
Copyright  2001-2016 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT ]
NAME
break - exit from for, while, or until loop
SYNOPSIS
break [n]

DESCRIPTION
If n is specified, the break utility shall exit from the nth enclosing for, while, or until loop. If n is not specified, break shall behave as if n was specified as 1. Execution shall continue with the command immediately following the exited loop. The value of n is a positive decimal integer. If n is greater than the number of enclosing loops, the outermost enclosing loop shall be exited. If there is no enclosing loop, the behavior is unspecified.

A loop shall enclose a break or continue command if the loop lexically encloses the command. A loop lexically encloses a break or continue command if the command is:

Executing in the same execution environment (see Shell Execution Environment) as the compound-list of the loop's do-group (see Shell Grammar Rules), and

Contained in a compound-list associated with the loop (either in the compound-list of the loop's do-group or, if the loop is a while or until loop, in the compound-list following the while or until reserved word), and

Not in the body of a function whose function definition command (see Function Definition Command) is contained in a compound-list associated with the loop.

If n is greater than the number of lexically enclosing loops and there is a non-lexically enclosing loop in progress in the same execution environment as the break or continue command, it is unspecified whether that loop encloses the command.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
Successful completion.
>0
The n value was not an unsigned decimal integer greater than or equal to 1.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
for i in *
do
    if test -d "$i"
    then break
    fi
done

The results of running the following example are unspecified: there are two loops in progress when the break command is executed, and they are in the same execution environment, but neither loop is lexically enclosing the break command. (There are no loops lexically enclosing the continue commands, either.)

foo() {
    for j in 1 2; do
        echo 'break 2' >/tmp/do_break
        echo "  sourcing /tmp/do_break ($j)..."
        # the behavior of the break from running the following command
        # results in unspecified behavior:
        . /tmp/do_break


        do_continue() { continue 2; }
        echo "  running do_continue ($j)..."
        # the behavior of the continue in the following function call
        # results in unspecified behavior (if execution reaches this
        # point):
        do_continue


        trap 'continue 2' USR1
        echo "  sending SIGUSR1 to self ($j)..."
        # the behavior of the continue in the trap invoked from the
        # following signal results in unspecified behavior (if
        # execution reaches this point):
        kill -s USR1 $$
        sleep 1
    done
}
for i in 1 2; do
    echo "running foo ($i)..."
    foo
done

RATIONALE
In early proposals, consideration was given to expanding the syntax of break and continue to refer to a label associated with the appropriate loop as a preferable alternative to the n method. However, this volume of POSIX.1-2008 does reserve the name space of command names ending with a <colon>. It is anticipated that a future implementation could take advantage of this and provide something like:

outofloop: for i in a b c d e
do
    for j in 0 1 2 3 4 5 6 7 8 9
    do
        if test -r "${i}${j}"
        then break outofloop
        fi
    done
done

and that this might be standardized after implementation experience is achieved.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0046 [842] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
colon - null utility
SYNOPSIS
: [argument...]

DESCRIPTION
This utility shall only expand command arguments. It is used when a command is needed, as in the then condition of an if command, but nothing is to be done by the command.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
Zero.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
: ${X=abc}
if     false
then   :
else   echo $X
fi
abc

As with any of the special built-ins, the null utility can also have variable assignments and redirections associated with it, such as:

x=y : > z

which sets variable x to the value y (so that it persists after the null utility completes) and creates or truncates file z.

RATIONALE
None.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

End of informative text.
<<< Previous	Home	Next >>>
NAME
continue - continue for, while, or until loop
SYNOPSIS
continue [n]

DESCRIPTION
If n is specified, the continue utility shall return to the top of the nth enclosing for, while, or until loop. If n is not specified, continue shall behave as if n was specified as 1. Returning to the top of the loop involves repeating the condition list of a while or until loop or performing the next assignment of a for loop, and re-executing the loop if appropriate.

The value of n is a positive decimal integer. If n is greater than the number of enclosing loops, the outermost enclosing loop shall be used. If there is no enclosing loop, the behavior is unspecified.

The meaning of "enclosing" shall be as specified in the description of the break utility.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
Successful completion.
>0
The n value was not an unsigned decimal integer greater than or equal to 1.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
for i in *
do
    if test -d "$i"
    then continue
    fi
    printf '"%s" is not a directory.\n' "$i"
done

RATIONALE
None.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
The example is changed to use the printf utility rather than echo.

POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0046 [842] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
dot - execute commands in the current environment
SYNOPSIS
. file

DESCRIPTION
The shell shall execute commands from the file in the current environment.

If file does not contain a <slash>, the shell shall use the search path specified by PATH to find the directory containing file. Unlike normal command search, however, the file searched for by the dot utility need not be executable. If no readable file is found, a non-interactive shell shall abort; an interactive shell shall write a diagnostic message to standard error, but this condition shall not be considered a syntax error.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
See the DESCRIPTION.

ENVIRONMENT VARIABLES
See the DESCRIPTION.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
If no readable file was found or if the commands in the file could not be parsed, and the shell is interactive (and therefore does not abort; see Consequences of Shell Errors), the exit status shall be non-zero. Otherwise, return the value of the last command executed, or a zero exit status if no command is executed.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
cat foobar
foo=hello bar=world
. ./foobar
echo $foo $bar
hello world

RATIONALE
Some older implementations searched the current directory for the file, even if the value of PATH disallowed it. This behavior was omitted from this volume of POSIX.1-2008 due to concerns about introducing the susceptibility to trojan horses that the user might be trying to avoid by leaving dot out of PATH.

The KornShell version of dot takes optional arguments that are set to the positional parameters. This is a valid extension that allows a dot script to behave identically to a function.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities, return

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-164 is applied.

POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0038 [114] and XCU/TC1-2008/0039 [214] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
eval - construct command by concatenating arguments
SYNOPSIS
eval [argument...]

DESCRIPTION
The eval utility shall construct a command by concatenating arguments together, separating each with a <space> character. The constructed command shall be read and executed by the shell.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
If there are no arguments, or only null arguments, eval shall return a zero exit status; otherwise, it shall return the exit status of the command defined by the string of concatenated arguments separated by <space> characters, or a non-zero exit status if the concatenation could not be parsed as a command and the shell is interactive (and therefore did not abort).

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
Since eval is not required to recognize the "--" end of options delimiter, in cases where the argument(s) to eval might begin with '-' it is recommended that the first argument is prefixed by a string that will not alter the commands to be executed, such as a <space> character:

eval " $commands"

or:

eval " $(some_command)"

EXAMPLES
foo=10 x=foo
y='$'$x
echo $y
$foo
eval y='$'$x
echo $y
10

RATIONALE
This standard allows, but does not require, eval to recognize "--". Although this means applications cannot use "--" to protect against options supported as an extension (or errors reported for unsupported options), the nature of the eval utility is such that other means can be used to provide this protection (see APPLICATION USAGE above).

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0040 [114], XCU/TC1-2008/0041 [163], and XCU/TC1-2008/0042 [163] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
exec - execute commands and open, close, or copy file descriptors
SYNOPSIS
exec [command [argument...]]

DESCRIPTION
The exec utility shall open, close, and/or copy file descriptors as specified by any redirections as part of the command.

If exec is specified without command or arguments, and any file descriptors with numbers greater than 2 are opened with associated redirection statements, it is unspecified whether those file descriptors remain open when the shell invokes another utility. Scripts concerned that child shells could misuse open file descriptors can always close them explicitly, as shown in one of the following examples.

If exec is specified with command, it shall replace the shell with command without creating a new process. If arguments are specified, they shall be arguments to command. Redirection affects the current shell execution environment.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
If command is specified, exec shall not return to the shell; rather, the exit status of the process shall be the exit status of the program implementing command, which overlaid the shell. If command is not found, the exit status shall be 127. If command is found, but it is not an executable utility, the exit status shall be 126. If a redirection error occurs (see Consequences of Shell Errors), the shell shall exit with a value in the range 1-125. Otherwise, exec shall return a zero exit status.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
Open readfile as file descriptor 3 for reading:

exec 3< readfile

Open writefile as file descriptor 4 for writing:

exec 4> writefile

Make file descriptor 5 a copy of file descriptor 0:

exec 5<&0

Close file descriptor 3:

exec 3<&-

Cat the file maggie by replacing the current shell with the cat utility:

exec cat maggie

RATIONALE
Most historical implementations were not conformant in that:

foo=bar exec cmd

did not pass foo to cmd.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

End of informative text.
<<< Previous	Home	Next >>>
NAME
exit - cause the shell to exit
SYNOPSIS
exit [n]

DESCRIPTION
The exit utility shall cause the shell to exit from its current execution environment with the exit status specified by the unsigned decimal integer n. If the current execution environment is a subshell environment, the shell shall exit from the subshell environment with the specified exit status and continue in the environment from which that subshell environment was invoked; otherwise, the shell utility shall terminate with the specified exit status. If n is specified, but its value is not between 0 and 255 inclusively, the exit status is undefined.

A trap on EXIT shall be executed before the shell terminates, except when the exit utility is invoked in that trap itself, in which case the shell shall exit immediately.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
The exit status shall be n, if specified, except that the behavior is unspecified if n is not an unsigned decimal integer or is greater than 255. Otherwise, the value shall be the exit value of the last command executed, or zero if no command was executed. When exit is executed in a trap action, the last command is considered to be the command that executed immediately preceding the trap action.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
Exit with a true value:

exit 0

Exit with a false value:

exit 1

Propagate error handling from within a subshell:

(
    command1 || exit 1
    command2 || exit 1
    exec command3
) > outputfile || exit 1
echo "outputfile created successfully"

RATIONALE
As explained in other sections, certain exit status values have been reserved for special uses and should be used by applications only for those purposes:

 126
A file to be executed was found, but it was not an executable utility.
 127
A utility to be executed was not found.
>128
A command was interrupted by a signal.
The behavior of exit when given an invalid argument or unknown option is unspecified, because of differing practices in the various historical implementations. A value larger than 255 might be truncated by the shell, and be unavailable even to a parent process that uses waitid() to get the full exit value. It is recommended that implementations that detect any usage error should cause a non-zero exit status (or, if the shell is interactive and the error does not cause the shell to abort, store a non-zero value in "$?" ), but even this was not done historically in all shells.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0047 [717], XCU/TC2-2008/0048 [960], XCU/TC2-2008/0049 [717], and XCU/TC2-2008/0050 [960] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
export - set the export attribute for variables
SYNOPSIS
export name[=word]...
 
export -p

DESCRIPTION
The shell shall give the export attribute to the variables corresponding to the specified names, which shall cause them to be in the environment of subsequently executed commands. If the name of a variable is followed by = word, then the value of that variable shall be set to word.

The export special built-in shall support XBD Utility Syntax Guidelines.

When -p is specified, export shall write to the standard output the names and values of all exported variables, in the following format:

"export %s=%s\n", <name>, <value>

if name is set, and:

"export %s\n", <name>

if name is unset.

The shell shall format the output, including the proper use of quoting, so that it is suitable for reinput to the shell as commands that achieve the same exporting results, except:

Read-only variables with values cannot be reset.

Variables that were unset at the time they were output need not be reset to the unset state if a value is assigned to the variable between the time the state was saved and the time at which the saved output is reinput to the shell.

When no arguments are given, the results are unspecified.

OPTIONS
See the DESCRIPTION.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
See the DESCRIPTION.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
All name operands were successfully exported.
>0
At least one name could not be exported, or the -p option was specified and an error occurred.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
Note that, unless X was previously marked readonly, the value of "$?" after:

export X=$(false)

will be 0 (because export successfully set X to the empty string) and that execution continues, even if set -e is in effect. In order to detect command substitution failures, a user must separate the assignment from the export, as in:

X=$(false)
export X

EXAMPLES
Export PWD and HOME variables:

export PWD HOME

Set and export the PATH variable:

export PATH=/local/bin:$PATH

Save and restore all exported variables:

export -p > temp-file
unset a lot of variables
... processing
. temp-file

RATIONALE
Some historical shells use the no-argument case as the functional equivalent of what is required here with -p. This feature was left unspecified because it is not historical practice in all shells, and some scripts may rely on the now-unspecified results on their implementations. Attempts to specify the -p output as the default case were unsuccessful in achieving consensus. The -p option was added to allow portable access to the values that can be saved and then later restored using; for example, a dot script.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

XBD Utility Syntax Guidelines

CHANGE HISTORY
Issue 6
IEEE PASC Interpretation 1003.2 #203 is applied, clarifying the format when a variable is unset.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/6 is applied, adding the following text to the end of the first paragraph of the DESCRIPTION: "If the name of a variable is followed by = word, then the value of that variable shall be set to word.". The reason for this change is that the SYNOPSIS for export includes:

export name[=word]...

but the meaning of the optional "= word" is never explained in the text.

Issue 7
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0043 [352] is applied.

POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0051 [654] and XCU/TC2-2008/0052 [960] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
readonly - set the readonly attribute for variables
SYNOPSIS
readonly name[=word]...
 
readonly -p

DESCRIPTION
The variables whose names are specified shall be given the readonly attribute. The values of variables with the readonly attribute cannot be changed by subsequent assignment, nor can those variables be unset by the unset utility. If the name of a variable is followed by = word, then the value of that variable shall be set to word.

The readonly special built-in shall support XBD Utility Syntax Guidelines.

When -p is specified, readonly writes to the standard output the names and values of all read-only variables, in the following format:

"readonly %s=%s\n", <name>, <value>

if name is set, and

"readonly %s\n", <name>

if name is unset.

The shell shall format the output, including the proper use of quoting, so that it is suitable for reinput to the shell as commands that achieve the same value and readonly attribute-setting results in a shell execution environment in which:

Variables with values at the time they were output do not have the readonly attribute set.

Variables that were unset at the time they were output do not have a value at the time at which the saved output is reinput to the shell.

When no arguments are given, the results are unspecified.

OPTIONS
See the DESCRIPTION.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
See the DESCRIPTION.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
All name operands were successfully marked readonly.
>0
At least one name could not be marked readonly, or the -p option was specified and an error occurred.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
readonly HOME PWD

RATIONALE
Some historical shells preserve the readonly attribute across separate invocations. This volume of POSIX.1-2008 allows this behavior, but does not require it.

The -p option allows portable access to the values that can be saved and then later restored using, for example, a dot script. Also see the RATIONALE for export for a description of the no-argument and -p output cases and a related example.

Read-only functions were considered, but they were omitted as not being historical practice or particularly useful. Furthermore, functions must not be read-only across invocations to preclude "spoofing" (spoofing is the term for the practice of creating a program that acts like a well-known utility with the intent of subverting the real intent of the user) of administrative or security-relevant (or security-conscious) shell scripts.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

XBD Utility Syntax Guidelines

CHANGE HISTORY
Issue 6
IEEE PASC Interpretation 1003.2 #203 is applied, clarifying the format when a variable is unset.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/7 is applied, adding the following text to the end of the first paragraph of the DESCRIPTION: "If the name of a variable is followed by = word, then the value of that variable shall be set to word.". The reason for this change is that the SYNOPSIS for readonly includes:
readonly name[=word]...

but the meaning of the optional "= word" is never explained in the text.

Issue 7
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0052 [960] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
return - return from a function or dot script
SYNOPSIS
return [n]

DESCRIPTION
The return utility shall cause the shell to stop executing the current function or dot script. If the shell is not currently executing a function or dot script, the results are unspecified.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
The value of the special parameter '?' shall be set to n, an unsigned decimal integer, or to the exit status of the last command executed if n is not specified. If n is not an unsigned decimal integer, or is greater than 255, the results are unspecified. When return is executed in a trap action, the last command is considered to be the command that executed immediately preceding the trap action.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
None.

RATIONALE
The behavior of return when not in a function or dot script differs between the System V shell and the KornShell. In the System V shell this is an error, whereas in the KornShell, the effect is the same as exit.

The results of returning a number greater than 255 are undefined because of differing practices in the various historical implementations. Some shells AND out all but the low-order 8 bits; others allow larger values, but not of unlimited size.

See the discussion of appropriate exit status values under exit.

FUTURE DIRECTIONS
None.

SEE ALSO
Function Definition Command, Special Built-In Utilities, dot

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0044 [214] and XCU/TC1-2008/0045 [214] are applied.

POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0052 [960] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
set - set or unset options and positional parameters
SYNOPSIS
set [-abCefhmnuvx] [-o option] [argument...]
 
set [+abCefhmnuvx] [+o option] [argument...]
 
set -- [argument...]
 
set -o
 
set +o

DESCRIPTION
If no options or arguments are specified, set shall write the names and values of all shell variables in the collation sequence of the current locale. Each name shall start on a separate line, using the format:

"%s=%s\n", <name>, <value>

The value string shall be written with appropriate quoting; see the description of shell quoting in Quoting. The output shall be suitable for reinput to the shell, setting or resetting, as far as possible, the variables that are currently set; read-only variables cannot be reset.

When options are specified, they shall set or unset attributes of the shell, as described below. When arguments are specified, they cause positional parameters to be set or unset, as described below. Setting or unsetting attributes and positional parameters are not necessarily related actions, but they can be combined in a single invocation of set.

The set special built-in shall support XBD Utility Syntax Guidelines except that options can be specified with either a leading <hyphen-minus> (meaning enable the option) or <plus-sign> (meaning disable it) unless otherwise specified.

Implementations shall support the options in the following list in both their <hyphen-minus> and <plus-sign> forms. These options can also be specified as options to sh.

-a
When this option is on, the export attribute shall be set for each variable to which an assignment is performed; see XBD Variable Assignment. If the assignment precedes a utility name in a command, the export attribute shall not persist in the current execution environment after the utility completes, with the exception that preceding one of the special built-in utilities causes the export attribute to persist after the built-in has completed. If the assignment does not precede a utility name in the command, or if the assignment is a result of the operation of the getopts or read utilities, the export attribute shall persist until the variable is unset.
-b
This option shall be supported if the implementation supports the User Portability Utilities option. It shall cause the shell to notify the user asynchronously of background job completions. The following message is written to standard error:
"[%d]%c %s%s\n", <job-number>, <current>, <status>, <job-name>

where the fields shall be as follows:

<current>
The character '+' identifies the job that would be used as a default for the fg or bg utilities; this job can also be specified using the job_id "%+" or "%%". The character '-' identifies the job that would become the default if the current default job were to exit; this job can also be specified using the job_id "%-". For other jobs, this field is a <space>. At most one job can be identified with '+' and at most one job can be identified with '-'. If there is any suspended job, then the current job shall be a suspended job. If there are at least two suspended jobs, then the previous job also shall be a suspended job.
<job-number>
A number that can be used to identify the process group to the wait, fg, bg, and kill utilities. Using these utilities, the job can be identified by prefixing the job number with '%'.
<status>
Unspecified.
<job-name>
Unspecified.
When the shell notifies the user a job has been completed, it may remove the job's process ID from the list of those known in the current shell execution environment; see Asynchronous Lists. Asynchronous notification shall not be enabled by default.

-C
(Uppercase C.) Prevent existing files from being overwritten by the shell's '>' redirection operator (see Redirecting Output); the ">|" redirection operator shall override this noclobber option for an individual file.
-e
When this option is on, when any command fails (for any of the reasons listed in Consequences of Shell Errors or by returning an exit status greater than zero), the shell immediately shall exit, as if by executing the exit special built-in utility with no arguments, with the following exceptions:
The failure of any individual command in a multi-command pipeline shall not cause the shell to exit. Only the failure of the pipeline itself shall be considered.

The -e setting shall be ignored when executing the compound list following the while, until, if, or elif reserved word, a pipeline beginning with the ! reserved word, or any command of an AND-OR list other than the last.

If the exit status of a compound command other than a subshell command was the result of a failure while -e was being ignored, then -e shall not apply to this command.

This requirement applies to the shell environment and each subshell environment separately. For example, in:

set -e; (false; echo one) | cat; echo two

the false command causes the subshell to exit without executing echo one; however, echo two is executed because the exit status of the pipeline (false; echo one) | cat is zero.

-f
The shell shall disable pathname expansion.
-h
Locate and remember utilities invoked by functions as those functions are defined (the utilities are normally located when the function is executed).
-m
This option shall be supported if the implementation supports the User Portability Utilities option. All jobs shall be run in their own process groups. Immediately before the shell issues a prompt after completion of the background job, a message reporting the exit status of the background job shall be written to standard error. If a foreground job stops, the shell shall write a message to standard error to that effect, formatted as described by the jobs utility. In addition, if a job changes status other than exiting (for example, if it stops for input or output or is stopped by a SIGSTOP signal), the shell shall write a similar message immediately prior to writing the next prompt. This option is enabled by default for interactive shells.
-n
The shell shall read commands but does not execute them; this can be used to check for shell script syntax errors. An interactive shell may ignore this option.
-o
Write the current settings of the options to standard output in an unspecified format.
+o
Write the current option settings to standard output in a format that is suitable for reinput to the shell as commands that achieve the same options settings.
-o  option
This option is supported if the system supports the User Portability Utilities option. It shall set various options, many of which shall be equivalent to the single option letters. The following values of option shall be supported:
allexport
Equivalent to -a.
errexit
Equivalent to -e.
ignoreeof
Prevent an interactive shell from exiting on end-of-file. This setting prevents accidental logouts when <control>-D is entered. A user shall explicitly exit to leave the interactive shell.
monitor
Equivalent to -m. This option is supported if the system supports the User Portability Utilities option.
noclobber
Equivalent to -C (uppercase C).
noglob
Equivalent to -f.
noexec
Equivalent to -n.
nolog
Prevent the entry of function definitions into the command history; see Command History List.
notify
Equivalent to -b.
nounset
Equivalent to -u.
verbose
Equivalent to -v.
vi
Allow shell command line editing using the built-in vi editor. Enabling vi mode shall disable any other command line editing mode provided as an implementation extension.
It need not be possible to set vi mode on for certain block-mode terminals.

xtrace
Equivalent to -x.
-u
When the shell tries to expand an unset parameter other than the '@' and '*' special parameters, it shall write a message to standard error and the expansion shall fail with the consequences specified in Consequences of Shell Errors.
-v
The shell shall write its input to standard error as it is read.
-x
The shell shall write to standard error a trace for each command after it expands the command and before it executes it. It is unspecified whether the command that turns tracing off is traced.
The default for all these options shall be off (unset) unless stated otherwise in the description of the option or unless the shell was invoked with them on; see sh.

The remaining arguments shall be assigned in order to the positional parameters. The special parameter '#' shall be set to reflect the number of positional parameters. All positional parameters shall be unset before any new values are assigned.

If the first argument is '-', the results are unspecified.

The special argument "--" immediately following the set command name can be used to delimit the arguments if the first argument begins with '+' or '-', or to prevent inadvertent listing of all shell variables when there are no arguments. The command set -- without argument shall unset all positional parameters and set the special parameter '#' to zero.

OPTIONS
See the DESCRIPTION.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
See the DESCRIPTION.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
Successful completion.
>0
An invalid option was specified, or an error occurred.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
Application writers should avoid relying on set -e within functions. For example, in the following script:

set -e
start() {
    some_server
    echo some_server started successfully
}
start || echo >&2 some_server failed

the -e setting is ignored within the function body (because the function is a command in an AND-OR list other than the last). Therefore, if some_server fails, the function carries on to echo "some_server started successfully", and the exit status of the function is zero (which means "some_server failed" is not output).

EXAMPLES
Write out all variables and their values:

set

Set $1, $2, and $3 and set "$#" to 3:

set c a b

Turn on the -x and -v options:

set -xv

Unset all positional parameters:

set --

Set $1 to the value of x, even if it begins with '-' or '+' :

set -- "$x"

Set the positional parameters to the expansion of x, even if x expands with a leading '-' or '+' :

set -- $x

RATIONALE
The set -- form is listed specifically in the SYNOPSIS even though this usage is implied by the Utility Syntax Guidelines. The explanation of this feature removes any ambiguity about whether the set -- form might be misinterpreted as being equivalent to set without any options or arguments. The functionality of this form has been adopted from the KornShell. In System V, set -- only unsets parameters if there is at least one argument; the only way to unset all parameters is to use shift. Using the KornShell version should not affect System V scripts because there should be no reason to issue it without arguments deliberately; if it were issued as, for example:

set -- "$@"

and there were in fact no arguments resulting from "$@", unsetting the parameters would have no result.

The set + form in early proposals was omitted as being an unnecessary duplication of set alone and not widespread historical practice.

The noclobber option was changed to allow set -C as well as the set -o noclobber option. The single-letter version was added so that the historical "$-" paradigm would not be broken; see Special Parameters.

The description of the -e option is intended to match the behavior of the 1988 version of the KornShell.

The -h flag is related to command name hashing. See hash.

The following set flags were omitted intentionally with the following rationale:

-k
The -k flag was originally added by the author of the Bourne shell to make it easier for users of pre-release versions of the shell. In early versions of the Bourne shell the construct set name= value had to be used to assign values to shell variables. The problem with -k is that the behavior affects parsing, virtually precluding writing any compilers. To explain the behavior of -k, it is necessary to describe the parsing algorithm, which is implementation-defined. For example:
set -k; echo name=value
and:

set -k
echo name=value
behave differently. The interaction with functions is even more complex. What is more, the -k flag is never needed, since the command line could have been reordered.

-t
The -t flag is hard to specify and almost never used. The only known use could be done with here-documents. Moreover, the behavior with ksh and sh differs. The reference page says that it exits after reading and executing one command. What is one command? If the input is date; date, sh executes both date commands while ksh does only the first.
Consideration was given to rewriting set to simplify its confusing syntax. A specific suggestion was that the unset utility should be used to unset options instead of using the non- getopt() -able + option syntax. However, the conclusion was reached that the historical practice of using + option was satisfactory and that there was no compelling reason to modify such widespread historical practice.

The -o option was adopted from the KornShell to address user needs. In addition to its generally friendly interface, -o is needed to provide the vi command line editing mode, for which historical practice yields no single-letter option name. (Although it might have been possible to invent such a letter, it was recognized that other editing modes would be developed and -o provides ample name space for describing such extensions.)

Historical implementations are inconsistent in the format used for -o option status reporting. The +o format without an option-argument was added to allow portable access to the options that can be saved and then later restored using, for instance, a dot script.

Historically, sh did trace the command set +x, but ksh did not.

The ignoreeof setting prevents accidental logouts when the end-of-file character (typically <control>-D) is entered. A user shall explicitly exit to leave the interactive shell.

The set -m option was added to apply only to the UPE because it applies primarily to interactive use, not shell script applications.

The ability to do asynchronous notification became available in the 1988 version of the KornShell. To have it occur, the user had to issue the command:

trap "jobs -n" CLD

The C shell provides two different levels of an asynchronous notification capability. The environment variable notify is analogous to what is done in set -b or set -o notify. When set, it notifies the user immediately of background job completions. When unset, this capability is turned off.

The other notification ability comes through the built-in utility notify. The syntax is:

notify [%job ... ]
By issuing notify with no operands, it causes the C shell to notify the user asynchronously when the state of the current job changes. If given operands, notify asynchronously informs the user of changes in the states of the specified jobs.

To add asynchronous notification to the POSIX shell, neither the KornShell extensions to trap, nor the C shell notify environment variable seemed appropriate (notify is not a proper POSIX environment variable name).

The set -b option was selected as a compromise.

The notify built-in was considered to have more functionality than was required for simple asynchronous notification.

Historically, some shells applied the -u option to all parameters including $@ and $*. The standard developers felt that this was a misfeature since it is normal and common for $@ and $* to be used in shell scripts regardless of whether they were passed any arguments. Treating these uses as an error when no arguments are passed reduces the value of -u for its intended purpose of finding spelling mistakes in variable names and uses of unset positional parameters.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities, hash

XBD Variable Assignment, Utility Syntax Guidelines

CHANGE HISTORY
Issue 6
The obsolescent set command name followed by '-' has been removed.

The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:

The nolog option is added to set -o.

IEEE PASC Interpretation 1003.2 #167 is applied, clarifying that the options default also takes into account the description of the option.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/8 is applied, changing the square brackets in the example in RATIONALE to be in bold, which is the typeface used for optional items.

Issue 7
Austin Group Interpretation 1003.1-2001 #027 is applied, clarifying the behavior if the first argument is '-'.

SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

XSI shading is removed from the -h functionality.

POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0046 [52], XCU/TC1-2008/0047 [155,280], XCU/TC1-2008/0048 [52], XCU/TC1-2008/0049 [52], and XCU/TC1-2008/0050 [155,430] are applied.

POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0053 [584], XCU/TC2-2008/0054 [717], XCU/TC2-2008/0055 [717], and XCU/TC2-2008/0056 [960] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
shift - shift positional parameters
SYNOPSIS
shift [n]

DESCRIPTION
The positional parameters shall be shifted. Positional parameter 1 shall be assigned the value of parameter (1+n), parameter 2 shall be assigned the value of parameter (2+n), and so on. The parameters represented by the numbers "$#" down to "$#-n+1" shall be unset, and the parameter '#' is updated to reflect the new number of positional parameters.

The value n shall be an unsigned decimal integer less than or equal to the value of the special parameter '#'. If n is not given, it shall be assumed to be 1. If n is 0, the positional and special parameters are not changed.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
If the n operand is invalid or is greater than "$#", this may be considered a syntax error and a non-interactive shell may exit; if the shell does not exit in this case, a non-zero exit status shall be returned. Otherwise, zero shall be returned.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
$ set a b c d e
$ shift 2
$ echo $*
c d e

RATIONALE
None.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0051 [459] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
times - write process times
SYNOPSIS
times

DESCRIPTION
The times utility shall write the accumulated user and system times for the shell and for all of its child processes, in the following POSIX locale format:

"%dm%fs %dm%fs\n%dm%fs %dm%fs\n", <shell user minutes>,
    <shell user seconds>, <shell system minutes>,
    <shell system seconds>, <children user minutes>,
    <children user seconds>, <children system minutes>,
    <children system seconds>

The four pairs of times shall correspond to the members of the <sys/times.h> tms structure (defined in XBD Headers) as returned by times(): tms_utime, tms_stime, tms_cutime, and tms_cstime, respectively.

OPTIONS
None.

OPERANDS
None.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
See the DESCRIPTION.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
$ times
0m0.43s 0m1.11s
8m44.18s 1m43.23s

RATIONALE
The times special built-in from the Single UNIX Specification is now required for all conforming shells.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

XBD <sys/times.h>

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/9 is applied, changing text in the DESCRIPTION from: "Write the accumulated user and system times for the shell and for all of its child processes ..." to: "The times utility shall write the accumulated user and system times for the shell and for all of its child processes ...".

Issue 7
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0056 [960] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
trap - trap signals
SYNOPSIS
trap n [condition...]trap [action condition...]

DESCRIPTION
If the first operand is an unsigned decimal integer, the shell shall treat all operands as conditions, and shall reset each condition to the default value. Otherwise, if there are operands, the first is treated as an action and the remaining as conditions.

If action is '-', the shell shall reset each condition to the default value. If action is null ( "" ), the shell shall ignore each specified condition if it arises. Otherwise, the argument action shall be read and executed by the shell when one of the corresponding conditions arises. The action of trap shall override a previous action (either default action or one explicitly set). The value of "$?" after the trap action completes shall be the value it had before trap was invoked.

The condition can be EXIT, 0 (equivalent to EXIT), or a signal specified using a symbolic name, without the SIG prefix, as listed in the tables of signal names in the <signal.h> header defined in XBD Headers; for example, HUP, INT, QUIT, TERM. Implementations may permit names with the SIG prefix or ignore case in signal names as an extension. Setting a trap for SIGKILL or SIGSTOP produces undefined results.

The environment in which the shell executes a trap on EXIT shall be identical to the environment immediately after the last command executed before the trap on EXIT was taken.

Each time trap is invoked, the action argument shall be processed in a manner equivalent to:

eval action
Signals that were ignored on entry to a non-interactive shell cannot be trapped or reset, although no error need be reported when attempting to do so. An interactive shell may reset or catch signals ignored on entry. Traps shall remain in place for a given shell until explicitly changed with another trap command.

When a subshell is entered, traps that are not being ignored shall be set to the default actions, except in the case of a command substitution containing only a single trap command, when the traps need not be altered. Implementations may check for this case using only lexical analysis; for example, if `trap` and $( trap -- ) do not alter the traps in the subshell, cases such as assigning var=trap and then using $($var) may still alter them. This does not imply that the trap command cannot be used within the subshell to set new traps.

The trap command with no operands shall write to standard output a list of commands associated with each condition. If the command is executed in a subshell, the implementation does not perform the optional check described above for a command substitution containing only a single trap command, and no trap commands with operands have been executed since entry to the subshell, the list shall contain the commands that were associated with each condition immediately before the subshell environment was entered. Otherwise, the list shall contain the commands currently associated with each condition. The format shall be:

"trap -- %s %s ...\n", <action>, <condition> ...

The shell shall format the output, including the proper use of quoting, so that it is suitable for reinput to the shell as commands that achieve the same trapping results. For example:

save_traps=$(trap)
...
eval "$save_traps"

[XSI] [Option Start] XSI-conformant systems also allow numeric signal numbers for the conditions corresponding to the following signal names:

1
SIGHUP
2
SIGINT
3
SIGQUIT
6
SIGABRT
9
SIGKILL
14
SIGALRM
15
SIGTERM
[Option End]
The trap special built-in shall conform to XBD Utility Syntax Guidelines.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
See the DESCRIPTION.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
If the trap name [XSI] [Option Start]  or number [Option End] is invalid, a non-zero exit status shall be returned; otherwise, zero shall be returned. For both interactive and non-interactive shells, invalid signal names [XSI] [Option Start]  or numbers [Option End] shall not be considered a syntax error and do not cause the shell to abort.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
Write out a list of all traps and actions:

trap

Set a trap so the logout utility in the directory referred to by the HOME environment variable executes when the shell terminates:

trap '"$HOME"/logout' EXIT

or:

trap '"$HOME"/logout' 0

Unset traps on INT, QUIT, TERM, and EXIT:

trap - INT QUIT TERM EXIT

RATIONALE
Implementations may permit lowercase signal names as an extension. Implementations may also accept the names with the SIG prefix; no known historical shell does so. The trap and kill utilities in this volume of POSIX.1-2008 are now consistent in their omission of the SIG prefix for signal names. Some kill implementations do not allow the prefix, and kill -l lists the signals without prefixes.

Trapping SIGKILL or SIGSTOP is syntactically accepted by some historical implementations, but it has no effect. Portable POSIX applications cannot attempt to trap these signals.

The output format is not historical practice. Since the output of historical trap commands is not portable (because numeric signal values are not portable) and had to change to become so, an opportunity was taken to format the output in a way that a shell script could use to save and then later reuse a trap if it wanted.

The KornShell uses an ERR trap that is triggered whenever set -e would cause an exit. This is allowable as an extension, but was not mandated, as other shells have not used it.

The text about the environment for the EXIT trap invalidates the behavior of some historical versions of interactive shells which, for example, close the standard input before executing a trap on 0. For example, in some historical interactive shell sessions the following trap on 0 would always print "--" :

trap 'read foo; echo "-$foo-"' 0

The command:

trap 'eval " $cmd"' 0

causes the contents of the shell variable cmd to be executed as a command when the shell exits. Using:

trap '$cmd' 0

does not work correctly if cmd contains any special characters such as quoting or redirections. Using:

trap " $cmd" 0

also works (the leading <space> character protects against unlikely cases where cmd is a decimal integer or begins with '-' ), but it expands the cmd variable when the trap command is executed, not when the exit action is executed.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

XBD Utility Syntax Guidelines, <signal.h>

CHANGE HISTORY
Issue 6
XSI-conforming implementations provide the mapping of signal names to numbers given above (previously this had been marked obsolescent). Other implementations need not provide this optional mapping.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

Austin Group Interpretation 1003.1-2001 #116 is applied.

POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0052 [53,268,440], XCU/TC1-2008/0053 [53,268,440], XCU/TC1-2008/0054 [163], XCU/TC1-2008/0055 [163], and XCU/TC1-2008/0056 [163] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
unset - unset values and attributes of variables and functions
SYNOPSIS
unset [-fv] name...

DESCRIPTION
Each variable or function specified by name shall be unset.

If -v is specified, name refers to a variable name and the shell shall unset it and remove it from the environment. Read-only variables cannot be unset.

If -f is specified, name refers to a function and the shell shall unset the function definition.

If neither -f nor -v is specified, name refers to a variable; if a variable by that name does not exist, it is unspecified whether a function by that name, if any, shall be unset.

Unsetting a variable or function that was not previously set shall not be considered an error and does not cause the shell to abort.

The unset special built-in shall support XBD Utility Syntax Guidelines.

Note that:

VARIABLE=

is not equivalent to an unset of VARIABLE; in the example, VARIABLE is set to "". Also, the variables that can be unset should not be misinterpreted to include the special parameters (see Special Parameters).

OPTIONS
See the DESCRIPTION.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
All name operands were successfully unset.
>0
At least one name could not be unset.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
Unset VISUAL variable:

unset -v VISUAL

Unset the functions foo and bar:

unset -f foo bar

RATIONALE
Consideration was given to omitting the -f option in favor of an unfunction utility, but the standard developers decided to retain historical practice.

The -v option was introduced because System V historically used one name space for both variables and functions. When unset is used without options, System V historically unset either a function or a variable, and there was no confusion about which one was intended. A portable POSIX application can use unset without an option to unset a variable, but not a function; the -f option must be used.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

XBD Utility Syntax Guidelines

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

End of informative text.
<<< Previous	Home	Next >>>

<<< Previous	Home	Next >>>
The Open Group Base Specifications Issue 7
IEEE Std 1003.1-2008, 2016 Edition
Copyright  2001-2016 The IEEE and The Open Group
2. Shell Command Language
This chapter contains the definition of the Shell Command Language.

2.1 Shell Introduction
The shell is a command language interpreter. This chapter describes the syntax of that command language as it is used by the sh utility and the system() and popen() functions defined in the System Interfaces volume of POSIX.1-2008.

The shell operates according to the following general overview of operations. The specific details are included in the cited sections of this chapter.

The shell reads its input from a file (see sh), from the -c option or from the system() and popen() functions defined in the System Interfaces volume of POSIX.1-2008. If the first line of a file of shell commands starts with the characters "#!", the results are unspecified.

The shell breaks the input into tokens: words and operators; see Token Recognition.

The shell parses the input into simple commands (see Simple Commands) and compound commands (see Compound Commands).

The shell performs various expansions (separately) on different parts of each command, resulting in a list of pathnames and fields to be treated as a command and arguments; see wordexp.

The shell performs redirection (see Redirection) and removes redirection operators and their operands from the parameter list.

The shell executes a function (see Function Definition Command), built-in (see Special Built-In Utilities), executable file, or script, giving the names of the arguments as positional parameters numbered 1 to n, and the name of the command (or in the case of a function within a script, the name of the script) as the positional parameter numbered 0 (see Command Search and Execution).

The shell optionally waits for the command to complete and collects the exit status (see Exit Status for Commands).

2.2 Quoting
Quoting is used to remove the special meaning of certain characters or words to the shell. Quoting can be used to preserve the literal meaning of the special characters in the next paragraph, prevent reserved words from being recognized as such, and prevent parameter expansion and command substitution within here-document processing (see Here-Document).

The application shall quote the following characters if they are to represent themselves:

|  &  ;  <  >  (  )  $  `  \  "  '  <space>  <tab>  <newline>

and the following may need to be quoted under certain circumstances. That is, these characters may be special depending on conditions described elsewhere in this volume of POSIX.1-2008:

*   ?   [   #      =   %

The various quoting mechanisms are the escape character, single-quotes, and double-quotes. The here-document represents another form of quoting; see Here-Document.

2.2.1 Escape Character (Backslash)
A <backslash> that is not quoted shall preserve the literal value of the following character, with the exception of a <newline>. If a <newline> follows the <backslash>, the shell shall interpret this as line continuation. The <backslash> and <newline> shall be removed before splitting the input into tokens. Since the escaped <newline> is removed entirely from the input and is not replaced by any white space, it cannot serve as a token separator.

2.2.2 Single-Quotes
Enclosing characters in single-quotes ( '' ) shall preserve the literal value of each character within the single-quotes. A single-quote cannot occur within single-quotes.

2.2.3 Double-Quotes
Enclosing characters in double-quotes ( "" ) shall preserve the literal value of all characters within the double-quotes, with the exception of the characters backquote, <dollar-sign>, and <backslash>, as follows:

$
The <dollar-sign> shall retain its special meaning introducing parameter expansion (see Parameter Expansion), a form of command substitution (see Command Substitution), and arithmetic expansion (see Arithmetic Expansion).
The input characters within the quoted string that are also enclosed between "$(" and the matching ')' shall not be affected by the double-quotes, but rather shall define that command whose output replaces the "$(...)" when the word is expanded. The tokenizing rules in Token Recognition, not including the alias substitutions in Alias Substitution, shall be applied recursively to find the matching ')'.

Within the string of characters from an enclosed "${" to the matching '}', an even number of unescaped double-quotes or single-quotes, if any, shall occur. A preceding <backslash> character shall be used to escape a literal '{' or '}'. The rule in Parameter Expansion shall be used to determine the matching '}'.

`
The backquote shall retain its special meaning introducing the other form of command substitution (see Command Substitution). The portion of the quoted string from the initial backquote and the characters up to the next backquote that is not preceded by a <backslash>, having escape characters removed, defines that command whose output replaces "`...`" when the word is expanded. Either of the following cases produces undefined results:
A single-quoted or double-quoted string that begins, but does not end, within the "`...`" sequence

A "`...`" sequence that begins, but does not end, within the same double-quoted string

\
The <backslash> shall retain its special meaning as an escape character (see Escape Character (Backslash)) only when followed by one of the following characters when considered special:
$   `   "   \   <newline>

The application shall ensure that a double-quote is preceded by a <backslash> to be included within double-quotes. The parameter '@' has special meaning inside double-quotes and is described in Special Parameters .

2.3 Token Recognition
The shell shall read its input in terms of lines. (For details about how the shell reads its input, see the description of sh.) The input lines can be of unlimited length. These lines shall be parsed using two major modes: ordinary token recognition and processing of here-documents.

When an io_here token has been recognized by the grammar (see Shell Grammar), one or more of the subsequent lines immediately following the next NEWLINE token form the body of one or more here-documents and shall be parsed according to the rules of Here-Document.

When it is not processing an io_here, the shell shall break its input into tokens by applying the first applicable rule below to the next character in its input. The token shall be from the current position in the input until a token is delimited according to one of the rules below; the characters forming the token are exactly those in the input, including any quoting characters. If it is indicated that a token is delimited, and no characters have been included in a token, processing shall continue until an actual token is delimited.

If the end of input is recognized, the current token (if any) shall be delimited.

If the previous character was used as part of an operator and the current character is not quoted and can be used with the previous characters to form an operator, it shall be used as part of that (operator) token.

If the previous character was used as part of an operator and the current character cannot be used with the previous characters to form an operator, the operator containing the previous character shall be delimited.

If the current character is <backslash>, single-quote, or double-quote and it is not quoted, it shall affect quoting for subsequent characters up to the end of the quoted text. The rules for quoting are as described in Quoting . During token recognition no substitutions shall be actually performed, and the result token shall contain exactly the characters that appear in the input (except for <newline> joining), unmodified, including any embedded or enclosing quotes or substitution operators, between the <quotation-mark> and the end of the quoted text. The token shall not be delimited by the end of the quoted field.

If the current character is an unquoted '$' or '`', the shell shall identify the start of any candidates for parameter expansion (Parameter Expansion), command substitution (Command Substitution), or arithmetic expansion (Arithmetic Expansion) from their introductory unquoted character sequences: '$' or "${", "$(" or '`', and "$((", respectively. The shell shall read sufficient input to determine the end of the unit to be expanded (as explained in the cited sections). While processing the characters, if instances of expansions or quoting are found nested within the substitution, the shell shall recursively process them in the manner specified for the construct that is found. The characters found from the beginning of the substitution to its end, allowing for any recursion necessary to recognize embedded constructs, shall be included unmodified in the result token, including any embedded or enclosing substitution operators or quotes. The token shall not be delimited by the end of the substitution.

If the current character is not quoted and can be used as the first character of a new operator, the current token (if any) shall be delimited. The current character shall be used as the beginning of the next (operator) token.

If the current character is an unquoted <blank>, any token containing the previous character is delimited and the current character shall be discarded.

If the previous character was part of a word, the current character shall be appended to that word.

If the current character is a '#', it and all subsequent characters up to, but excluding, the next <newline> shall be discarded as a comment. The <newline> that ends the line is not considered part of the comment.

The current character is used as the start of a new word.

Once a token is delimited, it is categorized as required by the grammar in Shell Grammar.

2.3.1 Alias Substitution
After a token has been delimited, but before applying the grammatical rules in Shell Grammar, a resulting word that is identified to be the command name word of a simple command shall be examined to determine whether it is an unquoted, valid alias name. However, reserved words in correct grammatical context shall not be candidates for alias substitution. A valid alias name (see XBD Alias Name) shall be one that has been defined by the alias utility and not subsequently undefined using unalias. Implementations also may provide predefined valid aliases that are in effect when the shell is invoked. To prevent infinite loops in recursive aliasing, if the shell is not currently processing an alias of the same name, the word shall be replaced by the value of the alias; otherwise, it shall not be replaced.

If the value of the alias replacing the word ends in a <blank>, the shell shall check the next command word for alias substitution; this process shall continue until a word is found that is not a valid alias or an alias value does not end in a <blank>.

When used as specified by this volume of POSIX.1-2008, alias definitions shall not be inherited by separate invocations of the shell or by the utility execution environments invoked by the shell; see Shell Execution Environment.

2.4 Reserved Words
Reserved words are words that have special meaning to the shell; see Shell Commands. The following words shall be recognized as reserved words:


!
{
}
case


do
done
elif
else


esac
fi
for
if


in
then
until
while

This recognition shall only occur when none of the characters is quoted and when the word is used as:

The first word of a command

The first word following one of the reserved words other than case, for, or in

The third word in a case command (only in is valid in this case)

The third word in a for command (only in and do are valid in this case)

See the grammar in Shell Grammar.

The following words may be recognized as reserved words on some implementations (when none of the characters are quoted), causing unspecified results:

[[

]]

function

select

Words that are the concatenation of a name and a <colon> ( ':' ) are reserved; their use produces unspecified results.

2.5 Parameters and Variables
A parameter can be denoted by a name, a number, or one of the special characters listed in Special Parameters. A variable is a parameter denoted by a name.

A parameter is set if it has an assigned value (null is a valid value). Once a variable is set, it can only be unset by using the unset special built-in command.

2.5.1 Positional Parameters
A positional parameter is a parameter denoted by the decimal value represented by one or more digits, other than the single digit 0. The digits denoting the positional parameters shall always be interpreted as a decimal value, even if there is a leading zero. When a positional parameter with more than one digit is specified, the application shall enclose the digits in braces (see Parameter Expansion). Positional parameters are initially assigned when the shell is invoked (see sh), temporarily replaced when a shell function is invoked (see Function Definition Command), and can be reassigned with the set special built-in command.

2.5.2 Special Parameters
Listed below are the special parameters and the values to which they shall expand. Only the values of the special parameters are listed; see wordexp for a detailed summary of all the stages involved in expanding words.

@
Expands to the positional parameters, starting from one, initially producing one field for each positional parameter that is set. When the expansion occurs in a context where field splitting will be performed, any empty fields may be discarded and each of the non-empty fields shall be further split as described in Field Splitting. When the expansion occurs within double-quotes, the behavior is unspecified unless one of the following is true:
Field splitting as described in Field Splitting would be performed if the expansion were not within double-quotes (regardless of whether field splitting would have any effect; for example, if IFS is null).

The double-quotes are within the word of a ${parameter:-word} or a ${parameter:+word} expansion (with or without the <colon>; see Parameter Expansion) which would have been subject to field splitting if parameter had been expanded instead of word.

If one of these conditions is true, the initial fields shall be retained as separate fields, except that if the parameter being expanded was embedded within a word, the first field shall be joined with the beginning part of the original word and the last field shall be joined with the end part of the original word. In all other contexts the results of the expansion are unspecified. If there are no positional parameters, the expansion of '@' shall generate zero fields, even when '@' is within double-quotes; however, if the expansion is embedded within a word which contains one or more other parts that expand to a quoted null string, these null string(s) shall still produce an empty field, except that if the other parts are all within the same double-quotes as the '@', it is unspecified whether the result is zero fields or one empty field.

*
Expands to the positional parameters, starting from one, initially producing one field for each positional parameter that is set. When the expansion occurs in a context where field splitting will be performed, any empty fields may be discarded and each of the non-empty fields shall be further split as described in Field Splitting. When the expansion occurs in a context where field splitting will not be performed, the initial fields shall be joined to form a single field with the value of each parameter separated by the first character of the IFS variable if IFS contains at least one character, or separated by a <space> if IFS is unset, or with no separation if IFS is set to a null string.
#
Expands to the decimal number of positional parameters. The command name (parameter 0) shall not be counted in the number given by '#' because it is a special parameter, not a positional parameter.
?
Expands to the decimal exit status of the most recent pipeline (see Pipelines).
-
(Hyphen.) Expands to the current option flags (the single-letter option names concatenated into a string) as specified on invocation, by the set special built-in command, or implicitly by the shell.
$
Expands to the decimal process ID of the invoked shell. In a subshell (see Shell Execution Environment ), '$' shall expand to the same value as that of the current shell.
!
Expands to the decimal process ID of the most recent background command (see Lists) executed from the current shell. (For example, background commands executed from subshells do not affect the value of "$!" in the current shell environment.) For a pipeline, the process ID is that of the last command in the pipeline.
0
(Zero.) Expands to the name of the shell or shell script. See sh for a detailed description of how this name is derived.
See the description of the IFS variable in Shell Variables.

2.5.3 Shell Variables
Variables shall be initialized from the environment (as defined by XBD Environment Variables and the exec function in the System Interfaces volume of POSIX.1-2008) and can be given new values with variable assignment commands. If a variable is initialized from the environment, it shall be marked for export immediately; see the export special built-in. New variables can be defined and initialized with variable assignments, with the read or getopts utilities, with the name parameter in a for loop, with the ${ name= word} expansion, or with other mechanisms provided as implementation extensions.
The following variables shall affect the execution of the shell:

ENV
[UP] [Option Start] The processing of the ENV shell variable shall be supported if the system supports the User Portability Utilities option. [Option End]
This variable, when and only when an interactive shell is invoked, shall be subjected to parameter expansion (see Parameter Expansion) by the shell and the resulting value shall be used as a pathname of a file containing shell commands to execute in the current environment. The file need not be executable. If the expanded value of ENV is not an absolute pathname, the results are unspecified. ENV shall be ignored if the user's real and effective user IDs or real and effective group IDs are different.

HOME
The pathname of the user's home directory. The contents of HOME are used in tilde expansion (see Tilde Expansion).
IFS
A string treated as a list of characters that is used for field splitting, expansion of the '*' special parameter, and to split lines into fields with the read utility. If the value of IFS includes any bytes that do not form part of a valid character, the results of field splitting, expansion of '*', and use of the read utility are unspecified.
If IFS is not set, it shall behave as normal for an unset variable, except that field splitting by the shell and line splitting by the read utility shall be performed as if the value of IFS is <space> <tab> <newline>; see Field Splitting.

The shell shall set IFS to <space> <tab> <newline> when it is invoked.

LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD Internationalization Variables for the precedence of internationalization variables used to determine the values of locale categories.)
LC_ALL
The value of this variable overrides the LC_* variables and LANG, as described in XBD Environment Variables.
LC_COLLATE
Determine the behavior of range expressions, equivalence classes, and multi-character collating elements within pattern matching.
LC_CTYPE
Determine the interpretation of sequences of bytes of text data as characters (for example, single-byte as opposed to multi-byte characters), which characters are defined as letters (character class alpha) and <blank> characters (character class blank), and the behavior of character classes within pattern matching. Changing the value of LC_CTYPE after the shell has started shall not affect the lexical processing of shell commands in the current shell execution environment or its subshells. Invoking a shell script or performing exec sh subjects the new shell to the changes in LC_CTYPE.
LC_MESSAGES
Determine the language in which messages should be written.
LINENO
Set by the shell to a decimal number representing the current sequential line number (numbered starting with 1) within a script or function before it executes each command. If the user unsets or resets LINENO, the variable may lose its special meaning for the life of the shell. If the shell is not currently executing a script or function, the value of LINENO is unspecified. This volume of POSIX.1-2008 specifies the effects of the variable only for systems supporting the User Portability Utilities option.
NLSPATH
[XSI] [Option Start] Determine the location of message catalogs for the processing of LC_MESSAGES. [Option End]
PATH
A string formatted as described in XBD Environment Variables, used to effect command interpretation; see Command Search and Execution.
PPID
Set by the shell to the decimal value of its parent process ID during initialization of the shell. In a subshell (see Shell Execution Environment), PPID shall be set to the same value as that of the parent of the current shell. For example, echo $ PPID and (echo $ PPID) would produce the same value.
PS1
Each time an interactive shell is ready to read a command, the value of this variable shall be subjected to parameter expansion and written to standard error. The default value shall be "$ ". For users who have specific additional implementation-defined privileges, the default may be another, implementation-defined value. The shell shall replace each instance of the character '!' in PS1 with the history file number of the next command to be typed. Escaping the '!' with another '!' (that is, "!!" ) shall place the literal character '!' in the prompt. This volume of POSIX.1-2008 specifies the effects of the variable only for systems supporting the User Portability Utilities option.
PS2
Each time the user enters a <newline> prior to completing a command line in an interactive shell, the value of this variable shall be subjected to parameter expansion and written to standard error. The default value is "> ". This volume of POSIX.1-2008 specifies the effects of the variable only for systems supporting the User Portability Utilities option.
PS4
When an execution trace (set -x) is being performed in an interactive shell, before each line in the execution trace, the value of this variable shall be subjected to parameter expansion and written to standard error. The default value is "+ ". This volume of POSIX.1-2008 specifies the effects of the variable only for systems supporting the User Portability Utilities option.
PWD
Set by the shell and by the cd utility. In the shell the value shall be initialized from the environment as follows. If a value for PWD is passed to the shell in the environment when it is executed, the value is an absolute pathname of the current working directory that is no longer than {PATH_MAX} bytes including the terminating null byte, and the value does not contain any components that are dot or dot-dot, then the shell shall set PWD to the value from the environment. Otherwise, if a value for PWD is passed to the shell in the environment when it is executed, the value is an absolute pathname of the current working directory, and the value does not contain any components that are dot or dot-dot, then it is unspecified whether the shell sets PWD to the value from the environment or sets PWD to the pathname that would be output by pwd -P. Otherwise, the sh utility sets PWD to the pathname that would be output by pwd -P. In cases where PWD is set to the value from the environment, the value can contain components that refer to files of type symbolic link. In cases where PWD is set to the pathname that would be output by pwd -P, if there is insufficient permission on the current working directory, or on any parent of that directory, to determine what that pathname would be, the value of PWD is unspecified. Assignments to this variable may be ignored. If an application sets or unsets the value of PWD, the behaviors of the cd and pwd utilities are unspecified.
2.6 Word Expansions
This section describes the various expansions that are performed on words. Not all expansions are performed on every word, as explained in the following sections.

Tilde expansions, parameter expansions, command substitutions, arithmetic expansions, and quote removals that occur within a single word expand to a single field. It is only field splitting or pathname expansion that can create multiple fields from a single word. The single exception to this rule is the expansion of the special parameter '@' within double-quotes, as described in Special Parameters.

The order of word expansion shall be as follows:

Tilde expansion (see Tilde Expansion), parameter expansion (see Parameter Expansion), command substitution (see Command Substitution), and arithmetic expansion (see Arithmetic Expansion) shall be performed, beginning to end. See item 5 in Token Recognition.

Field splitting (see Field Splitting) shall be performed on the portions of the fields generated by step 1, unless IFS is null.

Pathname expansion (see Pathname Expansion) shall be performed, unless set -f is in effect.

Quote removal (see Quote Removal) shall always be performed last.

The expansions described in this section shall occur in the same shell environment as that in which the command is executed.

If the complete expansion appropriate for a word results in an empty field, that empty field shall be deleted from the list of fields that form the completely expanded command, unless the original word contained single-quote or double-quote characters.

The '$' character is used to introduce parameter expansion, command substitution, or arithmetic evaluation. If an unquoted '$' is followed by a character that is not one of the following:

A numeric character

The name of one of the special parameters (see Special Parameters)

A valid first character of a variable name

A <left-curly-bracket> ( '{' )

A <left-parenthesis>

the result is unspecified.

2.6.1 Tilde Expansion
A "tilde-prefix" consists of an unquoted <tilde> character at the beginning of a word, followed by all of the characters preceding the first unquoted <slash> in the word, or all the characters in the word if there is no <slash>. In an assignment (see XBD Variable Assignment), multiple tilde-prefixes can be used: at the beginning of the word (that is, following the <equals-sign> of the assignment), following any unquoted <colon>, or both. A tilde-prefix in an assignment is terminated by the first unquoted <colon> or <slash>. If none of the characters in the tilde-prefix are quoted, the characters in the tilde-prefix following the <tilde> are treated as a possible login name from the user database. A portable login name cannot contain characters outside the set given in the description of the LOGNAME environment variable in XBD Other Environment Variables. If the login name is null (that is, the tilde-prefix contains only the tilde), the tilde-prefix is replaced by the value of the variable HOME. If HOME is unset, the results are unspecified. Otherwise, the tilde-prefix shall be replaced by a pathname of the initial working directory associated with the login name obtained using the getpwnam() function as defined in the System Interfaces volume of POSIX.1-2008. If the system does not recognize the login name, the results are undefined.

The pathname resulting from tilde expansion shall be treated as if quoted to prevent it being altered by field splitting and pathname expansion.

2.6.2 Parameter Expansion
The format for parameter expansion is as follows:

${expression}

where expression consists of all characters until the matching '}'. Any '}' escaped by a <backslash> or within a quoted string, and characters in embedded arithmetic expansions, command substitutions, and variable expansions, shall not be examined in determining the matching '}'.

The simplest form for parameter expansion is:

${parameter}

The value, if any, of parameter shall be substituted.

The parameter name or symbol can be enclosed in braces, which are optional except for positional parameters with more than one digit or when parameter is a name and is followed by a character that could be interpreted as part of the name. The matching closing brace shall be determined by counting brace levels, skipping over enclosed quoted strings, and command substitutions.

If the parameter is not enclosed in braces, and is a name, the expansion shall use the longest valid name (see XBD Name), whether or not the variable represented by that name exists. Otherwise, the parameter is a single-character symbol, and behavior is unspecified if that character is neither a digit nor one of the special parameters (see Special Parameters).

If a parameter expansion occurs inside double-quotes:

Pathname expansion shall not be performed on the results of the expansion.

Field splitting shall not be performed on the results of the expansion.

In addition, a parameter expansion can be modified by using one of the following formats. In each case that a value of word is needed (based on the state of parameter, as described below), word shall be subjected to tilde expansion, parameter expansion, command substitution, and arithmetic expansion. If word is not needed, it shall not be expanded. The '}' character that delimits the following parameter expansion modifications shall be determined as described previously in this section and in Double-Quotes.

${parameter:-[word]}
Use Default Values. If parameter is unset or null, the expansion of word (or an empty string if word is omitted) shall be substituted; otherwise, the value of parameter shall be substituted.
${parameter:=[word]}
Assign Default Values. If parameter is unset or null, the expansion of word (or an empty string if word is omitted) shall be assigned to parameter. In all cases, the final value of parameter shall be substituted. Only variables, not positional parameters or special parameters, can be assigned in this way.
${parameter:?[word]}
Indicate Error if Null or Unset. If parameter is unset or null, the expansion of word (or a message indicating it is unset if word is omitted) shall be written to standard error and the shell exits with a non-zero exit status. Otherwise, the value of parameter shall be substituted. An interactive shell need not exit.
${parameter:+[word]}
Use Alternative Value. If parameter is unset or null, null shall be substituted; otherwise, the expansion of word (or an empty string if word is omitted) shall be substituted.
In the parameter expansions shown previously, use of the <colon> in the format shall result in a test for a parameter that is unset or null; omission of the <colon> shall result in a test for a parameter that is only unset. If parameter is '#' and the colon is omitted, the application shall ensure that word is specified (this is necessary to avoid ambiguity with the string length expansion). The following table summarizes the effect of the <colon>:

 

parameter
Set and Not Null

parameter
Set But Null

parameter
Unset

${parameter:-word}

substitute parameter

substitute word

substitute word

${parameter-word}

substitute parameter

substitute null

substitute word

${parameter:=word}

substitute parameter

assign word

assign word

${parameter=word}

substitute parameter

substitute null

assign word

${parameter:?word}

substitute parameter

error, exit

error, exit

${parameter?word}

substitute parameter

substitute null

error, exit

${parameter:+word}

substitute word

substitute null

substitute null

${parameter+word}

substitute word

substitute word

substitute null

In all cases shown with "substitute", the expression is replaced with the value shown. In all cases shown with "assign", parameter is assigned that value, which also replaces the expression.

${#parameter}
String Length. The length in characters of the value of parameter shall be substituted. If parameter is '*' or '@', the result of the expansion is unspecified. If parameter is unset and set -u is in effect, the expansion shall fail.
The following four varieties of parameter expansion provide for substring processing. In each case, pattern matching notation (see Pattern Matching Notation), rather than regular expression notation, shall be used to evaluate the patterns. If parameter is '#', '*', or '@', the result of the expansion is unspecified. If parameter is unset and set -u is in effect, the expansion shall fail. Enclosing the full parameter expansion string in double-quotes shall not cause the following four varieties of pattern characters to be quoted, whereas quoting characters within the braces shall have this effect. In each variety, if word is omitted, the empty pattern shall be used.

${parameter%[word]}
Remove Smallest Suffix Pattern. The word shall be expanded to produce a pattern. The parameter expansion shall then result in parameter, with the smallest portion of the suffix matched by the pattern deleted. If present, word shall not begin with an unquoted '%'.
${parameter%%[word]}
Remove Largest Suffix Pattern. The word shall be expanded to produce a pattern. The parameter expansion shall then result in parameter, with the largest portion of the suffix matched by the pattern deleted.
${parameter#[word]}
Remove Smallest Prefix Pattern. The word shall be expanded to produce a pattern. The parameter expansion shall then result in parameter, with the smallest portion of the prefix matched by the pattern deleted. If present, word shall not begin with an unquoted '#'.
${parameter##[word]}
Remove Largest Prefix Pattern. The word shall be expanded to produce a pattern. The parameter expansion shall then result in parameter, with the largest portion of the prefix matched by the pattern deleted.
The following sections are informative.
Examples
${parameter}
In this example, the effects of omitting braces are demonstrated.
a=1
set 2
echo ${a}b-$ab-${1}0-${10}-$10
1b--20--20
${parameter-word}
This example demonstrates the difference between unset and set to the empty string, as well as the rules for finding the delimiting close brace.
foo=asdf
echo ${foo-bar}xyz}
asdfxyz}foo=
echo ${foo-bar}xyz}
xyz}unset foo
echo ${foo-bar}xyz}
barxyz}
${parameter:-word}
In this example, ls is executed only if x is null or unset. (The $(ls) command substitution notation is explained in Command Substitution.)
${x:-$(ls)}

${parameter:=word}
unset X
echo ${X:=abc}
abc
${parameter:?word}
unset posix
echo ${posix:?}
sh: posix: parameter null or not set
${parameter:+word}
set a b c
echo ${3:+posix}
posix
${#parameter}
HOME=/usr/posix
echo ${#HOME}
10
${parameter%word}
x=file.c
echo ${x%.c}.o
file.o
${parameter%%word}
x=posix/src/std
echo ${x%%/*}
posix
${parameter#word}
x=$HOME/src/cmd
echo ${x#$HOME}
/src/cmd
${parameter##word}
x=/one/two/three
echo ${x##*/}
three
The double-quoting of patterns is different depending on where the double-quotes are placed:

"${x#*}"
The <asterisk> is a pattern character.
${x#"*"}
The literal <asterisk> is quoted and not special.
End of informative text.
2.6.3 Command Substitution
Command substitution allows the output of a command to be substituted in place of the command name itself. Command substitution shall occur when the command is enclosed as follows:

$(command)

or (backquoted version):

`command`

The shell shall expand the command substitution by executing command in a subshell environment (see Shell Execution Environment) and replacing the command substitution (the text of command plus the enclosing "$()" or backquotes) with the standard output of the command, removing sequences of one or more <newline> characters at the end of the substitution. Embedded <newline> characters before the end of the output shall not be removed; however, they may be treated as field delimiters and eliminated during field splitting, depending on the value of IFS and quoting that is in effect. If the output contains any null bytes, the behavior is unspecified.

Within the backquoted style of command substitution, <backslash> shall retain its literal meaning, except when followed by: '$', '`', or <backslash>. The search for the matching backquote shall be satisfied by the first unquoted non-escaped backquote; during this search, if a non-escaped backquote is encountered within a shell comment, a here-document, an embedded command substitution of the $(command) form, or a quoted string, undefined results occur. A single-quoted or double-quoted string that begins, but does not end, within the "`...`" sequence produces undefined results.

With the $(command) form, all characters following the open parenthesis to the matching closing parenthesis constitute the command. Any valid shell script can be used for command, except a script consisting solely of redirections which produces unspecified results.

The results of command substitution shall not be processed for further tilde expansion, parameter expansion, command substitution, or arithmetic expansion. If a command substitution occurs inside double-quotes, field splitting and pathname expansion shall not be performed on the results of the substitution.

Command substitution can be nested. To specify nesting within the backquoted version, the application shall precede the inner backquotes with <backslash> characters; for example:

\`command\`

The syntax of the shell command language has an ambiguity for expansions beginning with "$((", which can introduce an arithmetic expansion or a command substitution that starts with a subshell. Arithmetic expansion has precedence; that is, the shell shall first determine whether it can parse the expansion as an arithmetic expansion and shall only parse the expansion as a command substitution if it determines that it cannot parse the expansion as an arithmetic expansion. The shell need not evaluate nested expansions when performing this determination. If it encounters the end of input without already having determined that it cannot parse the expansion as an arithmetic expansion, the shell shall treat the expansion as an incomplete arithmetic expansion and report a syntax error. A conforming application shall ensure that it separates the "$(" and '(' into two tokens (that is, separate them with white space) in a command substitution that starts with a subshell. For example, a command substitution containing a single subshell could be written as:

$( (command) )

2.6.4 Arithmetic Expansion
Arithmetic expansion provides a mechanism for evaluating an arithmetic expression and substituting its value. The format for arithmetic expansion shall be as follows:

$((expression))

The expression shall be treated as if it were in double-quotes, except that a double-quote inside the expression is not treated specially. The shell shall expand all tokens in the expression for parameter expansion, command substitution, and quote removal.

Next, the shell shall treat this as an arithmetic expression and substitute the value of the expression. The arithmetic expression shall be processed according to the rules given in Arithmetic Precision and Operations, with the following exceptions:

Only signed long integer arithmetic is required.

Only the decimal-constant, octal-constant, and hexadecimal-constant constants specified in the ISO C standard, Section 6.4.4.1 are required to be recognized as constants.

The sizeof() operator and the prefix and postfix "++" and "--" operators are not required.

Selection, iteration, and jump statements are not supported.

All changes to variables in an arithmetic expression shall be in effect after the arithmetic expansion, as in the parameter expansion "${x=value}".

If the shell variable x contains a value that forms a valid integer constant, optionally including a leading <plus-sign> or <hyphen-minus>, then the arithmetic expansions "$((x))" and "$(($x))" shall return the same value.

As an extension, the shell may recognize arithmetic expressions beyond those listed. The shell may use a signed integer type with a rank larger than the rank of signed long. The shell may use a real-floating type instead of signed long as long as it does not affect the results in cases where there is no overflow. If the expression is invalid, or the contents of a shell variable used in the expression are not recognized by the shell, the expansion fails and the shell shall write a diagnostic message to standard error indicating the failure.

The following sections are informative.
Examples
A simple example using arithmetic expansion:

# repeat a command 100 times
x=100
while [ $x -gt 0 ]
do
    command    x=$(($x-1))
done

End of informative text.
2.6.5 Field Splitting
After parameter expansion (Parameter Expansion), command substitution (Command Substitution), and arithmetic expansion (Arithmetic Expansion), the shell shall scan the results of expansions and substitutions that did not occur in double-quotes for field splitting and multiple fields can result.

The shell shall treat each character of the IFS as a delimiter and use the delimiters as field terminators to split the results of parameter expansion, command substitution, and arithmetic expansion into fields.

If the value of IFS is a <space>, <tab>, and <newline>, or if it is unset, any sequence of <space>, <tab>, or <newline> characters at the beginning or end of the input shall be ignored and any sequence of those characters within the input shall delimit a field. For example, the input:

<newline><space><tab>foo<tab><tab>bar<space>

yields two fields, foo and bar.

If the value of IFS is null, no field splitting shall be performed.

Otherwise, the following rules shall be applied in sequence. The term " IFS white space" is used to mean any sequence (zero or more instances) of white-space characters that are in the IFS value (for example, if IFS contains <space>/ <comma>/ <tab>, any sequence of <space> and <tab> characters is considered IFS white space).

IFS white space shall be ignored at the beginning and end of the input.

Each occurrence in the input of an IFS character that is not IFS white space, along with any adjacent IFS white space, shall delimit a field, as described previously.

Non-zero-length IFS white space shall delimit a field.

2.6.6 Pathname Expansion
After field splitting, if set -f is not in effect, each field in the resulting command line shall be expanded using the algorithm described in Pattern Matching Notation, qualified by the rules in Patterns Used for Filename Expansion.

2.6.7 Quote Removal
The quote characters ( <backslash>, single-quote, and double-quote) that were present in the original word shall be removed unless they have themselves been quoted.

2.7 Redirection
Redirection is used to open and close files for the current shell execution environment (see Shell Execution Environment) or for any command. Redirection operators can be used with numbers representing file descriptors (see XBD File Descriptor) as described below.

The overall format used for redirection is:

[n]redir-op word
The number n is an optional decimal number designating the file descriptor number; the application shall ensure it is delimited from any preceding text and immediately precede the redirection operator redir-op. If n is quoted, the number shall not be recognized as part of the redirection expression. For example:

echo \2>a

writes the character 2 into file a. If any part of redir-op is quoted, no redirection expression is recognized. For example:

echo 2\>a

writes the characters 2>a to standard output. The optional number, redirection operator, and word shall not appear in the arguments provided to the command to be executed (if any).

Open files are represented by decimal numbers starting with zero. The largest possible value is implementation-defined; however, all implementations shall support at least 0 to 9, inclusive, for use by the application. These numbers are called "file descriptors". The values 0, 1, and 2 have special meaning and conventional uses and are implied by certain redirection operations; they are referred to as standard input, standard output, and standard error, respectively. Programs usually take their input from standard input, and write output on standard output. Error messages are usually written on standard error. The redirection operators can be preceded by one or more digits (with no intervening <blank> characters allowed) to designate the file descriptor number.

If the redirection operator is "<<" or "<<-", the word that follows the redirection operator shall be subjected to quote removal; it is unspecified whether any of the other expansions occur. For the other redirection operators, the word that follows the redirection operator shall be subjected to tilde expansion, parameter expansion, command substitution, arithmetic expansion, and quote removal. Pathname expansion shall not be performed on the word by a non-interactive shell; an interactive shell may perform it, but shall do so only when the expansion would result in one word.

If more than one redirection operator is specified with a command, the order of evaluation is from beginning to end.

A failure to open or create a file shall cause a redirection to fail.

2.7.1 Redirecting Input
Input redirection shall cause the file whose name results from the expansion of word to be opened for reading on the designated file descriptor, or standard input if the file descriptor is not specified.

The general format for redirecting input is:

[n]<word
where the optional n represents the file descriptor number. If the number is omitted, the redirection shall refer to standard input (file descriptor 0).

2.7.2 Redirecting Output
The two general formats for redirecting output are:

[n]>word
[n]>|word
where the optional n represents the file descriptor number. If the number is omitted, the redirection shall refer to standard output (file descriptor 1).

Output redirection using the '>' format shall fail if the noclobber option is set (see the description of set -C) and the file named by the expansion of word exists and is a regular file. Otherwise, redirection using the '>' or ">|" formats shall cause the file whose name results from the expansion of word to be created and opened for output on the designated file descriptor, or standard output if none is specified. If the file does not exist, it shall be created; otherwise, it shall be truncated to be an empty file after being opened.

2.7.3 Appending Redirected Output
Appended output redirection shall cause the file whose name results from the expansion of word to be opened for output on the designated file descriptor. The file is opened as if the open() function as defined in the System Interfaces volume of POSIX.1-2008 was called with the O_APPEND flag. If the file does not exist, it shall be created.

The general format for appending redirected output is as follows:

[n]>>word
where the optional n represents the file descriptor number. If the number is omitted, the redirection refers to standard output (file descriptor 1).

2.7.4 Here-Document
The redirection operators "<<" and "<<-" both allow redirection of subsequent lines read by the shell to the input of a command. The redirected lines are known as a "here-document".

The here-document shall be treated as a single word that begins after the next <newline> and continues until there is a line containing only the delimiter and a <newline>, with no <blank> characters in between. Then the next here-document starts, if there is one. The format is as follows:

[n]<<word
    here-document
delimiter
where the optional n represents the file descriptor number. If the number is omitted, the here-document refers to standard input (file descriptor 0). It is unspecified whether the file descriptor is opened as a regular file, a special file, or a pipe. Portable applications cannot rely on the file descriptor being seekable (see XSH lseek).

If any part of word is quoted, the delimiter shall be formed by performing quote removal on word, and the here-document lines shall not be expanded. Otherwise, the delimiter shall be the word itself.

If no part of word is quoted, all lines of the here-document shall be expanded for parameter expansion, command substitution, and arithmetic expansion. In this case, the <backslash> in the input behaves as the <backslash> inside double-quotes (see Double-Quotes). However, the double-quote character ( ' )' shall not be treated specially within a here-document, except when the double-quote appears within "$()", "``", or "${}".

If the redirection operator is "<<-", all leading <tab> characters shall be stripped from input lines and the line containing the trailing delimiter. If more than one "<<" or "<<-" operator is specified on a line, the here-document associated with the first operator shall be supplied first by the application and shall be read first by the shell.

When a here-document is read from a terminal device and the shell is interactive, it shall write the contents of the variable PS2, processed as described in Shell Variables, to standard error before reading each line of input until the delimiter has been recognized.

The following sections are informative.
Examples
An example of a here-document follows:

cat <<eof1; cat <<eof2
Hi,
eof1
Helene.
eof2

End of informative text.
2.7.5 Duplicating an Input File Descriptor
The redirection operator:

[n]<&word
shall duplicate one input file descriptor from another, or shall close one. If word evaluates to one or more digits, the file descriptor denoted by n, or standard input if n is not specified, shall be made to be a copy of the file descriptor denoted by word; if the digits in word do not represent a file descriptor already open for input, a redirection error shall result; see Consequences of Shell Errors. If word evaluates to '-', file descriptor n, or standard input if n is not specified, shall be closed. Attempts to close a file descriptor that is not open shall not constitute an error. If word evaluates to something else, the behavior is unspecified.

2.7.6 Duplicating an Output File Descriptor
The redirection operator:

[n]>&word
shall duplicate one output file descriptor from another, or shall close one. If word evaluates to one or more digits, the file descriptor denoted by n, or standard output if n is not specified, shall be made to be a copy of the file descriptor denoted by word; if the digits in word do not represent a file descriptor already open for output, a redirection error shall result; see Consequences of Shell Errors. If word evaluates to '-', file descriptor n, or standard output if n is not specified, is closed. Attempts to close a file descriptor that is not open shall not constitute an error. If word evaluates to something else, the behavior is unspecified.

2.7.7 Open File Descriptors for Reading and Writing
The redirection operator:

[n]<>word
shall cause the file whose name is the expansion of word to be opened for both reading and writing on the file descriptor denoted by n, or standard input if n is not specified. If the file does not exist, it shall be created.

2.8 Exit Status and Errors
2.8.1 Consequences of Shell Errors
Certain errors shall cause the shell to write a diagnostic message to standard error and exit as shown in the following table:

Error

Non-Interactive
Shell

Interactive Shell

Shell Diagnostic
Message Required

Shell language syntax error

shall exit

shall not exit

yes

Special built-in utility error

shall exit

shall not exit

no1

Other utility (not a special
built-in) error

shall not exit

shall not exit

no2

Redirection error with
special built-in utilities

shall exit

shall not exit

yes

Redirection error with
compound commands

may exit3

shall not exit

yes

Redirection error with
function execution

may exit3

shall not exit

yes

Redirection error with other
utilities (not special built-ins)

shall not exit

shall not exit

yes

Variable assignment error

shall exit

shall not exit

yes

Expansion error

shall exit

shall not exit

yes

Command not found

may exit

shall not exit

yes

Notes:
Although special built-ins are part of the shell, a diagnostic message written by a special built-in is not considered to be a shell diagnostic message, and can be redirected like any other utility.

The shell is not required to write a diagnostic message, but the utility itself shall write a diagnostic message if required to do so.

A future version of this standard may require the shell to not exit in this condition.

An expansion error is one that occurs when the shell expansions define in wordexp are carried out (for example, "${x!y}", because '!' is not a valid operator); an implementation may treat these as syntax errors if it is able to detect them during tokenization, rather than during expansion.

If any of the errors shown as "shall exit" or "may exit" occur in a subshell environment, the shell shall (respectively, may) exit from the subshell environment with a non-zero status and continue in the environment from which that subshell environment was invoked.

In all of the cases shown in the table where an interactive shell is required not to exit, the shell shall not perform any further processing of the command in which the error occurred.

2.8.2 Exit Status for Commands
Each command has an exit status that can influence the behavior of other shell commands. The exit status of commands that are not utilities is documented in this section. The exit status of the standard utilities is documented in their respective sections.

If a command is not found, the exit status shall be 127. If the command name is found, but it is not an executable utility, the exit status shall be 126. Applications that invoke utilities without using the shell should use these exit status values to report similar errors.

If a command fails during word expansion or redirection, its exit status shall be between 1 and 125 inclusive.

Internally, for purposes of deciding whether a command exits with a non-zero exit status, the shell shall recognize the entire status value retrieved for the command by the equivalent of the wait() function WEXITSTATUS macro (as defined in the System Interfaces volume of POSIX.1-2008). When reporting the exit status with the special parameter '?', the shell shall report the full eight bits of exit status available. The exit status of a command that terminated because it received a signal shall be reported as greater than 128.

2.9 Shell Commands
This section describes the basic structure of shell commands. The following command descriptions each describe a format of the command that is only used to aid the reader in recognizing the command type, and does not formally represent the syntax. In particular, the representations include spacing between tokens in some places where <blank>s would not be necessary (when one of the tokens is an operator). Each description discusses the semantics of the command; for a formal definition of the command language, consult Shell Grammar.

A command is one of the following:

Simple command (see Simple Commands)

Pipeline (see Pipelines)

List compound-list (see Lists)

Compound command (see Compound Commands)

Function definition (see Function Definition Command)

Unless otherwise stated, the exit status of a command shall be that of the last simple command executed by the command. There shall be no limit on the size of any shell command other than that imposed by the underlying system (memory constraints, {ARG_MAX}, and so on).

2.9.1 Simple Commands
A "simple command" is a sequence of optional variable assignments and redirections, in any sequence, optionally followed by words and redirections, terminated by a control operator.

When a given simple command is required to be executed (that is, when any conditional construct such as an AND-OR list or a case statement has not bypassed the simple command), the following expansions, assignments, and redirections shall all be performed from the beginning of the command text to the end:

The words that are recognized as variable assignments or redirections according to Shell Grammar Rules are saved for processing in steps 3 and 4.

The words that are not variable assignments or redirections shall be expanded. If any fields remain following their expansion, the first field shall be considered the command name and remaining fields are the arguments for the command.

Redirections shall be performed as described in Redirection.

Each variable assignment shall be expanded for tilde expansion, parameter expansion, command substitution, arithmetic expansion, and quote removal prior to assigning the value.

In the preceding list, the order of steps 3 and 4 may be reversed if no command name results from step 2 or if the command name matches the name of a special built-in utility; see Special Built-In Utilities.

Variable assignments shall be performed as follows:

If no command name results, variable assignments shall affect the current execution environment.

If the command name is not a special built-in utility or function, the variable assignments shall be exported for the execution environment of the command and shall not affect the current execution environment except as a side-effect of the expansions performed in step 4. In this case it is unspecified:

Whether or not the assignments are visible for subsequent expansions in step 4

Whether variable assignments made as side-effects of these expansions are visible for subsequent expansions in step 4, or in the current shell execution environment, or both

If the command name is a standard utility implemented as a function (see XBD Utility), the effect of variable assignments shall be as if the utility was not implemented as a function.

If the command name is a special built-in utility, variable assignments shall affect the current execution environment. Unless the set -a option is on (see set), it is unspecified:

Whether or not the variables gain the export attribute during the execution of the special built-in utility

Whether or not export attributes gained as a result of the variable assignments persist after the completion of the special built-in utility

If the command name is a function that is not a standard utility implemented as a function, variable assignments shall affect the current execution environment during the execution of the function. It is unspecified:

Whether or not the variable assignments persist after the completion of the function

Whether or not the variables gain the export attribute during the execution of the function

Whether or not export attributes gained as a result of the variable assignments persist after the completion of the function (if variable assignments persist after the completion of the function)

If any of the variable assignments attempt to assign a value to a variable for which the readonly attribute is set in the current shell environment (regardless of whether the assignment is made in that environment), a variable assignment error shall occur. See Consequences of Shell Errors for the consequences of these errors.

If there is no command name, any redirections shall be performed in a subshell environment; it is unspecified whether this subshell environment is the same one as that used for a command substitution within the command. (To affect the current execution environment, see the exec special built-in.) If any of the redirections performed in the current shell execution environment fail, the command shall immediately fail with an exit status greater than zero, and the shell shall write an error message indicating the failure. See Consequences of Shell Errors for the consequences of these failures on interactive and non-interactive shells.

If there is a command name, execution shall continue as described in Command Search and Execution . If there is no command name, but the command contained a command substitution, the command shall complete with the exit status of the last command substitution performed. Otherwise, the command shall complete with a zero exit status.

Command Search and Execution
If a simple command results in a command name and an optional list of arguments, the following actions shall be performed:

If the command name does not contain any <slash> characters, the first successful step in the following sequence shall occur:

If the command name matches the name of a special built-in utility, that special built-in utility shall be invoked.

If the command name matches the name of a utility listed in the following table, the results are unspecified.


alloc
autoload
bind
bindkey
builtin
bye
caller
cap
chdir
clone
 


comparguments
compcall
compctl
compdescribe
compfiles
compgen
compgroups
complete
compquote
comptags
 


comptry
compvalues
declare
dirs
disable
disown
dosh
echotc
echoti
help
 


history
hist
let
local
login
logout
map
mapfile
popd
print
 


pushd
readarray
repeat
savehistory
source
shopt
stop
suspend
typeset
whence
 

If the command name matches the name of a function known to this shell, the function shall be invoked as described in Function Definition Command. If the implementation has provided a standard utility in the form of a function, it shall not be recognized at this point. It shall be invoked in conjunction with the path search in step 1e.

If the command name matches the name [XSI] [Option Start]  of the type or ulimit utility, or [Option End]  of a utility listed in the following table, that utility shall be invoked.


alias
bg
cd
command
 


false
fc
fg
getopts
 


hash
jobs
kill
newgrp
 


pwd
read
true
umask
 


unalias
wait
 

Otherwise, the command shall be searched for using the PATH environment variable as described in XBD Environment Variables :

If the search is successful:

If the system has implemented the utility as a regular built-in or as a shell function, it shall be invoked at this point in the path search.

Otherwise, the shell executes the utility in a separate utility environment (see Shell Execution Environment) with actions equivalent to calling the execl() function as defined in the System Interfaces volume of POSIX.1-2008 with the path argument set to the pathname resulting from the search, arg0 set to the command name, and the remaining execl() arguments set to the command arguments (if any) and the null terminator.

If the execl() function fails due to an error equivalent to the [ENOEXEC] error defined in the System Interfaces volume of POSIX.1-2008, the shell shall execute a command equivalent to having a shell invoked with the pathname resulting from the search as its first operand, with any remaining arguments passed to the new shell, except that the value of "$0" in the new shell may be set to the command name. If the executable file is not a text file, the shell may bypass this command execution. In this case, it shall write an error message, and shall return an exit status of 126.

It is unspecified whether environment variables that were passed to the shell when it was invoked, but were not used to initialize shell variables (see Shell Variables) because they had invalid names, are included in the environment passed to execl() and (if execl() fails as described above) to the new shell.

Once a utility has been searched for and found (either as a result of this specific search or as part of an unspecified shell start-up activity), an implementation may remember its location and need not search for the utility again unless the PATH variable has been the subject of an assignment. If the remembered location fails for a subsequent invocation, the shell shall repeat the search to find the new location for the utility, if any.

If the search is unsuccessful, the command shall fail with an exit status of 127 and the shell shall write an error message.

If the command name contains at least one <slash>, the shell shall execute the utility in a separate utility environment with actions equivalent to calling the execl() function defined in the System Interfaces volume of POSIX.1-2008 with the path and arg0 arguments set to the command name, and the remaining execl() arguments set to the command arguments (if any) and the null terminator.

If the execl() function fails due to an error equivalent to the [ENOEXEC] error, the shell shall execute a command equivalent to having a shell invoked with the command name as its first operand, with any remaining arguments passed to the new shell. If the executable file is not a text file, the shell may bypass this command execution. In this case, it shall write an error message and shall return an exit status of 126.

It is unspecified whether environment variables that were passed to the shell when it was invoked, but were not used to initialize shell variables (see Shell Variables) because they had invalid names, are included in the environment passed to execl() and (if execl() fails as described above) to the new shell.

If the utility would be executed with file descriptor 0, 1, or 2 closed, implementations may execute the utility with the file descriptor open to an unspecified file. If a standard utility or a conforming application is executed with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for writing, the environment in which the utility or application is executed shall be deemed non-conforming, and consequently the utility or application might not behave as described in this standard.

2.9.2 Pipelines
A pipeline is a sequence of one or more commands separated by the control operator '|'. For each command but the last, the shell shall connect the standard output of the command to the standard input of the next command as if by creating a pipe and passing the write end of the pipe as the standard output of the command and the read end of the pipe as the standard input of the next command.

The format for a pipeline is:

[!] command1 [ | command2 ...]
If the pipeline begins with the reserved word ! and command1 is a subshell command, the application shall ensure that the ( operator at the beginning of command1 is separated from the ! by one or more <blank> characters. The behavior of the reserved word ! immediately followed by the ( operator is unspecified.

The standard output of command1 shall be connected to the standard input of command2. The standard input, standard output, or both of a command shall be considered to be assigned by the pipeline before any redirection specified by redirection operators that are part of the command (see Redirection).

If the pipeline is not in the background (see Asynchronous Lists), the shell shall wait for the last command specified in the pipeline to complete, and may also wait for all commands to complete.

Exit Status
If the pipeline does not begin with the ! reserved word, the exit status shall be the exit status of the last command specified in the pipeline. Otherwise, the exit status shall be the logical NOT of the exit status of the last command. That is, if the last command returns zero, the exit status shall be 1; if the last command returns greater than zero, the exit status shall be zero.

2.9.3 Lists
An AND-OR list is a sequence of one or more pipelines separated by the operators "&&" and "||" .

A list is a sequence of one or more AND-OR lists separated by the operators ';' and '&'.

The operators "&&" and "||" shall have equal precedence and shall be evaluated with left associativity. For example, both of the following commands write solely bar to standard output:

false && echo foo || echo bar
true || echo foo && echo bar

A ';' separator or a ';' or <newline> terminator shall cause the preceding AND-OR list to be executed sequentially; an '&' separator or terminator shall cause asynchronous execution of the preceding AND-OR list.

The term "compound-list" is derived from the grammar in Shell Grammar; it is equivalent to a sequence of lists, separated by <newline> characters, that can be preceded or followed by an arbitrary number of <newline> characters.

The following sections are informative.
Examples
The following is an example that illustrates <newline> characters in compound-lists:

while
    # a couple of <newline>s


    # a list
    date && who || ls; cat file
    # a couple of <newline>s


    # another list
    wc file > output & true


do
    # 2 lists
    ls
    cat file
done

End of informative text.
Asynchronous Lists
If a command is terminated by the control operator <ampersand> ( '&' ), the shell shall execute the command asynchronously in a subshell. This means that the shell shall not wait for the command to finish before executing the next command.

The format for running a command in the background is:

command1 & [command2 & ... ]
If job control is disabled (see set, -m), the standard input for an asynchronous list, before any explicit redirections are performed, shall be considered to be assigned to a file that has the same properties as /dev/null. This shall not happen if job control is enabled. In all cases, explicit redirection of standard input shall override this activity.

When an element of an asynchronous list (the portion of the list ended by an <ampersand>, such as command1, above) is started by the shell, the process ID of the last command in the asynchronous list element shall become known in the current shell execution environment; see Shell Execution Environment. This process ID shall remain known until:

The command terminates and the application waits for the process ID.

Another asynchronous list is invoked before "$!" (corresponding to the previous asynchronous list) is expanded in the current execution environment.

The implementation need not retain more than the {CHILD_MAX} most recent entries in its list of known process IDs in the current shell execution environment.

Exit Status
The exit status of an asynchronous list shall be zero.

Sequential Lists
Commands that are separated by a <semicolon> ( ';' ) shall be executed sequentially.

The format for executing commands sequentially shall be:

command1 [; command2] ...

Each command shall be expanded and executed in the order specified.

Exit Status
The exit status of a sequential list shall be the exit status of the last command in the list.

AND Lists
The control operator "&&" denotes an AND list. The format shall be:

command1 [ && command2] ...

First command1 shall be executed. If its exit status is zero, command2 shall be executed, and so on, until a command has a non-zero exit status or there are no more commands left to execute. The commands are expanded only if they are executed.

Exit Status
The exit status of an AND list shall be the exit status of the last command that is executed in the list.

OR Lists
The control operator "||" denotes an OR List. The format shall be:

command1 [ || command2] ...

First, command1 shall be executed. If its exit status is non-zero, command2 shall be executed, and so on, until a command has a zero exit status or there are no more commands left to execute.

Exit Status
The exit status of an OR list shall be the exit status of the last command that is executed in the list.

2.9.4 Compound Commands
The shell has several programming constructs that are "compound commands", which provide control flow for commands. Each of these compound commands has a reserved word or control operator at the beginning, and a corresponding terminator reserved word or operator at the end. In addition, each can be followed by redirections on the same line as the terminator. Each redirection shall apply to all the commands within the compound command that do not explicitly override that redirection.

Grouping Commands
The format for grouping commands is as follows:

( compound-list )
Execute compound-list in a subshell environment; see Shell Execution Environment. Variable assignments and built-in commands that affect the environment shall not remain in effect after the list finishes.
If a character sequence beginning with "((" would be parsed by the shell as an arithmetic expansion if preceded by a '$', shells which implement an extension whereby "((expression))" is evaluated as an arithmetic expression may treat the "((" as introducing as an arithmetic evaluation instead of a grouping command. A conforming application shall ensure that it separates the two leading '(' characters with white space to prevent the shell from performing an arithmetic evaluation.

{ compound-list ; }
Execute compound-list in the current process environment. The semicolon shown here is an example of a control operator delimiting the } reserved word. Other delimiters are possible, as shown in Shell Grammar; a <newline> is frequently used.
Exit Status
The exit status of a grouping command shall be the exit status of compound-list.

The for Loop
The for loop shall execute a sequence of commands for each member in a list of items. The for loop requires that the reserved words do and done be used to delimit the sequence of commands.

The format for the for loop is as follows:

for name [ in [word ... ]]
do
    compound-list
done

First, the list of words following in shall be expanded to generate a list of items. Then, the variable name shall be set to each item, in turn, and the compound-list executed each time. If no items result from the expansion, the compound-list shall not be executed. Omitting:

in word...
shall be equivalent to:

in "$@"

Exit Status
The exit status of a for command shall be the exit status of the last command that executes. If there are no items, the exit status shall be zero.

Case Conditional Construct
The conditional construct case shall execute the compound-list corresponding to the first one of several patterns (see Pattern Matching Notation) that is matched by the string resulting from the tilde expansion, parameter expansion, command substitution, arithmetic expansion, and quote removal of the given word. The reserved word in shall denote the beginning of the patterns to be matched. Multiple patterns with the same compound-list shall be delimited by the '|' symbol. The control operator ')' terminates a list of patterns corresponding to a given action. The compound-list for each list of patterns, with the possible exception of the last, shall be terminated with ";;". The case construct terminates with the reserved word esac (case reversed).
The format for the case construct is as follows:

case word in
    [(] pattern1 ) compound-list ;;
    [[(] pattern[ | pattern] ... ) compound-list ;;] ...
    [[(] pattern[ | pattern] ... ) compound-list]
esac

The ";;" is optional for the last compound-list.

In order from the beginning to the end of the case statement, each pattern that labels a compound-list shall be subjected to tilde expansion, parameter expansion, command substitution, and arithmetic expansion, and the result of these expansions shall be compared against the expansion of word, according to the rules described in Pattern Matching Notation (which also describes the effect of quoting parts of the pattern). After the first match, no more patterns shall be expanded, and the compound-list shall be executed. The order of expansion and comparison of multiple patterns that label a compound-list statement is unspecified.

Exit Status
The exit status of case shall be zero if no patterns are matched. Otherwise, the exit status shall be the exit status of the last command executed in the compound-list.

The if Conditional Construct
The if command shall execute a compound-list and use its exit status to determine whether to execute another compound-list.

The format for the if construct is as follows:

if compound-list
then
    compound-list
[elif compound-list
then
    compound-list] ...
[else
    compound-list]
fi

The if compound-list shall be executed; if its exit status is zero, the then compound-list shall be executed and the command shall complete. Otherwise, each elif compound-list shall be executed, in turn, and if its exit status is zero, the then compound-list shall be executed and the command shall complete. Otherwise, the else compound-list shall be executed.

Exit Status
The exit status of the if command shall be the exit status of the then or else compound-list that was executed, or zero, if none was executed.

The while Loop
The while loop shall continuously execute one compound-list as long as another compound-list has a zero exit status.

The format of the while loop is as follows:

while compound-list-1
do
    compound-list-2
done

The compound-list-1 shall be executed, and if it has a non-zero exit status, the while command shall complete. Otherwise, the compound-list-2 shall be executed, and the process shall repeat.

Exit Status
The exit status of the while loop shall be the exit status of the last compound-list-2 executed, or zero if none was executed.

The until Loop
The until loop shall continuously execute one compound-list as long as another compound-list has a non-zero exit status.

The format of the until loop is as follows:

until compound-list-1
do
    compound-list-2
done

The compound-list-1 shall be executed, and if it has a zero exit status, the until command completes. Otherwise, the compound-list-2 shall be executed, and the process repeats.

Exit Status
The exit status of the until loop shall be the exit status of the last compound-list-2 executed, or zero if none was executed.

2.9.5 Function Definition Command
A function is a user-defined name that is used as a simple command to call a compound command with new positional parameters. A function is defined with a "function definition command".

The format of a function definition command is as follows:

fname ( ) compound-command [io-redirect ...]
The function is named fname; the application shall ensure that it is a name (see XBD Name) and that it is not the name of a special built-in utility. An implementation may allow other characters in a function name as an extension. The implementation shall maintain separate name spaces for functions and variables.

The argument compound-command represents a compound command, as described in Compound Commands.

When the function is declared, none of the expansions in wordexp shall be performed on the text in compound-command or io-redirect; all expansions shall be performed as normal each time the function is called. Similarly, the optional io-redirect redirections and any variable assignments within compound-command shall be performed during the execution of the function itself, not the function definition. See Consequences of Shell Errors for the consequences of failures of these operations on interactive and non-interactive shells.

When a function is executed, it shall have the syntax-error properties described for special built-in utilities in the first item in the enumerated list at the beginning of Special Built-In Utilities.

The compound-command shall be executed whenever the function name is specified as the name of a simple command (see Command Search and Execution). The operands to the command temporarily shall become the positional parameters during the execution of the compound-command; the special parameter '#' also shall be changed to reflect the number of operands. The special parameter 0 shall be unchanged. When the function completes, the values of the positional parameters and the special parameter '#' shall be restored to the values they had before the function was executed. If the special built-in return (see return) is executed in the compound-command, the function completes and execution shall resume with the next command after the function call.

Exit Status
The exit status of a function definition shall be zero if the function was declared successfully; otherwise, it shall be greater than zero. The exit status of a function invocation shall be the exit status of the last command executed by the function.

2.10. Shell Grammar
The following grammar defines the Shell Command Language. This formal syntax shall take precedence over the preceding text syntax description.

2.10.1 Shell Grammar Lexical Conventions
The input language to the shell must be first recognized at the character level. The resulting tokens shall be classified by their immediate context according to the following rules (applied in order). These rules shall be used to determine what a "token" is that is subject to parsing at the token level. The rules for token recognition in Token Recognition shall apply.

If the token is an operator, the token identifier for that operator shall result.

If the string consists solely of digits and the delimiter character is one of '<' or '>', the token identifier IO_NUMBER shall be returned.

Otherwise, the token identifier TOKEN results.

Further distinction on TOKEN is context-dependent. It may be that the same TOKEN yields WORD, a NAME, an ASSIGNMENT_WORD, or one of the reserved words below, dependent upon the context. Some of the productions in the grammar below are annotated with a rule number from the following list. When a TOKEN is seen where one of those annotated productions could be used to reduce the symbol, the applicable rule shall be applied to convert the token identifier type of the TOKEN to a token identifier acceptable at that point in the grammar. The reduction shall then proceed based upon the token identifier type yielded by the rule applied. When more than one rule applies, the highest numbered rule shall apply (which in turn may refer to another rule). (Note that except in rule 7, the presence of an '=' in the token has no effect.)

The WORD tokens shall have the word expansion rules applied to them immediately before the associated command is executed, not at the time the command is parsed.

2.10.2 Shell Grammar Rules
[Command Name]

When the TOKEN is exactly a reserved word, the token identifier for that reserved word shall result. Otherwise, the token WORD shall be returned. Also, if the parser is in any state where only a reserved word could be the next correct token, proceed as above.

Note:
Because at this point <quotation-mark> characters are retained in the token, quoted strings cannot be recognized as reserved words. This rule also implies that reserved words are not recognized except in certain positions in the input, such as after a <newline> or <semicolon>; the grammar presumes that if the reserved word is intended, it is properly delimited by the user, and does not attempt to reflect that requirement directly. Also note that line joining is done before tokenization, as described in Escape Character (Backslash), so escaped <newline> characters are already removed at this point.
Rule 1 is not directly referenced in the grammar, but is referred to by other rules, or applies globally.

[Redirection to or from filename]

The expansions specified in Redirection shall occur. As specified there, exactly one field can result (or the result is unspecified), and there are additional requirements on pathname expansion.

[Redirection from here-document]

Quote removal shall be applied to the word to determine the delimiter that is used to find the end of the here-document that begins after the next <newline>.

[Case statement termination]

When the TOKEN is exactly the reserved word esac, the token identifier for esac shall result. Otherwise, the token WORD shall be returned.

[ NAME in for]

When the TOKEN meets the requirements for a name (see XBD Name ), the token identifier NAME shall result. Otherwise, the token WORD shall be returned.

[Third word of for and case]

[ case only]

When the TOKEN is exactly the reserved word in, the token identifier for in shall result. Otherwise, the token WORD shall be returned.

[ for only]

When the TOKEN is exactly the reserved word in or do, the token identifier for in or do shall result, respectively. Otherwise, the token WORD shall be returned.

(For a. and b.: As indicated in the grammar, a linebreak precedes the tokens in and do. If <newline> characters are present at the indicated location, it is the token after them that is treated in this fashion.)

[Assignment preceding command name]

[When the first word]

If the TOKEN does not contain the character '=', rule 1 is applied. Otherwise, 7b shall be applied.

[Not the first word]

If the TOKEN contains an unquoted (as determined while applying rule 4 from Token Recognition) <equals-sign> character that is not part of an embedded parameter expansion, command substitution, or arithmetic expansion construct (as determined while applying rule 5 from Token Recognition):

If the TOKEN begins with '=', then rule 1 shall be applied.

If all the characters in the TOKEN preceding the first such <equals-sign> form a valid name (see XBD Name), the token ASSIGNMENT_WORD shall be returned.

Otherwise, it is unspecified whether rule 1 is applied or ASSIGNMENT_WORD is returned.

Otherwise, rule 1 shall be applied.

Assignment to the name within a returned ASSIGNMENT_WORD token shall occur as specified in Simple Commands.

[ NAME in function]

When the TOKEN is exactly a reserved word, the token identifier for that reserved word shall result. Otherwise, when the TOKEN meets the requirements for a name, the token identifier NAME shall result. Otherwise, rule 7 applies.

[Body of function]

Word expansion and assignment shall never occur, even when required by the rules above, when this rule is being parsed. Each TOKEN that might either be expanded or have assignment applied to it shall instead be returned as a single WORD consisting only of characters that are exactly the token described in Token Recognition.


/* -------------------------------------------------------
   The grammar symbols
   ------------------------------------------------------- */
%token  WORD
%token  ASSIGNMENT_WORD
%token  NAME
%token  NEWLINE
%token  IO_NUMBER


/* The following are the operators (see XBD Operator)
   containing more than one character. */



%token  AND_IF    OR_IF    DSEMI
/*      '&&'      '||'     ';;'    */


%token  DLESS  DGREAT  LESSAND  GREATAND  LESSGREAT  DLESSDASH
/*      '<<'   '>>'    '<&'     '>&'      '<>'       '<<-'   */


%token  CLOBBER
/*      '>|'   */


/* The following are the reserved words. */


%token  If    Then    Else    Elif    Fi    Do    Done
/*      'if'  'then'  'else'  'elif'  'fi'  'do'  'done'   */


%token  Case    Esac    While    Until    For
/*      'case'  'esac'  'while'  'until'  'for'   */


/* These are reserved words, not operator tokens, and are
   recognized when reserved words are recognized. */


%token  Lbrace    Rbrace    Bang
/*      '{'       '}'       '!'   */


%token  In
/*      'in'   */


/* -------------------------------------------------------
   The Grammar
   ------------------------------------------------------- */
%start program
%%
program          : linebreak complete_commands linebreak
                 | linebreak
                 ;
complete_commands: complete_commands newline_list complete_command
                 |                                complete_command
                 ;
complete_command : list separator_op
                 | list
                 ;
list             : list separator_op and_or
                 |                   and_or
                 ;
and_or           :                         pipeline
                 | and_or AND_IF linebreak pipeline
                 | and_or OR_IF  linebreak pipeline
                 ;
pipeline         :      pipe_sequence
                 | Bang pipe_sequence
                 ;
pipe_sequence    :                             command
                 | pipe_sequence '|' linebreak command
                 ;
command          : simple_command
                 | compound_command
                 | compound_command redirect_list
                 | function_definition
                 ;
compound_command : brace_group
                 | subshell
                 | for_clause
                 | case_clause
                 | if_clause
                 | while_clause
                 | until_clause
                 ;
subshell         : '(' compound_list ')'
                 ;
compound_list    : linebreak term
                 | linebreak term separator
                 ;
term             : term separator and_or
                 |                and_or
                 ;
for_clause       : For name                                      do_group
                 | For name                       sequential_sep do_group
                 | For name linebreak in          sequential_sep do_group
                 | For name linebreak in wordlist sequential_sep do_group
                 ;
name             : NAME                     /* Apply rule 5 */
                 ;
in               : In                       /* Apply rule 6 */
                 ;
wordlist         : wordlist WORD
                 |          WORD
                 ;
case_clause      : Case WORD linebreak in linebreak case_list    Esac
                 | Case WORD linebreak in linebreak case_list_ns Esac
                 | Case WORD linebreak in linebreak              Esac
                 ;
case_list_ns     : case_list case_item_ns
                 |           case_item_ns
                 ;
case_list        : case_list case_item
                 |           case_item
                 ;
case_item_ns     :     pattern ')' linebreak
                 |     pattern ')' compound_list
                 | '(' pattern ')' linebreak
                 | '(' pattern ')' compound_list
                 ;
case_item        :     pattern ')' linebreak     DSEMI linebreak
                 |     pattern ')' compound_list DSEMI linebreak
                 | '(' pattern ')' linebreak     DSEMI linebreak
                 | '(' pattern ')' compound_list DSEMI linebreak
                 ;
pattern          :             WORD         /* Apply rule 4 */
                 | pattern '|' WORD         /* Do not apply rule 4 */
                 ;
if_clause        : If compound_list Then compound_list else_part Fi
                 | If compound_list Then compound_list           Fi
                 ;
else_part        : Elif compound_list Then compound_list
                 | Elif compound_list Then compound_list else_part
                 | Else compound_list
                 ;
while_clause     : While compound_list do_group
                 ;
until_clause     : Until compound_list do_group
                 ;
function_definition : fname '(' ')' linebreak function_body
                 ;
function_body    : compound_command                /* Apply rule 9 */
                 | compound_command redirect_list  /* Apply rule 9 */
                 ;
fname            : NAME                            /* Apply rule 8 */
                 ;
brace_group      : Lbrace compound_list Rbrace
                 ;
do_group         : Do compound_list Done           /* Apply rule 6 */
                 ;
simple_command   : cmd_prefix cmd_word cmd_suffix
                 | cmd_prefix cmd_word
                 | cmd_prefix
                 | cmd_name cmd_suffix
                 | cmd_name
                 ;
cmd_name         : WORD                   /* Apply rule 7a */
                 ;
cmd_word         : WORD                   /* Apply rule 7b */
                 ;
cmd_prefix       :            io_redirect
                 | cmd_prefix io_redirect
                 |            ASSIGNMENT_WORD
                 | cmd_prefix ASSIGNMENT_WORD
                 ;
cmd_suffix       :            io_redirect
                 | cmd_suffix io_redirect
                 |            WORD
                 | cmd_suffix WORD
                 ;
redirect_list    :               io_redirect
                 | redirect_list io_redirect
                 ;
io_redirect      :           io_file
                 | IO_NUMBER io_file
                 |           io_here
                 | IO_NUMBER io_here
                 ;
io_file          : '<'       filename
                 | LESSAND   filename
                 | '>'       filename
                 | GREATAND  filename
                 | DGREAT    filename
                 | LESSGREAT filename
                 | CLOBBER   filename
                 ;
filename         : WORD                      /* Apply rule 2 */
                 ;
io_here          : DLESS     here_end
                 | DLESSDASH here_end
                 ;
here_end         : WORD                      /* Apply rule 3 */
                 ;
newline_list     :              NEWLINE
                 | newline_list NEWLINE
                 ;
linebreak        : newline_list
                 | /* empty */
                 ;
separator_op     : '&'
                 | ';'
                 ;
separator        : separator_op linebreak
                 | newline_list
                 ;
sequential_sep   : ';' linebreak
                 | newline_list
                 ;

2.11. Signals and Error Handling
If job control is disabled (see the description of set -m) when the shell executes an asynchronous list, the commands in the list shall inherit from the shell a signal action of ignored (SIG_IGN) for the SIGINT and SIGQUIT signals. In all other cases, commands executed by the shell shall inherit the same signal actions as those inherited by the shell from its parent unless a signal action is modified by the trap special built-in (see trap)

When a signal for which a trap has been set is received while the shell is waiting for the completion of a utility executing a foreground command, the trap associated with that signal shall not be executed until after the foreground command has completed. When the shell is waiting, by means of the wait utility, for asynchronous commands to complete, the reception of a signal for which a trap has been set shall cause the wait utility to return immediately with an exit status >128, immediately after which the trap associated with that signal shall be taken.

If multiple signals are pending for the shell for which there are associated trap actions, the order of execution of trap actions is unspecified.

2.12. Shell Execution Environment
A shell execution environment consists of the following:

Open files inherited upon invocation of the shell, plus open files controlled by exec

Working directory as set by cd

File creation mask set by umask

[XSI] [Option Start] File size limit as set by ulimit [Option End]

Current traps set by trap

Shell parameters that are set by variable assignment (see the set special built-in) or from the System Interfaces volume of POSIX.1-2008 environment inherited by the shell when it begins (see the export special built-in)

Shell functions; see Function Definition Command

Options turned on at invocation or by set

Process IDs of the last commands in asynchronous lists known to this shell environment; see Asynchronous Lists

Shell aliases; see Alias Substitution

Utilities other than the special built-ins (see Special Built-In Utilities) shall be invoked in a separate environment that consists of the following. The initial value of these objects shall be the same as that for the parent shell, except as noted below.

Open files inherited on invocation of the shell, open files controlled by the exec special built-in plus any modifications, and additions specified by any redirections to the utility

Current working directory

File creation mask

If the utility is a shell script, traps caught by the shell shall be set to the default values and traps ignored by the shell shall be set to be ignored by the utility; if the utility is not a shell script, the trap actions (default or ignore) shall be mapped into the appropriate signal handling actions for the utility

Variables with the export attribute, along with those explicitly exported for the duration of the command, shall be passed to the utility environment variables

The environment of the shell process shall not be changed by the utility unless explicitly specified by the utility description (for example, cd and umask).

A subshell environment shall be created as a duplicate of the shell environment, except that signal traps that are not being ignored shall be set to the default action. Changes made to the subshell environment shall not affect the shell environment. Command substitution, commands that are grouped with parentheses, and asynchronous lists shall be executed in a subshell environment. Additionally, each command of a multi-command pipeline is in a subshell environment; as an extension, however, any or all commands in a pipeline may be executed in the current environment. All other commands shall be executed in the current shell environment.

2.13. Pattern Matching Notation
The pattern matching notation described in this section is used to specify patterns for matching strings in the shell. Historically, pattern matching notation is related to, but slightly different from, the regular expression notation described in XBD Regular Expressions. For this reason, the description of the rules for this pattern matching notation are based on the description of regular expression notation, modified to account for the differences.

2.13.1 Patterns Matching a Single Character
The following patterns matching a single character shall match a single character: ordinary characters, special pattern characters, and pattern bracket expressions. The pattern bracket expression also shall match a single collating element. A <backslash> character shall escape the following character. The escaping <backslash> shall be discarded. If a pattern ends with an unescaped <backslash>, it is unspecified whether the pattern does not match anything or the pattern is treated as invalid.

An ordinary character is a pattern that shall match itself. It can be any character in the supported character set except for NUL, those special shell characters in Quoting that require quoting, and the following three special pattern characters. Matching shall be based on the bit pattern used for encoding the character, not on the graphic representation of the character. If any character (ordinary, shell special, or pattern special) is quoted, that pattern shall match the character itself. The shell special characters always require quoting.

When unquoted and outside a bracket expression, the following three characters shall have special meaning in the specification of patterns:

?
A <question-mark> is a pattern that shall match any character.
*
An <asterisk> is a pattern that shall match multiple characters, as described in Patterns Matching Multiple Characters.
[
If an open bracket introduces a bracket expression as in XBD RE Bracket Expression, except that the <exclamation-mark> character ( '!' ) shall replace the <circumflex> character ( '^' ) in its role in a non-matching list in the regular expression notation, it shall introduce a pattern bracket expression. A bracket expression starting with an unquoted <circumflex> character produces unspecified results. Otherwise, '[' shall match the character itself.
When pattern matching is used where shell quote removal is not performed (such as in the argument to the find - name primary when find is being called using one of the exec functions as defined in the System Interfaces volume of POSIX.1-2008, or in the pattern argument to the fnmatch() function), special characters can be escaped to remove their special meaning by preceding them with a <backslash> character. This escaping <backslash> is discarded. The sequence "\\" represents one literal <backslash>. All of the requirements and effects of quoting on ordinary, shell special, and special pattern characters shall apply to escaping in this context.

2.13.2 Patterns Matching Multiple Characters
The following rules are used to construct patterns matching multiple characters from patterns matching a single character:

The <asterisk> ( '*' ) is a pattern that shall match any string, including the null string.

The concatenation of patterns matching a single character is a valid pattern that shall match the concatenation of the single characters or collating elements matched by each of the concatenated patterns.

The concatenation of one or more patterns matching a single character with one or more <asterisk> characters is a valid pattern. In such patterns, each <asterisk> shall match a string of zero or more characters, matching the greatest possible number of characters that still allows the remainder of the pattern to match the string.

2.13.3 Patterns Used for Filename Expansion
The rules described so far in Patterns Matching a Single Character and Patterns Matching Multiple Characters are qualified by the following rules that apply when pattern matching notation is used for filename expansion:

The <slash> character in a pathname shall be explicitly matched by using one or more <slash> characters in the pattern; it shall neither be matched by the <asterisk> or <question-mark> special characters nor by a bracket expression. <slash> characters in the pattern shall be identified before bracket expressions; thus, a <slash> cannot be included in a pattern bracket expression used for filename expansion. If a <slash> character is found following an unescaped <left-square-bracket> character before a corresponding <right-square-bracket> is found, the open bracket shall be treated as an ordinary character. For example, the pattern "a[b/c]d" does not match such pathnames as abd or a/d. It only matches a pathname of literally a[b/c]d.

If a filename begins with a <period> ( '.' ), the <period> shall be explicitly matched by using a <period> as the first character of the pattern or immediately following a <slash> character. The leading <period> shall not be matched by:

The <asterisk> or <question-mark> special characters

A bracket expression containing a non-matching list, such as "[!a]", a range expression, such as "[%-0]", or a character class expression, such as "[[:punct:]]"

It is unspecified whether an explicit <period> in a bracket expression matching list, such as "[.abc]", can match a leading <period> in a filename.

Specified patterns shall be matched against existing filenames and pathnames, as appropriate. Each component that contains a pattern character shall require read permission in the directory containing that component. Any component, except the last, that does not contain a pattern character shall require search permission. For example, given the pattern:

/foo/bar/x*/bam

search permission is needed for directories / and foo, search and read permissions are needed for directory bar, and search permission is needed for each x* directory. If the pattern matches any existing filenames or pathnames, the pattern shall be replaced with those filenames and pathnames, sorted according to the collating sequence in effect in the current locale. If this collating sequence does not have a total ordering of all characters (see XBD LC_COLLATE), any filenames or pathnames that collate equally should be further compared byte-by-byte using the collating sequence for the POSIX locale.

Note:
A future version of this standard may require the byte-by-byte further comparison described above.
If the pattern contains an open bracket ( '[' ) that does not introduce a bracket expression as in XBD RE Bracket Expression, it is unspecified whether other unquoted pattern matching characters within the same slash-delimited component of the pattern retain their special meanings or are treated as ordinary characters. For example, the pattern "a*[/b*" may match all filenames beginning with 'b' in the directory "a*[" or it may match all filenames beginning with 'b' in all directories with names beginning with 'a' and ending with '['.

If the pattern does not match any existing filenames or pathnames, the pattern string shall be left unchanged.

2.14. Special Built-In Utilities
The following "special built-in" utilities shall be supported in the shell command language. The output of each command, if any, shall be written to standard output, subject to the normal redirection and piping possible with all commands.

The term "built-in" implies that the shell can execute the utility directly and does not need to search for it. An implementation may choose to make any utility a built-in; however, the special built-in utilities described here differ from regular built-in utilities in two respects:

An error in a special built-in utility may cause a shell executing that utility to abort, while an error in a regular built-in utility shall not cause a shell executing that utility to abort. (See Consequences of Shell Errors for the consequences of errors on interactive and non-interactive shells.) If a special built-in utility encountering an error does not abort the shell, its exit value shall be non-zero.

As described in Simple Commands, variable assignments preceding the invocation of a special built-in utility remain in effect after the built-in completes; this shall not be the case with a regular built-in or other utility.

The special built-in utilities in this section need not be provided in a manner accessible via the exec family of functions defined in the System Interfaces volume of POSIX.1-2008.

Some of the special built-ins are described as conforming to XBD Utility Syntax Guidelines. For those that are not, the requirement in Utility Description Defaults that "--" be recognized as a first argument to be discarded does not apply and a conforming application shall not use that argument.

<<< Previous	Home	Next >>>
 

return to top of page
UNIX  is a registered Trademark of The Open Group.
POSIX  is a registered Trademark of The IEEE.
Copyright  2001-2016 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT ]
NAME
break - exit from for, while, or until loop
SYNOPSIS
break [n]

DESCRIPTION
If n is specified, the break utility shall exit from the nth enclosing for, while, or until loop. If n is not specified, break shall behave as if n was specified as 1. Execution shall continue with the command immediately following the exited loop. The value of n is a positive decimal integer. If n is greater than the number of enclosing loops, the outermost enclosing loop shall be exited. If there is no enclosing loop, the behavior is unspecified.

A loop shall enclose a break or continue command if the loop lexically encloses the command. A loop lexically encloses a break or continue command if the command is:

Executing in the same execution environment (see Shell Execution Environment) as the compound-list of the loop's do-group (see Shell Grammar Rules), and

Contained in a compound-list associated with the loop (either in the compound-list of the loop's do-group or, if the loop is a while or until loop, in the compound-list following the while or until reserved word), and

Not in the body of a function whose function definition command (see Function Definition Command) is contained in a compound-list associated with the loop.

If n is greater than the number of lexically enclosing loops and there is a non-lexically enclosing loop in progress in the same execution environment as the break or continue command, it is unspecified whether that loop encloses the command.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
Successful completion.
>0
The n value was not an unsigned decimal integer greater than or equal to 1.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
for i in *
do
    if test -d "$i"
    then break
    fi
done

The results of running the following example are unspecified: there are two loops in progress when the break command is executed, and they are in the same execution environment, but neither loop is lexically enclosing the break command. (There are no loops lexically enclosing the continue commands, either.)

foo() {
    for j in 1 2; do
        echo 'break 2' >/tmp/do_break
        echo "  sourcing /tmp/do_break ($j)..."
        # the behavior of the break from running the following command
        # results in unspecified behavior:
        . /tmp/do_break


        do_continue() { continue 2; }
        echo "  running do_continue ($j)..."
        # the behavior of the continue in the following function call
        # results in unspecified behavior (if execution reaches this
        # point):
        do_continue


        trap 'continue 2' USR1
        echo "  sending SIGUSR1 to self ($j)..."
        # the behavior of the continue in the trap invoked from the
        # following signal results in unspecified behavior (if
        # execution reaches this point):
        kill -s USR1 $$
        sleep 1
    done
}
for i in 1 2; do
    echo "running foo ($i)..."
    foo
done

RATIONALE
In early proposals, consideration was given to expanding the syntax of break and continue to refer to a label associated with the appropriate loop as a preferable alternative to the n method. However, this volume of POSIX.1-2008 does reserve the name space of command names ending with a <colon>. It is anticipated that a future implementation could take advantage of this and provide something like:

outofloop: for i in a b c d e
do
    for j in 0 1 2 3 4 5 6 7 8 9
    do
        if test -r "${i}${j}"
        then break outofloop
        fi
    done
done

and that this might be standardized after implementation experience is achieved.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0046 [842] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
colon - null utility
SYNOPSIS
: [argument...]

DESCRIPTION
This utility shall only expand command arguments. It is used when a command is needed, as in the then condition of an if command, but nothing is to be done by the command.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
Zero.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
: ${X=abc}
if     false
then   :
else   echo $X
fi
abc

As with any of the special built-ins, the null utility can also have variable assignments and redirections associated with it, such as:

x=y : > z

which sets variable x to the value y (so that it persists after the null utility completes) and creates or truncates file z.

RATIONALE
None.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

End of informative text.
<<< Previous	Home	Next >>>
NAME
continue - continue for, while, or until loop
SYNOPSIS
continue [n]

DESCRIPTION
If n is specified, the continue utility shall return to the top of the nth enclosing for, while, or until loop. If n is not specified, continue shall behave as if n was specified as 1. Returning to the top of the loop involves repeating the condition list of a while or until loop or performing the next assignment of a for loop, and re-executing the loop if appropriate.

The value of n is a positive decimal integer. If n is greater than the number of enclosing loops, the outermost enclosing loop shall be used. If there is no enclosing loop, the behavior is unspecified.

The meaning of "enclosing" shall be as specified in the description of the break utility.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
Successful completion.
>0
The n value was not an unsigned decimal integer greater than or equal to 1.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
for i in *
do
    if test -d "$i"
    then continue
    fi
    printf '"%s" is not a directory.\n' "$i"
done

RATIONALE
None.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
The example is changed to use the printf utility rather than echo.

POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0046 [842] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
dot - execute commands in the current environment
SYNOPSIS
. file

DESCRIPTION
The shell shall execute commands from the file in the current environment.

If file does not contain a <slash>, the shell shall use the search path specified by PATH to find the directory containing file. Unlike normal command search, however, the file searched for by the dot utility need not be executable. If no readable file is found, a non-interactive shell shall abort; an interactive shell shall write a diagnostic message to standard error, but this condition shall not be considered a syntax error.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
See the DESCRIPTION.

ENVIRONMENT VARIABLES
See the DESCRIPTION.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
If no readable file was found or if the commands in the file could not be parsed, and the shell is interactive (and therefore does not abort; see Consequences of Shell Errors), the exit status shall be non-zero. Otherwise, return the value of the last command executed, or a zero exit status if no command is executed.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
cat foobar
foo=hello bar=world
. ./foobar
echo $foo $bar
hello world

RATIONALE
Some older implementations searched the current directory for the file, even if the value of PATH disallowed it. This behavior was omitted from this volume of POSIX.1-2008 due to concerns about introducing the susceptibility to trojan horses that the user might be trying to avoid by leaving dot out of PATH.

The KornShell version of dot takes optional arguments that are set to the positional parameters. This is a valid extension that allows a dot script to behave identically to a function.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities, return

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-164 is applied.

POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0038 [114] and XCU/TC1-2008/0039 [214] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
eval - construct command by concatenating arguments
SYNOPSIS
eval [argument...]

DESCRIPTION
The eval utility shall construct a command by concatenating arguments together, separating each with a <space> character. The constructed command shall be read and executed by the shell.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
If there are no arguments, or only null arguments, eval shall return a zero exit status; otherwise, it shall return the exit status of the command defined by the string of concatenated arguments separated by <space> characters, or a non-zero exit status if the concatenation could not be parsed as a command and the shell is interactive (and therefore did not abort).

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
Since eval is not required to recognize the "--" end of options delimiter, in cases where the argument(s) to eval might begin with '-' it is recommended that the first argument is prefixed by a string that will not alter the commands to be executed, such as a <space> character:

eval " $commands"

or:

eval " $(some_command)"

EXAMPLES
foo=10 x=foo
y='$'$x
echo $y
$foo
eval y='$'$x
echo $y
10

RATIONALE
This standard allows, but does not require, eval to recognize "--". Although this means applications cannot use "--" to protect against options supported as an extension (or errors reported for unsupported options), the nature of the eval utility is such that other means can be used to provide this protection (see APPLICATION USAGE above).

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0040 [114], XCU/TC1-2008/0041 [163], and XCU/TC1-2008/0042 [163] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
exec - execute commands and open, close, or copy file descriptors
SYNOPSIS
exec [command [argument...]]

DESCRIPTION
The exec utility shall open, close, and/or copy file descriptors as specified by any redirections as part of the command.

If exec is specified without command or arguments, and any file descriptors with numbers greater than 2 are opened with associated redirection statements, it is unspecified whether those file descriptors remain open when the shell invokes another utility. Scripts concerned that child shells could misuse open file descriptors can always close them explicitly, as shown in one of the following examples.

If exec is specified with command, it shall replace the shell with command without creating a new process. If arguments are specified, they shall be arguments to command. Redirection affects the current shell execution environment.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
If command is specified, exec shall not return to the shell; rather, the exit status of the process shall be the exit status of the program implementing command, which overlaid the shell. If command is not found, the exit status shall be 127. If command is found, but it is not an executable utility, the exit status shall be 126. If a redirection error occurs (see Consequences of Shell Errors), the shell shall exit with a value in the range 1-125. Otherwise, exec shall return a zero exit status.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
Open readfile as file descriptor 3 for reading:

exec 3< readfile

Open writefile as file descriptor 4 for writing:

exec 4> writefile

Make file descriptor 5 a copy of file descriptor 0:

exec 5<&0

Close file descriptor 3:

exec 3<&-

Cat the file maggie by replacing the current shell with the cat utility:

exec cat maggie

RATIONALE
Most historical implementations were not conformant in that:

foo=bar exec cmd

did not pass foo to cmd.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

End of informative text.
<<< Previous	Home	Next >>>
NAME
exit - cause the shell to exit
SYNOPSIS
exit [n]

DESCRIPTION
The exit utility shall cause the shell to exit from its current execution environment with the exit status specified by the unsigned decimal integer n. If the current execution environment is a subshell environment, the shell shall exit from the subshell environment with the specified exit status and continue in the environment from which that subshell environment was invoked; otherwise, the shell utility shall terminate with the specified exit status. If n is specified, but its value is not between 0 and 255 inclusively, the exit status is undefined.

A trap on EXIT shall be executed before the shell terminates, except when the exit utility is invoked in that trap itself, in which case the shell shall exit immediately.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
The exit status shall be n, if specified, except that the behavior is unspecified if n is not an unsigned decimal integer or is greater than 255. Otherwise, the value shall be the exit value of the last command executed, or zero if no command was executed. When exit is executed in a trap action, the last command is considered to be the command that executed immediately preceding the trap action.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
Exit with a true value:

exit 0

Exit with a false value:

exit 1

Propagate error handling from within a subshell:

(
    command1 || exit 1
    command2 || exit 1
    exec command3
) > outputfile || exit 1
echo "outputfile created successfully"

RATIONALE
As explained in other sections, certain exit status values have been reserved for special uses and should be used by applications only for those purposes:

 126
A file to be executed was found, but it was not an executable utility.
 127
A utility to be executed was not found.
>128
A command was interrupted by a signal.
The behavior of exit when given an invalid argument or unknown option is unspecified, because of differing practices in the various historical implementations. A value larger than 255 might be truncated by the shell, and be unavailable even to a parent process that uses waitid() to get the full exit value. It is recommended that implementations that detect any usage error should cause a non-zero exit status (or, if the shell is interactive and the error does not cause the shell to abort, store a non-zero value in "$?" ), but even this was not done historically in all shells.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0047 [717], XCU/TC2-2008/0048 [960], XCU/TC2-2008/0049 [717], and XCU/TC2-2008/0050 [960] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
export - set the export attribute for variables
SYNOPSIS
export name[=word]...
 
export -p

DESCRIPTION
The shell shall give the export attribute to the variables corresponding to the specified names, which shall cause them to be in the environment of subsequently executed commands. If the name of a variable is followed by = word, then the value of that variable shall be set to word.

The export special built-in shall support XBD Utility Syntax Guidelines.

When -p is specified, export shall write to the standard output the names and values of all exported variables, in the following format:

"export %s=%s\n", <name>, <value>

if name is set, and:

"export %s\n", <name>

if name is unset.

The shell shall format the output, including the proper use of quoting, so that it is suitable for reinput to the shell as commands that achieve the same exporting results, except:

Read-only variables with values cannot be reset.

Variables that were unset at the time they were output need not be reset to the unset state if a value is assigned to the variable between the time the state was saved and the time at which the saved output is reinput to the shell.

When no arguments are given, the results are unspecified.

OPTIONS
See the DESCRIPTION.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
See the DESCRIPTION.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
All name operands were successfully exported.
>0
At least one name could not be exported, or the -p option was specified and an error occurred.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
Note that, unless X was previously marked readonly, the value of "$?" after:

export X=$(false)

will be 0 (because export successfully set X to the empty string) and that execution continues, even if set -e is in effect. In order to detect command substitution failures, a user must separate the assignment from the export, as in:

X=$(false)
export X

EXAMPLES
Export PWD and HOME variables:

export PWD HOME

Set and export the PATH variable:

export PATH=/local/bin:$PATH

Save and restore all exported variables:

export -p > temp-file
unset a lot of variables
... processing
. temp-file

RATIONALE
Some historical shells use the no-argument case as the functional equivalent of what is required here with -p. This feature was left unspecified because it is not historical practice in all shells, and some scripts may rely on the now-unspecified results on their implementations. Attempts to specify the -p output as the default case were unsuccessful in achieving consensus. The -p option was added to allow portable access to the values that can be saved and then later restored using; for example, a dot script.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

XBD Utility Syntax Guidelines

CHANGE HISTORY
Issue 6
IEEE PASC Interpretation 1003.2 #203 is applied, clarifying the format when a variable is unset.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/6 is applied, adding the following text to the end of the first paragraph of the DESCRIPTION: "If the name of a variable is followed by = word, then the value of that variable shall be set to word.". The reason for this change is that the SYNOPSIS for export includes:

export name[=word]...

but the meaning of the optional "= word" is never explained in the text.

Issue 7
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0043 [352] is applied.

POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0051 [654] and XCU/TC2-2008/0052 [960] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
readonly - set the readonly attribute for variables
SYNOPSIS
readonly name[=word]...
 
readonly -p

DESCRIPTION
The variables whose names are specified shall be given the readonly attribute. The values of variables with the readonly attribute cannot be changed by subsequent assignment, nor can those variables be unset by the unset utility. If the name of a variable is followed by = word, then the value of that variable shall be set to word.

The readonly special built-in shall support XBD Utility Syntax Guidelines.

When -p is specified, readonly writes to the standard output the names and values of all read-only variables, in the following format:

"readonly %s=%s\n", <name>, <value>

if name is set, and

"readonly %s\n", <name>

if name is unset.

The shell shall format the output, including the proper use of quoting, so that it is suitable for reinput to the shell as commands that achieve the same value and readonly attribute-setting results in a shell execution environment in which:

Variables with values at the time they were output do not have the readonly attribute set.

Variables that were unset at the time they were output do not have a value at the time at which the saved output is reinput to the shell.

When no arguments are given, the results are unspecified.

OPTIONS
See the DESCRIPTION.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
See the DESCRIPTION.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
All name operands were successfully marked readonly.
>0
At least one name could not be marked readonly, or the -p option was specified and an error occurred.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
readonly HOME PWD

RATIONALE
Some historical shells preserve the readonly attribute across separate invocations. This volume of POSIX.1-2008 allows this behavior, but does not require it.

The -p option allows portable access to the values that can be saved and then later restored using, for example, a dot script. Also see the RATIONALE for export for a description of the no-argument and -p output cases and a related example.

Read-only functions were considered, but they were omitted as not being historical practice or particularly useful. Furthermore, functions must not be read-only across invocations to preclude "spoofing" (spoofing is the term for the practice of creating a program that acts like a well-known utility with the intent of subverting the real intent of the user) of administrative or security-relevant (or security-conscious) shell scripts.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

XBD Utility Syntax Guidelines

CHANGE HISTORY
Issue 6
IEEE PASC Interpretation 1003.2 #203 is applied, clarifying the format when a variable is unset.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/7 is applied, adding the following text to the end of the first paragraph of the DESCRIPTION: "If the name of a variable is followed by = word, then the value of that variable shall be set to word.". The reason for this change is that the SYNOPSIS for readonly includes:
readonly name[=word]...

but the meaning of the optional "= word" is never explained in the text.

Issue 7
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0052 [960] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
return - return from a function or dot script
SYNOPSIS
return [n]

DESCRIPTION
The return utility shall cause the shell to stop executing the current function or dot script. If the shell is not currently executing a function or dot script, the results are unspecified.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
The value of the special parameter '?' shall be set to n, an unsigned decimal integer, or to the exit status of the last command executed if n is not specified. If n is not an unsigned decimal integer, or is greater than 255, the results are unspecified. When return is executed in a trap action, the last command is considered to be the command that executed immediately preceding the trap action.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
None.

RATIONALE
The behavior of return when not in a function or dot script differs between the System V shell and the KornShell. In the System V shell this is an error, whereas in the KornShell, the effect is the same as exit.

The results of returning a number greater than 255 are undefined because of differing practices in the various historical implementations. Some shells AND out all but the low-order 8 bits; others allow larger values, but not of unlimited size.

See the discussion of appropriate exit status values under exit.

FUTURE DIRECTIONS
None.

SEE ALSO
Function Definition Command, Special Built-In Utilities, dot

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0044 [214] and XCU/TC1-2008/0045 [214] are applied.

POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0052 [960] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
set - set or unset options and positional parameters
SYNOPSIS
set [-abCefhmnuvx] [-o option] [argument...]
 
set [+abCefhmnuvx] [+o option] [argument...]
 
set -- [argument...]
 
set -o
 
set +o

DESCRIPTION
If no options or arguments are specified, set shall write the names and values of all shell variables in the collation sequence of the current locale. Each name shall start on a separate line, using the format:

"%s=%s\n", <name>, <value>

The value string shall be written with appropriate quoting; see the description of shell quoting in Quoting. The output shall be suitable for reinput to the shell, setting or resetting, as far as possible, the variables that are currently set; read-only variables cannot be reset.

When options are specified, they shall set or unset attributes of the shell, as described below. When arguments are specified, they cause positional parameters to be set or unset, as described below. Setting or unsetting attributes and positional parameters are not necessarily related actions, but they can be combined in a single invocation of set.

The set special built-in shall support XBD Utility Syntax Guidelines except that options can be specified with either a leading <hyphen-minus> (meaning enable the option) or <plus-sign> (meaning disable it) unless otherwise specified.

Implementations shall support the options in the following list in both their <hyphen-minus> and <plus-sign> forms. These options can also be specified as options to sh.

-a
When this option is on, the export attribute shall be set for each variable to which an assignment is performed; see XBD Variable Assignment. If the assignment precedes a utility name in a command, the export attribute shall not persist in the current execution environment after the utility completes, with the exception that preceding one of the special built-in utilities causes the export attribute to persist after the built-in has completed. If the assignment does not precede a utility name in the command, or if the assignment is a result of the operation of the getopts or read utilities, the export attribute shall persist until the variable is unset.
-b
This option shall be supported if the implementation supports the User Portability Utilities option. It shall cause the shell to notify the user asynchronously of background job completions. The following message is written to standard error:
"[%d]%c %s%s\n", <job-number>, <current>, <status>, <job-name>

where the fields shall be as follows:

<current>
The character '+' identifies the job that would be used as a default for the fg or bg utilities; this job can also be specified using the job_id "%+" or "%%". The character '-' identifies the job that would become the default if the current default job were to exit; this job can also be specified using the job_id "%-". For other jobs, this field is a <space>. At most one job can be identified with '+' and at most one job can be identified with '-'. If there is any suspended job, then the current job shall be a suspended job. If there are at least two suspended jobs, then the previous job also shall be a suspended job.
<job-number>
A number that can be used to identify the process group to the wait, fg, bg, and kill utilities. Using these utilities, the job can be identified by prefixing the job number with '%'.
<status>
Unspecified.
<job-name>
Unspecified.
When the shell notifies the user a job has been completed, it may remove the job's process ID from the list of those known in the current shell execution environment; see Asynchronous Lists. Asynchronous notification shall not be enabled by default.

-C
(Uppercase C.) Prevent existing files from being overwritten by the shell's '>' redirection operator (see Redirecting Output); the ">|" redirection operator shall override this noclobber option for an individual file.
-e
When this option is on, when any command fails (for any of the reasons listed in Consequences of Shell Errors or by returning an exit status greater than zero), the shell immediately shall exit, as if by executing the exit special built-in utility with no arguments, with the following exceptions:
The failure of any individual command in a multi-command pipeline shall not cause the shell to exit. Only the failure of the pipeline itself shall be considered.

The -e setting shall be ignored when executing the compound list following the while, until, if, or elif reserved word, a pipeline beginning with the ! reserved word, or any command of an AND-OR list other than the last.

If the exit status of a compound command other than a subshell command was the result of a failure while -e was being ignored, then -e shall not apply to this command.

This requirement applies to the shell environment and each subshell environment separately. For example, in:

set -e; (false; echo one) | cat; echo two

the false command causes the subshell to exit without executing echo one; however, echo two is executed because the exit status of the pipeline (false; echo one) | cat is zero.

-f
The shell shall disable pathname expansion.
-h
Locate and remember utilities invoked by functions as those functions are defined (the utilities are normally located when the function is executed).
-m
This option shall be supported if the implementation supports the User Portability Utilities option. All jobs shall be run in their own process groups. Immediately before the shell issues a prompt after completion of the background job, a message reporting the exit status of the background job shall be written to standard error. If a foreground job stops, the shell shall write a message to standard error to that effect, formatted as described by the jobs utility. In addition, if a job changes status other than exiting (for example, if it stops for input or output or is stopped by a SIGSTOP signal), the shell shall write a similar message immediately prior to writing the next prompt. This option is enabled by default for interactive shells.
-n
The shell shall read commands but does not execute them; this can be used to check for shell script syntax errors. An interactive shell may ignore this option.
-o
Write the current settings of the options to standard output in an unspecified format.
+o
Write the current option settings to standard output in a format that is suitable for reinput to the shell as commands that achieve the same options settings.
-o  option
This option is supported if the system supports the User Portability Utilities option. It shall set various options, many of which shall be equivalent to the single option letters. The following values of option shall be supported:
allexport
Equivalent to -a.
errexit
Equivalent to -e.
ignoreeof
Prevent an interactive shell from exiting on end-of-file. This setting prevents accidental logouts when <control>-D is entered. A user shall explicitly exit to leave the interactive shell.
monitor
Equivalent to -m. This option is supported if the system supports the User Portability Utilities option.
noclobber
Equivalent to -C (uppercase C).
noglob
Equivalent to -f.
noexec
Equivalent to -n.
nolog
Prevent the entry of function definitions into the command history; see Command History List.
notify
Equivalent to -b.
nounset
Equivalent to -u.
verbose
Equivalent to -v.
vi
Allow shell command line editing using the built-in vi editor. Enabling vi mode shall disable any other command line editing mode provided as an implementation extension.
It need not be possible to set vi mode on for certain block-mode terminals.

xtrace
Equivalent to -x.
-u
When the shell tries to expand an unset parameter other than the '@' and '*' special parameters, it shall write a message to standard error and the expansion shall fail with the consequences specified in Consequences of Shell Errors.
-v
The shell shall write its input to standard error as it is read.
-x
The shell shall write to standard error a trace for each command after it expands the command and before it executes it. It is unspecified whether the command that turns tracing off is traced.
The default for all these options shall be off (unset) unless stated otherwise in the description of the option or unless the shell was invoked with them on; see sh.

The remaining arguments shall be assigned in order to the positional parameters. The special parameter '#' shall be set to reflect the number of positional parameters. All positional parameters shall be unset before any new values are assigned.

If the first argument is '-', the results are unspecified.

The special argument "--" immediately following the set command name can be used to delimit the arguments if the first argument begins with '+' or '-', or to prevent inadvertent listing of all shell variables when there are no arguments. The command set -- without argument shall unset all positional parameters and set the special parameter '#' to zero.

OPTIONS
See the DESCRIPTION.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
See the DESCRIPTION.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
Successful completion.
>0
An invalid option was specified, or an error occurred.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
Application writers should avoid relying on set -e within functions. For example, in the following script:

set -e
start() {
    some_server
    echo some_server started successfully
}
start || echo >&2 some_server failed

the -e setting is ignored within the function body (because the function is a command in an AND-OR list other than the last). Therefore, if some_server fails, the function carries on to echo "some_server started successfully", and the exit status of the function is zero (which means "some_server failed" is not output).

EXAMPLES
Write out all variables and their values:

set

Set $1, $2, and $3 and set "$#" to 3:

set c a b

Turn on the -x and -v options:

set -xv

Unset all positional parameters:

set --

Set $1 to the value of x, even if it begins with '-' or '+' :

set -- "$x"

Set the positional parameters to the expansion of x, even if x expands with a leading '-' or '+' :

set -- $x

RATIONALE
The set -- form is listed specifically in the SYNOPSIS even though this usage is implied by the Utility Syntax Guidelines. The explanation of this feature removes any ambiguity about whether the set -- form might be misinterpreted as being equivalent to set without any options or arguments. The functionality of this form has been adopted from the KornShell. In System V, set -- only unsets parameters if there is at least one argument; the only way to unset all parameters is to use shift. Using the KornShell version should not affect System V scripts because there should be no reason to issue it without arguments deliberately; if it were issued as, for example:

set -- "$@"

and there were in fact no arguments resulting from "$@", unsetting the parameters would have no result.

The set + form in early proposals was omitted as being an unnecessary duplication of set alone and not widespread historical practice.

The noclobber option was changed to allow set -C as well as the set -o noclobber option. The single-letter version was added so that the historical "$-" paradigm would not be broken; see Special Parameters.

The description of the -e option is intended to match the behavior of the 1988 version of the KornShell.

The -h flag is related to command name hashing. See hash.

The following set flags were omitted intentionally with the following rationale:

-k
The -k flag was originally added by the author of the Bourne shell to make it easier for users of pre-release versions of the shell. In early versions of the Bourne shell the construct set name= value had to be used to assign values to shell variables. The problem with -k is that the behavior affects parsing, virtually precluding writing any compilers. To explain the behavior of -k, it is necessary to describe the parsing algorithm, which is implementation-defined. For example:
set -k; echo name=value
and:

set -k
echo name=value
behave differently. The interaction with functions is even more complex. What is more, the -k flag is never needed, since the command line could have been reordered.

-t
The -t flag is hard to specify and almost never used. The only known use could be done with here-documents. Moreover, the behavior with ksh and sh differs. The reference page says that it exits after reading and executing one command. What is one command? If the input is date; date, sh executes both date commands while ksh does only the first.
Consideration was given to rewriting set to simplify its confusing syntax. A specific suggestion was that the unset utility should be used to unset options instead of using the non- getopt() -able + option syntax. However, the conclusion was reached that the historical practice of using + option was satisfactory and that there was no compelling reason to modify such widespread historical practice.

The -o option was adopted from the KornShell to address user needs. In addition to its generally friendly interface, -o is needed to provide the vi command line editing mode, for which historical practice yields no single-letter option name. (Although it might have been possible to invent such a letter, it was recognized that other editing modes would be developed and -o provides ample name space for describing such extensions.)

Historical implementations are inconsistent in the format used for -o option status reporting. The +o format without an option-argument was added to allow portable access to the options that can be saved and then later restored using, for instance, a dot script.

Historically, sh did trace the command set +x, but ksh did not.

The ignoreeof setting prevents accidental logouts when the end-of-file character (typically <control>-D) is entered. A user shall explicitly exit to leave the interactive shell.

The set -m option was added to apply only to the UPE because it applies primarily to interactive use, not shell script applications.

The ability to do asynchronous notification became available in the 1988 version of the KornShell. To have it occur, the user had to issue the command:

trap "jobs -n" CLD

The C shell provides two different levels of an asynchronous notification capability. The environment variable notify is analogous to what is done in set -b or set -o notify. When set, it notifies the user immediately of background job completions. When unset, this capability is turned off.

The other notification ability comes through the built-in utility notify. The syntax is:

notify [%job ... ]
By issuing notify with no operands, it causes the C shell to notify the user asynchronously when the state of the current job changes. If given operands, notify asynchronously informs the user of changes in the states of the specified jobs.

To add asynchronous notification to the POSIX shell, neither the KornShell extensions to trap, nor the C shell notify environment variable seemed appropriate (notify is not a proper POSIX environment variable name).

The set -b option was selected as a compromise.

The notify built-in was considered to have more functionality than was required for simple asynchronous notification.

Historically, some shells applied the -u option to all parameters including $@ and $*. The standard developers felt that this was a misfeature since it is normal and common for $@ and $* to be used in shell scripts regardless of whether they were passed any arguments. Treating these uses as an error when no arguments are passed reduces the value of -u for its intended purpose of finding spelling mistakes in variable names and uses of unset positional parameters.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities, hash

XBD Variable Assignment, Utility Syntax Guidelines

CHANGE HISTORY
Issue 6
The obsolescent set command name followed by '-' has been removed.

The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:

The nolog option is added to set -o.

IEEE PASC Interpretation 1003.2 #167 is applied, clarifying that the options default also takes into account the description of the option.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/8 is applied, changing the square brackets in the example in RATIONALE to be in bold, which is the typeface used for optional items.

Issue 7
Austin Group Interpretation 1003.1-2001 #027 is applied, clarifying the behavior if the first argument is '-'.

SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

XSI shading is removed from the -h functionality.

POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0046 [52], XCU/TC1-2008/0047 [155,280], XCU/TC1-2008/0048 [52], XCU/TC1-2008/0049 [52], and XCU/TC1-2008/0050 [155,430] are applied.

POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0053 [584], XCU/TC2-2008/0054 [717], XCU/TC2-2008/0055 [717], and XCU/TC2-2008/0056 [960] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
shift - shift positional parameters
SYNOPSIS
shift [n]

DESCRIPTION
The positional parameters shall be shifted. Positional parameter 1 shall be assigned the value of parameter (1+n), parameter 2 shall be assigned the value of parameter (2+n), and so on. The parameters represented by the numbers "$#" down to "$#-n+1" shall be unset, and the parameter '#' is updated to reflect the new number of positional parameters.

The value n shall be an unsigned decimal integer less than or equal to the value of the special parameter '#'. If n is not given, it shall be assumed to be 1. If n is 0, the positional and special parameters are not changed.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
If the n operand is invalid or is greater than "$#", this may be considered a syntax error and a non-interactive shell may exit; if the shell does not exit in this case, a non-zero exit status shall be returned. Otherwise, zero shall be returned.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
$ set a b c d e
$ shift 2
$ echo $*
c d e

RATIONALE
None.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0051 [459] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
times - write process times
SYNOPSIS
times

DESCRIPTION
The times utility shall write the accumulated user and system times for the shell and for all of its child processes, in the following POSIX locale format:

"%dm%fs %dm%fs\n%dm%fs %dm%fs\n", <shell user minutes>,
    <shell user seconds>, <shell system minutes>,
    <shell system seconds>, <children user minutes>,
    <children user seconds>, <children system minutes>,
    <children system seconds>

The four pairs of times shall correspond to the members of the <sys/times.h> tms structure (defined in XBD Headers) as returned by times(): tms_utime, tms_stime, tms_cutime, and tms_cstime, respectively.

OPTIONS
None.

OPERANDS
None.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
See the DESCRIPTION.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
$ times
0m0.43s 0m1.11s
8m44.18s 1m43.23s

RATIONALE
The times special built-in from the Single UNIX Specification is now required for all conforming shells.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

XBD <sys/times.h>

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/9 is applied, changing text in the DESCRIPTION from: "Write the accumulated user and system times for the shell and for all of its child processes ..." to: "The times utility shall write the accumulated user and system times for the shell and for all of its child processes ...".

Issue 7
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0056 [960] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
trap - trap signals
SYNOPSIS
trap n [condition...]trap [action condition...]

DESCRIPTION
If the first operand is an unsigned decimal integer, the shell shall treat all operands as conditions, and shall reset each condition to the default value. Otherwise, if there are operands, the first is treated as an action and the remaining as conditions.

If action is '-', the shell shall reset each condition to the default value. If action is null ( "" ), the shell shall ignore each specified condition if it arises. Otherwise, the argument action shall be read and executed by the shell when one of the corresponding conditions arises. The action of trap shall override a previous action (either default action or one explicitly set). The value of "$?" after the trap action completes shall be the value it had before trap was invoked.

The condition can be EXIT, 0 (equivalent to EXIT), or a signal specified using a symbolic name, without the SIG prefix, as listed in the tables of signal names in the <signal.h> header defined in XBD Headers; for example, HUP, INT, QUIT, TERM. Implementations may permit names with the SIG prefix or ignore case in signal names as an extension. Setting a trap for SIGKILL or SIGSTOP produces undefined results.

The environment in which the shell executes a trap on EXIT shall be identical to the environment immediately after the last command executed before the trap on EXIT was taken.

Each time trap is invoked, the action argument shall be processed in a manner equivalent to:

eval action
Signals that were ignored on entry to a non-interactive shell cannot be trapped or reset, although no error need be reported when attempting to do so. An interactive shell may reset or catch signals ignored on entry. Traps shall remain in place for a given shell until explicitly changed with another trap command.

When a subshell is entered, traps that are not being ignored shall be set to the default actions, except in the case of a command substitution containing only a single trap command, when the traps need not be altered. Implementations may check for this case using only lexical analysis; for example, if `trap` and $( trap -- ) do not alter the traps in the subshell, cases such as assigning var=trap and then using $($var) may still alter them. This does not imply that the trap command cannot be used within the subshell to set new traps.

The trap command with no operands shall write to standard output a list of commands associated with each condition. If the command is executed in a subshell, the implementation does not perform the optional check described above for a command substitution containing only a single trap command, and no trap commands with operands have been executed since entry to the subshell, the list shall contain the commands that were associated with each condition immediately before the subshell environment was entered. Otherwise, the list shall contain the commands currently associated with each condition. The format shall be:

"trap -- %s %s ...\n", <action>, <condition> ...

The shell shall format the output, including the proper use of quoting, so that it is suitable for reinput to the shell as commands that achieve the same trapping results. For example:

save_traps=$(trap)
...
eval "$save_traps"

[XSI] [Option Start] XSI-conformant systems also allow numeric signal numbers for the conditions corresponding to the following signal names:

1
SIGHUP
2
SIGINT
3
SIGQUIT
6
SIGABRT
9
SIGKILL
14
SIGALRM
15
SIGTERM
[Option End]
The trap special built-in shall conform to XBD Utility Syntax Guidelines.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
See the DESCRIPTION.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
If the trap name [XSI] [Option Start]  or number [Option End] is invalid, a non-zero exit status shall be returned; otherwise, zero shall be returned. For both interactive and non-interactive shells, invalid signal names [XSI] [Option Start]  or numbers [Option End] shall not be considered a syntax error and do not cause the shell to abort.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
Write out a list of all traps and actions:

trap

Set a trap so the logout utility in the directory referred to by the HOME environment variable executes when the shell terminates:

trap '"$HOME"/logout' EXIT

or:

trap '"$HOME"/logout' 0

Unset traps on INT, QUIT, TERM, and EXIT:

trap - INT QUIT TERM EXIT

RATIONALE
Implementations may permit lowercase signal names as an extension. Implementations may also accept the names with the SIG prefix; no known historical shell does so. The trap and kill utilities in this volume of POSIX.1-2008 are now consistent in their omission of the SIG prefix for signal names. Some kill implementations do not allow the prefix, and kill -l lists the signals without prefixes.

Trapping SIGKILL or SIGSTOP is syntactically accepted by some historical implementations, but it has no effect. Portable POSIX applications cannot attempt to trap these signals.

The output format is not historical practice. Since the output of historical trap commands is not portable (because numeric signal values are not portable) and had to change to become so, an opportunity was taken to format the output in a way that a shell script could use to save and then later reuse a trap if it wanted.

The KornShell uses an ERR trap that is triggered whenever set -e would cause an exit. This is allowable as an extension, but was not mandated, as other shells have not used it.

The text about the environment for the EXIT trap invalidates the behavior of some historical versions of interactive shells which, for example, close the standard input before executing a trap on 0. For example, in some historical interactive shell sessions the following trap on 0 would always print "--" :

trap 'read foo; echo "-$foo-"' 0

The command:

trap 'eval " $cmd"' 0

causes the contents of the shell variable cmd to be executed as a command when the shell exits. Using:

trap '$cmd' 0

does not work correctly if cmd contains any special characters such as quoting or redirections. Using:

trap " $cmd" 0

also works (the leading <space> character protects against unlikely cases where cmd is a decimal integer or begins with '-' ), but it expands the cmd variable when the trap command is executed, not when the exit action is executed.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

XBD Utility Syntax Guidelines, <signal.h>

CHANGE HISTORY
Issue 6
XSI-conforming implementations provide the mapping of signal names to numbers given above (previously this had been marked obsolescent). Other implementations need not provide this optional mapping.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

Austin Group Interpretation 1003.1-2001 #116 is applied.

POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0052 [53,268,440], XCU/TC1-2008/0053 [53,268,440], XCU/TC1-2008/0054 [163], XCU/TC1-2008/0055 [163], and XCU/TC1-2008/0056 [163] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
unset - unset values and attributes of variables and functions
SYNOPSIS
unset [-fv] name...

DESCRIPTION
Each variable or function specified by name shall be unset.

If -v is specified, name refers to a variable name and the shell shall unset it and remove it from the environment. Read-only variables cannot be unset.

If -f is specified, name refers to a function and the shell shall unset the function definition.

If neither -f nor -v is specified, name refers to a variable; if a variable by that name does not exist, it is unspecified whether a function by that name, if any, shall be unset.

Unsetting a variable or function that was not previously set shall not be considered an error and does not cause the shell to abort.

The unset special built-in shall support XBD Utility Syntax Guidelines.

Note that:

VARIABLE=

is not equivalent to an unset of VARIABLE; in the example, VARIABLE is set to "". Also, the variables that can be unset should not be misinterpreted to include the special parameters (see Special Parameters).

OPTIONS
See the DESCRIPTION.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
All name operands were successfully unset.
>0
At least one name could not be unset.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
Unset VISUAL variable:

unset -v VISUAL

Unset the functions foo and bar:

unset -f foo bar

RATIONALE
Consideration was given to omitting the -f option in favor of an unfunction utility, but the standard developers decided to retain historical practice.

The -v option was introduced because System V historically used one name space for both variables and functions. When unset is used without options, System V historically unset either a function or a variable, and there was no confusion about which one was intended. A portable POSIX application can use unset without an option to unset a variable, but not a function; the -f option must be used.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

XBD Utility Syntax Guidelines

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

End of informative text.
<<< Previous	Home	Next >>>


<<< Previous	Home	Next >>>
The Open Group Base Specifications Issue 7
IEEE Std 1003.1-2008, 2016 Edition
Copyright  2001-2016 The IEEE and The Open Group
2. Shell Command Language
This chapter contains the definition of the Shell Command Language.

2.1 Shell Introduction
The shell is a command language interpreter. This chapter describes the syntax of that command language as it is used by the sh utility and the system() and popen() functions defined in the System Interfaces volume of POSIX.1-2008.

The shell operates according to the following general overview of operations. The specific details are included in the cited sections of this chapter.

The shell reads its input from a file (see sh), from the -c option or from the system() and popen() functions defined in the System Interfaces volume of POSIX.1-2008. If the first line of a file of shell commands starts with the characters "#!", the results are unspecified.

The shell breaks the input into tokens: words and operators; see Token Recognition.

The shell parses the input into simple commands (see Simple Commands) and compound commands (see Compound Commands).

The shell performs various expansions (separately) on different parts of each command, resulting in a list of pathnames and fields to be treated as a command and arguments; see wordexp.

The shell performs redirection (see Redirection) and removes redirection operators and their operands from the parameter list.

The shell executes a function (see Function Definition Command), built-in (see Special Built-In Utilities), executable file, or script, giving the names of the arguments as positional parameters numbered 1 to n, and the name of the command (or in the case of a function within a script, the name of the script) as the positional parameter numbered 0 (see Command Search and Execution).

The shell optionally waits for the command to complete and collects the exit status (see Exit Status for Commands).

2.2 Quoting
Quoting is used to remove the special meaning of certain characters or words to the shell. Quoting can be used to preserve the literal meaning of the special characters in the next paragraph, prevent reserved words from being recognized as such, and prevent parameter expansion and command substitution within here-document processing (see Here-Document).

The application shall quote the following characters if they are to represent themselves:

|  &  ;  <  >  (  )  $  `  \  "  '  <space>  <tab>  <newline>

and the following may need to be quoted under certain circumstances. That is, these characters may be special depending on conditions described elsewhere in this volume of POSIX.1-2008:

*   ?   [   #      =   %

The various quoting mechanisms are the escape character, single-quotes, and double-quotes. The here-document represents another form of quoting; see Here-Document.

2.2.1 Escape Character (Backslash)
A <backslash> that is not quoted shall preserve the literal value of the following character, with the exception of a <newline>. If a <newline> follows the <backslash>, the shell shall interpret this as line continuation. The <backslash> and <newline> shall be removed before splitting the input into tokens. Since the escaped <newline> is removed entirely from the input and is not replaced by any white space, it cannot serve as a token separator.

2.2.2 Single-Quotes
Enclosing characters in single-quotes ( '' ) shall preserve the literal value of each character within the single-quotes. A single-quote cannot occur within single-quotes.

2.2.3 Double-Quotes
Enclosing characters in double-quotes ( "" ) shall preserve the literal value of all characters within the double-quotes, with the exception of the characters backquote, <dollar-sign>, and <backslash>, as follows:

$
The <dollar-sign> shall retain its special meaning introducing parameter expansion (see Parameter Expansion), a form of command substitution (see Command Substitution), and arithmetic expansion (see Arithmetic Expansion).
The input characters within the quoted string that are also enclosed between "$(" and the matching ')' shall not be affected by the double-quotes, but rather shall define that command whose output replaces the "$(...)" when the word is expanded. The tokenizing rules in Token Recognition, not including the alias substitutions in Alias Substitution, shall be applied recursively to find the matching ')'.

Within the string of characters from an enclosed "${" to the matching '}', an even number of unescaped double-quotes or single-quotes, if any, shall occur. A preceding <backslash> character shall be used to escape a literal '{' or '}'. The rule in Parameter Expansion shall be used to determine the matching '}'.

`
The backquote shall retain its special meaning introducing the other form of command substitution (see Command Substitution). The portion of the quoted string from the initial backquote and the characters up to the next backquote that is not preceded by a <backslash>, having escape characters removed, defines that command whose output replaces "`...`" when the word is expanded. Either of the following cases produces undefined results:
A single-quoted or double-quoted string that begins, but does not end, within the "`...`" sequence

A "`...`" sequence that begins, but does not end, within the same double-quoted string

\
The <backslash> shall retain its special meaning as an escape character (see Escape Character (Backslash)) only when followed by one of the following characters when considered special:
$   `   "   \   <newline>

The application shall ensure that a double-quote is preceded by a <backslash> to be included within double-quotes. The parameter '@' has special meaning inside double-quotes and is described in Special Parameters .

2.3 Token Recognition
The shell shall read its input in terms of lines. (For details about how the shell reads its input, see the description of sh.) The input lines can be of unlimited length. These lines shall be parsed using two major modes: ordinary token recognition and processing of here-documents.

When an io_here token has been recognized by the grammar (see Shell Grammar), one or more of the subsequent lines immediately following the next NEWLINE token form the body of one or more here-documents and shall be parsed according to the rules of Here-Document.

When it is not processing an io_here, the shell shall break its input into tokens by applying the first applicable rule below to the next character in its input. The token shall be from the current position in the input until a token is delimited according to one of the rules below; the characters forming the token are exactly those in the input, including any quoting characters. If it is indicated that a token is delimited, and no characters have been included in a token, processing shall continue until an actual token is delimited.

If the end of input is recognized, the current token (if any) shall be delimited.

If the previous character was used as part of an operator and the current character is not quoted and can be used with the previous characters to form an operator, it shall be used as part of that (operator) token.

If the previous character was used as part of an operator and the current character cannot be used with the previous characters to form an operator, the operator containing the previous character shall be delimited.

If the current character is <backslash>, single-quote, or double-quote and it is not quoted, it shall affect quoting for subsequent characters up to the end of the quoted text. The rules for quoting are as described in Quoting . During token recognition no substitutions shall be actually performed, and the result token shall contain exactly the characters that appear in the input (except for <newline> joining), unmodified, including any embedded or enclosing quotes or substitution operators, between the <quotation-mark> and the end of the quoted text. The token shall not be delimited by the end of the quoted field.

If the current character is an unquoted '$' or '`', the shell shall identify the start of any candidates for parameter expansion (Parameter Expansion), command substitution (Command Substitution), or arithmetic expansion (Arithmetic Expansion) from their introductory unquoted character sequences: '$' or "${", "$(" or '`', and "$((", respectively. The shell shall read sufficient input to determine the end of the unit to be expanded (as explained in the cited sections). While processing the characters, if instances of expansions or quoting are found nested within the substitution, the shell shall recursively process them in the manner specified for the construct that is found. The characters found from the beginning of the substitution to its end, allowing for any recursion necessary to recognize embedded constructs, shall be included unmodified in the result token, including any embedded or enclosing substitution operators or quotes. The token shall not be delimited by the end of the substitution.

If the current character is not quoted and can be used as the first character of a new operator, the current token (if any) shall be delimited. The current character shall be used as the beginning of the next (operator) token.

If the current character is an unquoted <blank>, any token containing the previous character is delimited and the current character shall be discarded.

If the previous character was part of a word, the current character shall be appended to that word.

If the current character is a '#', it and all subsequent characters up to, but excluding, the next <newline> shall be discarded as a comment. The <newline> that ends the line is not considered part of the comment.

The current character is used as the start of a new word.

Once a token is delimited, it is categorized as required by the grammar in Shell Grammar.

2.3.1 Alias Substitution
After a token has been delimited, but before applying the grammatical rules in Shell Grammar, a resulting word that is identified to be the command name word of a simple command shall be examined to determine whether it is an unquoted, valid alias name. However, reserved words in correct grammatical context shall not be candidates for alias substitution. A valid alias name (see XBD Alias Name) shall be one that has been defined by the alias utility and not subsequently undefined using unalias. Implementations also may provide predefined valid aliases that are in effect when the shell is invoked. To prevent infinite loops in recursive aliasing, if the shell is not currently processing an alias of the same name, the word shall be replaced by the value of the alias; otherwise, it shall not be replaced.

If the value of the alias replacing the word ends in a <blank>, the shell shall check the next command word for alias substitution; this process shall continue until a word is found that is not a valid alias or an alias value does not end in a <blank>.

When used as specified by this volume of POSIX.1-2008, alias definitions shall not be inherited by separate invocations of the shell or by the utility execution environments invoked by the shell; see Shell Execution Environment.

2.4 Reserved Words
Reserved words are words that have special meaning to the shell; see Shell Commands. The following words shall be recognized as reserved words:


!
{
}
case


do
done
elif
else


esac
fi
for
if


in
then
until
while

This recognition shall only occur when none of the characters is quoted and when the word is used as:

The first word of a command

The first word following one of the reserved words other than case, for, or in

The third word in a case command (only in is valid in this case)

The third word in a for command (only in and do are valid in this case)

See the grammar in Shell Grammar.

The following words may be recognized as reserved words on some implementations (when none of the characters are quoted), causing unspecified results:

[[

]]

function

select

Words that are the concatenation of a name and a <colon> ( ':' ) are reserved; their use produces unspecified results.

2.5 Parameters and Variables
A parameter can be denoted by a name, a number, or one of the special characters listed in Special Parameters. A variable is a parameter denoted by a name.

A parameter is set if it has an assigned value (null is a valid value). Once a variable is set, it can only be unset by using the unset special built-in command.

2.5.1 Positional Parameters
A positional parameter is a parameter denoted by the decimal value represented by one or more digits, other than the single digit 0. The digits denoting the positional parameters shall always be interpreted as a decimal value, even if there is a leading zero. When a positional parameter with more than one digit is specified, the application shall enclose the digits in braces (see Parameter Expansion). Positional parameters are initially assigned when the shell is invoked (see sh), temporarily replaced when a shell function is invoked (see Function Definition Command), and can be reassigned with the set special built-in command.

2.5.2 Special Parameters
Listed below are the special parameters and the values to which they shall expand. Only the values of the special parameters are listed; see wordexp for a detailed summary of all the stages involved in expanding words.

@
Expands to the positional parameters, starting from one, initially producing one field for each positional parameter that is set. When the expansion occurs in a context where field splitting will be performed, any empty fields may be discarded and each of the non-empty fields shall be further split as described in Field Splitting. When the expansion occurs within double-quotes, the behavior is unspecified unless one of the following is true:
Field splitting as described in Field Splitting would be performed if the expansion were not within double-quotes (regardless of whether field splitting would have any effect; for example, if IFS is null).

The double-quotes are within the word of a ${parameter:-word} or a ${parameter:+word} expansion (with or without the <colon>; see Parameter Expansion) which would have been subject to field splitting if parameter had been expanded instead of word.

If one of these conditions is true, the initial fields shall be retained as separate fields, except that if the parameter being expanded was embedded within a word, the first field shall be joined with the beginning part of the original word and the last field shall be joined with the end part of the original word. In all other contexts the results of the expansion are unspecified. If there are no positional parameters, the expansion of '@' shall generate zero fields, even when '@' is within double-quotes; however, if the expansion is embedded within a word which contains one or more other parts that expand to a quoted null string, these null string(s) shall still produce an empty field, except that if the other parts are all within the same double-quotes as the '@', it is unspecified whether the result is zero fields or one empty field.

*
Expands to the positional parameters, starting from one, initially producing one field for each positional parameter that is set. When the expansion occurs in a context where field splitting will be performed, any empty fields may be discarded and each of the non-empty fields shall be further split as described in Field Splitting. When the expansion occurs in a context where field splitting will not be performed, the initial fields shall be joined to form a single field with the value of each parameter separated by the first character of the IFS variable if IFS contains at least one character, or separated by a <space> if IFS is unset, or with no separation if IFS is set to a null string.
#
Expands to the decimal number of positional parameters. The command name (parameter 0) shall not be counted in the number given by '#' because it is a special parameter, not a positional parameter.
?
Expands to the decimal exit status of the most recent pipeline (see Pipelines).
-
(Hyphen.) Expands to the current option flags (the single-letter option names concatenated into a string) as specified on invocation, by the set special built-in command, or implicitly by the shell.
$
Expands to the decimal process ID of the invoked shell. In a subshell (see Shell Execution Environment ), '$' shall expand to the same value as that of the current shell.
!
Expands to the decimal process ID of the most recent background command (see Lists) executed from the current shell. (For example, background commands executed from subshells do not affect the value of "$!" in the current shell environment.) For a pipeline, the process ID is that of the last command in the pipeline.
0
(Zero.) Expands to the name of the shell or shell script. See sh for a detailed description of how this name is derived.
See the description of the IFS variable in Shell Variables.

2.5.3 Shell Variables
Variables shall be initialized from the environment (as defined by XBD Environment Variables and the exec function in the System Interfaces volume of POSIX.1-2008) and can be given new values with variable assignment commands. If a variable is initialized from the environment, it shall be marked for export immediately; see the export special built-in. New variables can be defined and initialized with variable assignments, with the read or getopts utilities, with the name parameter in a for loop, with the ${ name= word} expansion, or with other mechanisms provided as implementation extensions.
The following variables shall affect the execution of the shell:

ENV
[UP] [Option Start] The processing of the ENV shell variable shall be supported if the system supports the User Portability Utilities option. [Option End]
This variable, when and only when an interactive shell is invoked, shall be subjected to parameter expansion (see Parameter Expansion) by the shell and the resulting value shall be used as a pathname of a file containing shell commands to execute in the current environment. The file need not be executable. If the expanded value of ENV is not an absolute pathname, the results are unspecified. ENV shall be ignored if the user's real and effective user IDs or real and effective group IDs are different.

HOME
The pathname of the user's home directory. The contents of HOME are used in tilde expansion (see Tilde Expansion).
IFS
A string treated as a list of characters that is used for field splitting, expansion of the '*' special parameter, and to split lines into fields with the read utility. If the value of IFS includes any bytes that do not form part of a valid character, the results of field splitting, expansion of '*', and use of the read utility are unspecified.
If IFS is not set, it shall behave as normal for an unset variable, except that field splitting by the shell and line splitting by the read utility shall be performed as if the value of IFS is <space> <tab> <newline>; see Field Splitting.

The shell shall set IFS to <space> <tab> <newline> when it is invoked.

LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD Internationalization Variables for the precedence of internationalization variables used to determine the values of locale categories.)
LC_ALL
The value of this variable overrides the LC_* variables and LANG, as described in XBD Environment Variables.
LC_COLLATE
Determine the behavior of range expressions, equivalence classes, and multi-character collating elements within pattern matching.
LC_CTYPE
Determine the interpretation of sequences of bytes of text data as characters (for example, single-byte as opposed to multi-byte characters), which characters are defined as letters (character class alpha) and <blank> characters (character class blank), and the behavior of character classes within pattern matching. Changing the value of LC_CTYPE after the shell has started shall not affect the lexical processing of shell commands in the current shell execution environment or its subshells. Invoking a shell script or performing exec sh subjects the new shell to the changes in LC_CTYPE.
LC_MESSAGES
Determine the language in which messages should be written.
LINENO
Set by the shell to a decimal number representing the current sequential line number (numbered starting with 1) within a script or function before it executes each command. If the user unsets or resets LINENO, the variable may lose its special meaning for the life of the shell. If the shell is not currently executing a script or function, the value of LINENO is unspecified. This volume of POSIX.1-2008 specifies the effects of the variable only for systems supporting the User Portability Utilities option.
NLSPATH
[XSI] [Option Start] Determine the location of message catalogs for the processing of LC_MESSAGES. [Option End]
PATH
A string formatted as described in XBD Environment Variables, used to effect command interpretation; see Command Search and Execution.
PPID
Set by the shell to the decimal value of its parent process ID during initialization of the shell. In a subshell (see Shell Execution Environment), PPID shall be set to the same value as that of the parent of the current shell. For example, echo $ PPID and (echo $ PPID) would produce the same value.
PS1
Each time an interactive shell is ready to read a command, the value of this variable shall be subjected to parameter expansion and written to standard error. The default value shall be "$ ". For users who have specific additional implementation-defined privileges, the default may be another, implementation-defined value. The shell shall replace each instance of the character '!' in PS1 with the history file number of the next command to be typed. Escaping the '!' with another '!' (that is, "!!" ) shall place the literal character '!' in the prompt. This volume of POSIX.1-2008 specifies the effects of the variable only for systems supporting the User Portability Utilities option.
PS2
Each time the user enters a <newline> prior to completing a command line in an interactive shell, the value of this variable shall be subjected to parameter expansion and written to standard error. The default value is "> ". This volume of POSIX.1-2008 specifies the effects of the variable only for systems supporting the User Portability Utilities option.
PS4
When an execution trace (set -x) is being performed in an interactive shell, before each line in the execution trace, the value of this variable shall be subjected to parameter expansion and written to standard error. The default value is "+ ". This volume of POSIX.1-2008 specifies the effects of the variable only for systems supporting the User Portability Utilities option.
PWD
Set by the shell and by the cd utility. In the shell the value shall be initialized from the environment as follows. If a value for PWD is passed to the shell in the environment when it is executed, the value is an absolute pathname of the current working directory that is no longer than {PATH_MAX} bytes including the terminating null byte, and the value does not contain any components that are dot or dot-dot, then the shell shall set PWD to the value from the environment. Otherwise, if a value for PWD is passed to the shell in the environment when it is executed, the value is an absolute pathname of the current working directory, and the value does not contain any components that are dot or dot-dot, then it is unspecified whether the shell sets PWD to the value from the environment or sets PWD to the pathname that would be output by pwd -P. Otherwise, the sh utility sets PWD to the pathname that would be output by pwd -P. In cases where PWD is set to the value from the environment, the value can contain components that refer to files of type symbolic link. In cases where PWD is set to the pathname that would be output by pwd -P, if there is insufficient permission on the current working directory, or on any parent of that directory, to determine what that pathname would be, the value of PWD is unspecified. Assignments to this variable may be ignored. If an application sets or unsets the value of PWD, the behaviors of the cd and pwd utilities are unspecified.
2.6 Word Expansions
This section describes the various expansions that are performed on words. Not all expansions are performed on every word, as explained in the following sections.

Tilde expansions, parameter expansions, command substitutions, arithmetic expansions, and quote removals that occur within a single word expand to a single field. It is only field splitting or pathname expansion that can create multiple fields from a single word. The single exception to this rule is the expansion of the special parameter '@' within double-quotes, as described in Special Parameters.

The order of word expansion shall be as follows:

Tilde expansion (see Tilde Expansion), parameter expansion (see Parameter Expansion), command substitution (see Command Substitution), and arithmetic expansion (see Arithmetic Expansion) shall be performed, beginning to end. See item 5 in Token Recognition.

Field splitting (see Field Splitting) shall be performed on the portions of the fields generated by step 1, unless IFS is null.

Pathname expansion (see Pathname Expansion) shall be performed, unless set -f is in effect.

Quote removal (see Quote Removal) shall always be performed last.

The expansions described in this section shall occur in the same shell environment as that in which the command is executed.

If the complete expansion appropriate for a word results in an empty field, that empty field shall be deleted from the list of fields that form the completely expanded command, unless the original word contained single-quote or double-quote characters.

The '$' character is used to introduce parameter expansion, command substitution, or arithmetic evaluation. If an unquoted '$' is followed by a character that is not one of the following:

A numeric character

The name of one of the special parameters (see Special Parameters)

A valid first character of a variable name

A <left-curly-bracket> ( '{' )

A <left-parenthesis>

the result is unspecified.

2.6.1 Tilde Expansion
A "tilde-prefix" consists of an unquoted <tilde> character at the beginning of a word, followed by all of the characters preceding the first unquoted <slash> in the word, or all the characters in the word if there is no <slash>. In an assignment (see XBD Variable Assignment), multiple tilde-prefixes can be used: at the beginning of the word (that is, following the <equals-sign> of the assignment), following any unquoted <colon>, or both. A tilde-prefix in an assignment is terminated by the first unquoted <colon> or <slash>. If none of the characters in the tilde-prefix are quoted, the characters in the tilde-prefix following the <tilde> are treated as a possible login name from the user database. A portable login name cannot contain characters outside the set given in the description of the LOGNAME environment variable in XBD Other Environment Variables. If the login name is null (that is, the tilde-prefix contains only the tilde), the tilde-prefix is replaced by the value of the variable HOME. If HOME is unset, the results are unspecified. Otherwise, the tilde-prefix shall be replaced by a pathname of the initial working directory associated with the login name obtained using the getpwnam() function as defined in the System Interfaces volume of POSIX.1-2008. If the system does not recognize the login name, the results are undefined.

The pathname resulting from tilde expansion shall be treated as if quoted to prevent it being altered by field splitting and pathname expansion.

2.6.2 Parameter Expansion
The format for parameter expansion is as follows:

${expression}

where expression consists of all characters until the matching '}'. Any '}' escaped by a <backslash> or within a quoted string, and characters in embedded arithmetic expansions, command substitutions, and variable expansions, shall not be examined in determining the matching '}'.

The simplest form for parameter expansion is:

${parameter}

The value, if any, of parameter shall be substituted.

The parameter name or symbol can be enclosed in braces, which are optional except for positional parameters with more than one digit or when parameter is a name and is followed by a character that could be interpreted as part of the name. The matching closing brace shall be determined by counting brace levels, skipping over enclosed quoted strings, and command substitutions.

If the parameter is not enclosed in braces, and is a name, the expansion shall use the longest valid name (see XBD Name), whether or not the variable represented by that name exists. Otherwise, the parameter is a single-character symbol, and behavior is unspecified if that character is neither a digit nor one of the special parameters (see Special Parameters).

If a parameter expansion occurs inside double-quotes:

Pathname expansion shall not be performed on the results of the expansion.

Field splitting shall not be performed on the results of the expansion.

In addition, a parameter expansion can be modified by using one of the following formats. In each case that a value of word is needed (based on the state of parameter, as described below), word shall be subjected to tilde expansion, parameter expansion, command substitution, and arithmetic expansion. If word is not needed, it shall not be expanded. The '}' character that delimits the following parameter expansion modifications shall be determined as described previously in this section and in Double-Quotes.

${parameter:-[word]}
Use Default Values. If parameter is unset or null, the expansion of word (or an empty string if word is omitted) shall be substituted; otherwise, the value of parameter shall be substituted.
${parameter:=[word]}
Assign Default Values. If parameter is unset or null, the expansion of word (or an empty string if word is omitted) shall be assigned to parameter. In all cases, the final value of parameter shall be substituted. Only variables, not positional parameters or special parameters, can be assigned in this way.
${parameter:?[word]}
Indicate Error if Null or Unset. If parameter is unset or null, the expansion of word (or a message indicating it is unset if word is omitted) shall be written to standard error and the shell exits with a non-zero exit status. Otherwise, the value of parameter shall be substituted. An interactive shell need not exit.
${parameter:+[word]}
Use Alternative Value. If parameter is unset or null, null shall be substituted; otherwise, the expansion of word (or an empty string if word is omitted) shall be substituted.
In the parameter expansions shown previously, use of the <colon> in the format shall result in a test for a parameter that is unset or null; omission of the <colon> shall result in a test for a parameter that is only unset. If parameter is '#' and the colon is omitted, the application shall ensure that word is specified (this is necessary to avoid ambiguity with the string length expansion). The following table summarizes the effect of the <colon>:

 

parameter
Set and Not Null

parameter
Set But Null

parameter
Unset

${parameter:-word}

substitute parameter

substitute word

substitute word

${parameter-word}

substitute parameter

substitute null

substitute word

${parameter:=word}

substitute parameter

assign word

assign word

${parameter=word}

substitute parameter

substitute null

assign word

${parameter:?word}

substitute parameter

error, exit

error, exit

${parameter?word}

substitute parameter

substitute null

error, exit

${parameter:+word}

substitute word

substitute null

substitute null

${parameter+word}

substitute word

substitute word

substitute null

In all cases shown with "substitute", the expression is replaced with the value shown. In all cases shown with "assign", parameter is assigned that value, which also replaces the expression.

${#parameter}
String Length. The length in characters of the value of parameter shall be substituted. If parameter is '*' or '@', the result of the expansion is unspecified. If parameter is unset and set -u is in effect, the expansion shall fail.
The following four varieties of parameter expansion provide for substring processing. In each case, pattern matching notation (see Pattern Matching Notation), rather than regular expression notation, shall be used to evaluate the patterns. If parameter is '#', '*', or '@', the result of the expansion is unspecified. If parameter is unset and set -u is in effect, the expansion shall fail. Enclosing the full parameter expansion string in double-quotes shall not cause the following four varieties of pattern characters to be quoted, whereas quoting characters within the braces shall have this effect. In each variety, if word is omitted, the empty pattern shall be used.

${parameter%[word]}
Remove Smallest Suffix Pattern. The word shall be expanded to produce a pattern. The parameter expansion shall then result in parameter, with the smallest portion of the suffix matched by the pattern deleted. If present, word shall not begin with an unquoted '%'.
${parameter%%[word]}
Remove Largest Suffix Pattern. The word shall be expanded to produce a pattern. The parameter expansion shall then result in parameter, with the largest portion of the suffix matched by the pattern deleted.
${parameter#[word]}
Remove Smallest Prefix Pattern. The word shall be expanded to produce a pattern. The parameter expansion shall then result in parameter, with the smallest portion of the prefix matched by the pattern deleted. If present, word shall not begin with an unquoted '#'.
${parameter##[word]}
Remove Largest Prefix Pattern. The word shall be expanded to produce a pattern. The parameter expansion shall then result in parameter, with the largest portion of the prefix matched by the pattern deleted.
The following sections are informative.
Examples
${parameter}
In this example, the effects of omitting braces are demonstrated.
a=1
set 2
echo ${a}b-$ab-${1}0-${10}-$10
1b--20--20
${parameter-word}
This example demonstrates the difference between unset and set to the empty string, as well as the rules for finding the delimiting close brace.
foo=asdf
echo ${foo-bar}xyz}
asdfxyz}foo=
echo ${foo-bar}xyz}
xyz}unset foo
echo ${foo-bar}xyz}
barxyz}
${parameter:-word}
In this example, ls is executed only if x is null or unset. (The $(ls) command substitution notation is explained in Command Substitution.)
${x:-$(ls)}

${parameter:=word}
unset X
echo ${X:=abc}
abc
${parameter:?word}
unset posix
echo ${posix:?}
sh: posix: parameter null or not set
${parameter:+word}
set a b c
echo ${3:+posix}
posix
${#parameter}
HOME=/usr/posix
echo ${#HOME}
10
${parameter%word}
x=file.c
echo ${x%.c}.o
file.o
${parameter%%word}
x=posix/src/std
echo ${x%%/*}
posix
${parameter#word}
x=$HOME/src/cmd
echo ${x#$HOME}
/src/cmd
${parameter##word}
x=/one/two/three
echo ${x##*/}
three
The double-quoting of patterns is different depending on where the double-quotes are placed:

"${x#*}"
The <asterisk> is a pattern character.
${x#"*"}
The literal <asterisk> is quoted and not special.
End of informative text.
2.6.3 Command Substitution
Command substitution allows the output of a command to be substituted in place of the command name itself. Command substitution shall occur when the command is enclosed as follows:

$(command)

or (backquoted version):

`command`

The shell shall expand the command substitution by executing command in a subshell environment (see Shell Execution Environment) and replacing the command substitution (the text of command plus the enclosing "$()" or backquotes) with the standard output of the command, removing sequences of one or more <newline> characters at the end of the substitution. Embedded <newline> characters before the end of the output shall not be removed; however, they may be treated as field delimiters and eliminated during field splitting, depending on the value of IFS and quoting that is in effect. If the output contains any null bytes, the behavior is unspecified.

Within the backquoted style of command substitution, <backslash> shall retain its literal meaning, except when followed by: '$', '`', or <backslash>. The search for the matching backquote shall be satisfied by the first unquoted non-escaped backquote; during this search, if a non-escaped backquote is encountered within a shell comment, a here-document, an embedded command substitution of the $(command) form, or a quoted string, undefined results occur. A single-quoted or double-quoted string that begins, but does not end, within the "`...`" sequence produces undefined results.

With the $(command) form, all characters following the open parenthesis to the matching closing parenthesis constitute the command. Any valid shell script can be used for command, except a script consisting solely of redirections which produces unspecified results.

The results of command substitution shall not be processed for further tilde expansion, parameter expansion, command substitution, or arithmetic expansion. If a command substitution occurs inside double-quotes, field splitting and pathname expansion shall not be performed on the results of the substitution.

Command substitution can be nested. To specify nesting within the backquoted version, the application shall precede the inner backquotes with <backslash> characters; for example:

\`command\`

The syntax of the shell command language has an ambiguity for expansions beginning with "$((", which can introduce an arithmetic expansion or a command substitution that starts with a subshell. Arithmetic expansion has precedence; that is, the shell shall first determine whether it can parse the expansion as an arithmetic expansion and shall only parse the expansion as a command substitution if it determines that it cannot parse the expansion as an arithmetic expansion. The shell need not evaluate nested expansions when performing this determination. If it encounters the end of input without already having determined that it cannot parse the expansion as an arithmetic expansion, the shell shall treat the expansion as an incomplete arithmetic expansion and report a syntax error. A conforming application shall ensure that it separates the "$(" and '(' into two tokens (that is, separate them with white space) in a command substitution that starts with a subshell. For example, a command substitution containing a single subshell could be written as:

$( (command) )

2.6.4 Arithmetic Expansion
Arithmetic expansion provides a mechanism for evaluating an arithmetic expression and substituting its value. The format for arithmetic expansion shall be as follows:

$((expression))

The expression shall be treated as if it were in double-quotes, except that a double-quote inside the expression is not treated specially. The shell shall expand all tokens in the expression for parameter expansion, command substitution, and quote removal.

Next, the shell shall treat this as an arithmetic expression and substitute the value of the expression. The arithmetic expression shall be processed according to the rules given in Arithmetic Precision and Operations, with the following exceptions:

Only signed long integer arithmetic is required.

Only the decimal-constant, octal-constant, and hexadecimal-constant constants specified in the ISO C standard, Section 6.4.4.1 are required to be recognized as constants.

The sizeof() operator and the prefix and postfix "++" and "--" operators are not required.

Selection, iteration, and jump statements are not supported.

All changes to variables in an arithmetic expression shall be in effect after the arithmetic expansion, as in the parameter expansion "${x=value}".

If the shell variable x contains a value that forms a valid integer constant, optionally including a leading <plus-sign> or <hyphen-minus>, then the arithmetic expansions "$((x))" and "$(($x))" shall return the same value.

As an extension, the shell may recognize arithmetic expressions beyond those listed. The shell may use a signed integer type with a rank larger than the rank of signed long. The shell may use a real-floating type instead of signed long as long as it does not affect the results in cases where there is no overflow. If the expression is invalid, or the contents of a shell variable used in the expression are not recognized by the shell, the expansion fails and the shell shall write a diagnostic message to standard error indicating the failure.

The following sections are informative.
Examples
A simple example using arithmetic expansion:

# repeat a command 100 times
x=100
while [ $x -gt 0 ]
do
    command    x=$(($x-1))
done

End of informative text.
2.6.5 Field Splitting
After parameter expansion (Parameter Expansion), command substitution (Command Substitution), and arithmetic expansion (Arithmetic Expansion), the shell shall scan the results of expansions and substitutions that did not occur in double-quotes for field splitting and multiple fields can result.

The shell shall treat each character of the IFS as a delimiter and use the delimiters as field terminators to split the results of parameter expansion, command substitution, and arithmetic expansion into fields.

If the value of IFS is a <space>, <tab>, and <newline>, or if it is unset, any sequence of <space>, <tab>, or <newline> characters at the beginning or end of the input shall be ignored and any sequence of those characters within the input shall delimit a field. For example, the input:

<newline><space><tab>foo<tab><tab>bar<space>

yields two fields, foo and bar.

If the value of IFS is null, no field splitting shall be performed.

Otherwise, the following rules shall be applied in sequence. The term " IFS white space" is used to mean any sequence (zero or more instances) of white-space characters that are in the IFS value (for example, if IFS contains <space>/ <comma>/ <tab>, any sequence of <space> and <tab> characters is considered IFS white space).

IFS white space shall be ignored at the beginning and end of the input.

Each occurrence in the input of an IFS character that is not IFS white space, along with any adjacent IFS white space, shall delimit a field, as described previously.

Non-zero-length IFS white space shall delimit a field.

2.6.6 Pathname Expansion
After field splitting, if set -f is not in effect, each field in the resulting command line shall be expanded using the algorithm described in Pattern Matching Notation, qualified by the rules in Patterns Used for Filename Expansion.

2.6.7 Quote Removal
The quote characters ( <backslash>, single-quote, and double-quote) that were present in the original word shall be removed unless they have themselves been quoted.

2.7 Redirection
Redirection is used to open and close files for the current shell execution environment (see Shell Execution Environment) or for any command. Redirection operators can be used with numbers representing file descriptors (see XBD File Descriptor) as described below.

The overall format used for redirection is:

[n]redir-op word
The number n is an optional decimal number designating the file descriptor number; the application shall ensure it is delimited from any preceding text and immediately precede the redirection operator redir-op. If n is quoted, the number shall not be recognized as part of the redirection expression. For example:

echo \2>a

writes the character 2 into file a. If any part of redir-op is quoted, no redirection expression is recognized. For example:

echo 2\>a

writes the characters 2>a to standard output. The optional number, redirection operator, and word shall not appear in the arguments provided to the command to be executed (if any).

Open files are represented by decimal numbers starting with zero. The largest possible value is implementation-defined; however, all implementations shall support at least 0 to 9, inclusive, for use by the application. These numbers are called "file descriptors". The values 0, 1, and 2 have special meaning and conventional uses and are implied by certain redirection operations; they are referred to as standard input, standard output, and standard error, respectively. Programs usually take their input from standard input, and write output on standard output. Error messages are usually written on standard error. The redirection operators can be preceded by one or more digits (with no intervening <blank> characters allowed) to designate the file descriptor number.

If the redirection operator is "<<" or "<<-", the word that follows the redirection operator shall be subjected to quote removal; it is unspecified whether any of the other expansions occur. For the other redirection operators, the word that follows the redirection operator shall be subjected to tilde expansion, parameter expansion, command substitution, arithmetic expansion, and quote removal. Pathname expansion shall not be performed on the word by a non-interactive shell; an interactive shell may perform it, but shall do so only when the expansion would result in one word.

If more than one redirection operator is specified with a command, the order of evaluation is from beginning to end.

A failure to open or create a file shall cause a redirection to fail.

2.7.1 Redirecting Input
Input redirection shall cause the file whose name results from the expansion of word to be opened for reading on the designated file descriptor, or standard input if the file descriptor is not specified.

The general format for redirecting input is:

[n]<word
where the optional n represents the file descriptor number. If the number is omitted, the redirection shall refer to standard input (file descriptor 0).

2.7.2 Redirecting Output
The two general formats for redirecting output are:

[n]>word
[n]>|word
where the optional n represents the file descriptor number. If the number is omitted, the redirection shall refer to standard output (file descriptor 1).

Output redirection using the '>' format shall fail if the noclobber option is set (see the description of set -C) and the file named by the expansion of word exists and is a regular file. Otherwise, redirection using the '>' or ">|" formats shall cause the file whose name results from the expansion of word to be created and opened for output on the designated file descriptor, or standard output if none is specified. If the file does not exist, it shall be created; otherwise, it shall be truncated to be an empty file after being opened.

2.7.3 Appending Redirected Output
Appended output redirection shall cause the file whose name results from the expansion of word to be opened for output on the designated file descriptor. The file is opened as if the open() function as defined in the System Interfaces volume of POSIX.1-2008 was called with the O_APPEND flag. If the file does not exist, it shall be created.

The general format for appending redirected output is as follows:

[n]>>word
where the optional n represents the file descriptor number. If the number is omitted, the redirection refers to standard output (file descriptor 1).

2.7.4 Here-Document
The redirection operators "<<" and "<<-" both allow redirection of subsequent lines read by the shell to the input of a command. The redirected lines are known as a "here-document".

The here-document shall be treated as a single word that begins after the next <newline> and continues until there is a line containing only the delimiter and a <newline>, with no <blank> characters in between. Then the next here-document starts, if there is one. The format is as follows:

[n]<<word
    here-document
delimiter
where the optional n represents the file descriptor number. If the number is omitted, the here-document refers to standard input (file descriptor 0). It is unspecified whether the file descriptor is opened as a regular file, a special file, or a pipe. Portable applications cannot rely on the file descriptor being seekable (see XSH lseek).

If any part of word is quoted, the delimiter shall be formed by performing quote removal on word, and the here-document lines shall not be expanded. Otherwise, the delimiter shall be the word itself.

If no part of word is quoted, all lines of the here-document shall be expanded for parameter expansion, command substitution, and arithmetic expansion. In this case, the <backslash> in the input behaves as the <backslash> inside double-quotes (see Double-Quotes). However, the double-quote character ( ' )' shall not be treated specially within a here-document, except when the double-quote appears within "$()", "``", or "${}".

If the redirection operator is "<<-", all leading <tab> characters shall be stripped from input lines and the line containing the trailing delimiter. If more than one "<<" or "<<-" operator is specified on a line, the here-document associated with the first operator shall be supplied first by the application and shall be read first by the shell.

When a here-document is read from a terminal device and the shell is interactive, it shall write the contents of the variable PS2, processed as described in Shell Variables, to standard error before reading each line of input until the delimiter has been recognized.

The following sections are informative.
Examples
An example of a here-document follows:

cat <<eof1; cat <<eof2
Hi,
eof1
Helene.
eof2

End of informative text.
2.7.5 Duplicating an Input File Descriptor
The redirection operator:

[n]<&word
shall duplicate one input file descriptor from another, or shall close one. If word evaluates to one or more digits, the file descriptor denoted by n, or standard input if n is not specified, shall be made to be a copy of the file descriptor denoted by word; if the digits in word do not represent a file descriptor already open for input, a redirection error shall result; see Consequences of Shell Errors. If word evaluates to '-', file descriptor n, or standard input if n is not specified, shall be closed. Attempts to close a file descriptor that is not open shall not constitute an error. If word evaluates to something else, the behavior is unspecified.

2.7.6 Duplicating an Output File Descriptor
The redirection operator:

[n]>&word
shall duplicate one output file descriptor from another, or shall close one. If word evaluates to one or more digits, the file descriptor denoted by n, or standard output if n is not specified, shall be made to be a copy of the file descriptor denoted by word; if the digits in word do not represent a file descriptor already open for output, a redirection error shall result; see Consequences of Shell Errors. If word evaluates to '-', file descriptor n, or standard output if n is not specified, is closed. Attempts to close a file descriptor that is not open shall not constitute an error. If word evaluates to something else, the behavior is unspecified.

2.7.7 Open File Descriptors for Reading and Writing
The redirection operator:

[n]<>word
shall cause the file whose name is the expansion of word to be opened for both reading and writing on the file descriptor denoted by n, or standard input if n is not specified. If the file does not exist, it shall be created.

2.8 Exit Status and Errors
2.8.1 Consequences of Shell Errors
Certain errors shall cause the shell to write a diagnostic message to standard error and exit as shown in the following table:

Error

Non-Interactive
Shell

Interactive Shell

Shell Diagnostic
Message Required

Shell language syntax error

shall exit

shall not exit

yes

Special built-in utility error

shall exit

shall not exit

no1

Other utility (not a special
built-in) error

shall not exit

shall not exit

no2

Redirection error with
special built-in utilities

shall exit

shall not exit

yes

Redirection error with
compound commands

may exit3

shall not exit

yes

Redirection error with
function execution

may exit3

shall not exit

yes

Redirection error with other
utilities (not special built-ins)

shall not exit

shall not exit

yes

Variable assignment error

shall exit

shall not exit

yes

Expansion error

shall exit

shall not exit

yes

Command not found

may exit

shall not exit

yes

Notes:
Although special built-ins are part of the shell, a diagnostic message written by a special built-in is not considered to be a shell diagnostic message, and can be redirected like any other utility.

The shell is not required to write a diagnostic message, but the utility itself shall write a diagnostic message if required to do so.

A future version of this standard may require the shell to not exit in this condition.

An expansion error is one that occurs when the shell expansions define in wordexp are carried out (for example, "${x!y}", because '!' is not a valid operator); an implementation may treat these as syntax errors if it is able to detect them during tokenization, rather than during expansion.

If any of the errors shown as "shall exit" or "may exit" occur in a subshell environment, the shell shall (respectively, may) exit from the subshell environment with a non-zero status and continue in the environment from which that subshell environment was invoked.

In all of the cases shown in the table where an interactive shell is required not to exit, the shell shall not perform any further processing of the command in which the error occurred.

2.8.2 Exit Status for Commands
Each command has an exit status that can influence the behavior of other shell commands. The exit status of commands that are not utilities is documented in this section. The exit status of the standard utilities is documented in their respective sections.

If a command is not found, the exit status shall be 127. If the command name is found, but it is not an executable utility, the exit status shall be 126. Applications that invoke utilities without using the shell should use these exit status values to report similar errors.

If a command fails during word expansion or redirection, its exit status shall be between 1 and 125 inclusive.

Internally, for purposes of deciding whether a command exits with a non-zero exit status, the shell shall recognize the entire status value retrieved for the command by the equivalent of the wait() function WEXITSTATUS macro (as defined in the System Interfaces volume of POSIX.1-2008). When reporting the exit status with the special parameter '?', the shell shall report the full eight bits of exit status available. The exit status of a command that terminated because it received a signal shall be reported as greater than 128.

2.9 Shell Commands
This section describes the basic structure of shell commands. The following command descriptions each describe a format of the command that is only used to aid the reader in recognizing the command type, and does not formally represent the syntax. In particular, the representations include spacing between tokens in some places where <blank>s would not be necessary (when one of the tokens is an operator). Each description discusses the semantics of the command; for a formal definition of the command language, consult Shell Grammar.

A command is one of the following:

Simple command (see Simple Commands)

Pipeline (see Pipelines)

List compound-list (see Lists)

Compound command (see Compound Commands)

Function definition (see Function Definition Command)

Unless otherwise stated, the exit status of a command shall be that of the last simple command executed by the command. There shall be no limit on the size of any shell command other than that imposed by the underlying system (memory constraints, {ARG_MAX}, and so on).

2.9.1 Simple Commands
A "simple command" is a sequence of optional variable assignments and redirections, in any sequence, optionally followed by words and redirections, terminated by a control operator.

When a given simple command is required to be executed (that is, when any conditional construct such as an AND-OR list or a case statement has not bypassed the simple command), the following expansions, assignments, and redirections shall all be performed from the beginning of the command text to the end:

The words that are recognized as variable assignments or redirections according to Shell Grammar Rules are saved for processing in steps 3 and 4.

The words that are not variable assignments or redirections shall be expanded. If any fields remain following their expansion, the first field shall be considered the command name and remaining fields are the arguments for the command.

Redirections shall be performed as described in Redirection.

Each variable assignment shall be expanded for tilde expansion, parameter expansion, command substitution, arithmetic expansion, and quote removal prior to assigning the value.

In the preceding list, the order of steps 3 and 4 may be reversed if no command name results from step 2 or if the command name matches the name of a special built-in utility; see Special Built-In Utilities.

Variable assignments shall be performed as follows:

If no command name results, variable assignments shall affect the current execution environment.

If the command name is not a special built-in utility or function, the variable assignments shall be exported for the execution environment of the command and shall not affect the current execution environment except as a side-effect of the expansions performed in step 4. In this case it is unspecified:

Whether or not the assignments are visible for subsequent expansions in step 4

Whether variable assignments made as side-effects of these expansions are visible for subsequent expansions in step 4, or in the current shell execution environment, or both

If the command name is a standard utility implemented as a function (see XBD Utility), the effect of variable assignments shall be as if the utility was not implemented as a function.

If the command name is a special built-in utility, variable assignments shall affect the current execution environment. Unless the set -a option is on (see set), it is unspecified:

Whether or not the variables gain the export attribute during the execution of the special built-in utility

Whether or not export attributes gained as a result of the variable assignments persist after the completion of the special built-in utility

If the command name is a function that is not a standard utility implemented as a function, variable assignments shall affect the current execution environment during the execution of the function. It is unspecified:

Whether or not the variable assignments persist after the completion of the function

Whether or not the variables gain the export attribute during the execution of the function

Whether or not export attributes gained as a result of the variable assignments persist after the completion of the function (if variable assignments persist after the completion of the function)

If any of the variable assignments attempt to assign a value to a variable for which the readonly attribute is set in the current shell environment (regardless of whether the assignment is made in that environment), a variable assignment error shall occur. See Consequences of Shell Errors for the consequences of these errors.

If there is no command name, any redirections shall be performed in a subshell environment; it is unspecified whether this subshell environment is the same one as that used for a command substitution within the command. (To affect the current execution environment, see the exec special built-in.) If any of the redirections performed in the current shell execution environment fail, the command shall immediately fail with an exit status greater than zero, and the shell shall write an error message indicating the failure. See Consequences of Shell Errors for the consequences of these failures on interactive and non-interactive shells.

If there is a command name, execution shall continue as described in Command Search and Execution . If there is no command name, but the command contained a command substitution, the command shall complete with the exit status of the last command substitution performed. Otherwise, the command shall complete with a zero exit status.

Command Search and Execution
If a simple command results in a command name and an optional list of arguments, the following actions shall be performed:

If the command name does not contain any <slash> characters, the first successful step in the following sequence shall occur:

If the command name matches the name of a special built-in utility, that special built-in utility shall be invoked.

If the command name matches the name of a utility listed in the following table, the results are unspecified.


alloc
autoload
bind
bindkey
builtin
bye
caller
cap
chdir
clone
 


comparguments
compcall
compctl
compdescribe
compfiles
compgen
compgroups
complete
compquote
comptags
 


comptry
compvalues
declare
dirs
disable
disown
dosh
echotc
echoti
help
 


history
hist
let
local
login
logout
map
mapfile
popd
print
 


pushd
readarray
repeat
savehistory
source
shopt
stop
suspend
typeset
whence
 

If the command name matches the name of a function known to this shell, the function shall be invoked as described in Function Definition Command. If the implementation has provided a standard utility in the form of a function, it shall not be recognized at this point. It shall be invoked in conjunction with the path search in step 1e.

If the command name matches the name [XSI] [Option Start]  of the type or ulimit utility, or [Option End]  of a utility listed in the following table, that utility shall be invoked.


alias
bg
cd
command
 


false
fc
fg
getopts
 


hash
jobs
kill
newgrp
 


pwd
read
true
umask
 


unalias
wait
 

Otherwise, the command shall be searched for using the PATH environment variable as described in XBD Environment Variables :

If the search is successful:

If the system has implemented the utility as a regular built-in or as a shell function, it shall be invoked at this point in the path search.

Otherwise, the shell executes the utility in a separate utility environment (see Shell Execution Environment) with actions equivalent to calling the execl() function as defined in the System Interfaces volume of POSIX.1-2008 with the path argument set to the pathname resulting from the search, arg0 set to the command name, and the remaining execl() arguments set to the command arguments (if any) and the null terminator.

If the execl() function fails due to an error equivalent to the [ENOEXEC] error defined in the System Interfaces volume of POSIX.1-2008, the shell shall execute a command equivalent to having a shell invoked with the pathname resulting from the search as its first operand, with any remaining arguments passed to the new shell, except that the value of "$0" in the new shell may be set to the command name. If the executable file is not a text file, the shell may bypass this command execution. In this case, it shall write an error message, and shall return an exit status of 126.

It is unspecified whether environment variables that were passed to the shell when it was invoked, but were not used to initialize shell variables (see Shell Variables) because they had invalid names, are included in the environment passed to execl() and (if execl() fails as described above) to the new shell.

Once a utility has been searched for and found (either as a result of this specific search or as part of an unspecified shell start-up activity), an implementation may remember its location and need not search for the utility again unless the PATH variable has been the subject of an assignment. If the remembered location fails for a subsequent invocation, the shell shall repeat the search to find the new location for the utility, if any.

If the search is unsuccessful, the command shall fail with an exit status of 127 and the shell shall write an error message.

If the command name contains at least one <slash>, the shell shall execute the utility in a separate utility environment with actions equivalent to calling the execl() function defined in the System Interfaces volume of POSIX.1-2008 with the path and arg0 arguments set to the command name, and the remaining execl() arguments set to the command arguments (if any) and the null terminator.

If the execl() function fails due to an error equivalent to the [ENOEXEC] error, the shell shall execute a command equivalent to having a shell invoked with the command name as its first operand, with any remaining arguments passed to the new shell. If the executable file is not a text file, the shell may bypass this command execution. In this case, it shall write an error message and shall return an exit status of 126.

It is unspecified whether environment variables that were passed to the shell when it was invoked, but were not used to initialize shell variables (see Shell Variables) because they had invalid names, are included in the environment passed to execl() and (if execl() fails as described above) to the new shell.

If the utility would be executed with file descriptor 0, 1, or 2 closed, implementations may execute the utility with the file descriptor open to an unspecified file. If a standard utility or a conforming application is executed with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for writing, the environment in which the utility or application is executed shall be deemed non-conforming, and consequently the utility or application might not behave as described in this standard.

2.9.2 Pipelines
A pipeline is a sequence of one or more commands separated by the control operator '|'. For each command but the last, the shell shall connect the standard output of the command to the standard input of the next command as if by creating a pipe and passing the write end of the pipe as the standard output of the command and the read end of the pipe as the standard input of the next command.

The format for a pipeline is:

[!] command1 [ | command2 ...]
If the pipeline begins with the reserved word ! and command1 is a subshell command, the application shall ensure that the ( operator at the beginning of command1 is separated from the ! by one or more <blank> characters. The behavior of the reserved word ! immediately followed by the ( operator is unspecified.

The standard output of command1 shall be connected to the standard input of command2. The standard input, standard output, or both of a command shall be considered to be assigned by the pipeline before any redirection specified by redirection operators that are part of the command (see Redirection).

If the pipeline is not in the background (see Asynchronous Lists), the shell shall wait for the last command specified in the pipeline to complete, and may also wait for all commands to complete.

Exit Status
If the pipeline does not begin with the ! reserved word, the exit status shall be the exit status of the last command specified in the pipeline. Otherwise, the exit status shall be the logical NOT of the exit status of the last command. That is, if the last command returns zero, the exit status shall be 1; if the last command returns greater than zero, the exit status shall be zero.

2.9.3 Lists
An AND-OR list is a sequence of one or more pipelines separated by the operators "&&" and "||" .

A list is a sequence of one or more AND-OR lists separated by the operators ';' and '&'.

The operators "&&" and "||" shall have equal precedence and shall be evaluated with left associativity. For example, both of the following commands write solely bar to standard output:

false && echo foo || echo bar
true || echo foo && echo bar

A ';' separator or a ';' or <newline> terminator shall cause the preceding AND-OR list to be executed sequentially; an '&' separator or terminator shall cause asynchronous execution of the preceding AND-OR list.

The term "compound-list" is derived from the grammar in Shell Grammar; it is equivalent to a sequence of lists, separated by <newline> characters, that can be preceded or followed by an arbitrary number of <newline> characters.

The following sections are informative.
Examples
The following is an example that illustrates <newline> characters in compound-lists:

while
    # a couple of <newline>s


    # a list
    date && who || ls; cat file
    # a couple of <newline>s


    # another list
    wc file > output & true


do
    # 2 lists
    ls
    cat file
done

End of informative text.
Asynchronous Lists
If a command is terminated by the control operator <ampersand> ( '&' ), the shell shall execute the command asynchronously in a subshell. This means that the shell shall not wait for the command to finish before executing the next command.

The format for running a command in the background is:

command1 & [command2 & ... ]
If job control is disabled (see set, -m), the standard input for an asynchronous list, before any explicit redirections are performed, shall be considered to be assigned to a file that has the same properties as /dev/null. This shall not happen if job control is enabled. In all cases, explicit redirection of standard input shall override this activity.

When an element of an asynchronous list (the portion of the list ended by an <ampersand>, such as command1, above) is started by the shell, the process ID of the last command in the asynchronous list element shall become known in the current shell execution environment; see Shell Execution Environment. This process ID shall remain known until:

The command terminates and the application waits for the process ID.

Another asynchronous list is invoked before "$!" (corresponding to the previous asynchronous list) is expanded in the current execution environment.

The implementation need not retain more than the {CHILD_MAX} most recent entries in its list of known process IDs in the current shell execution environment.

Exit Status
The exit status of an asynchronous list shall be zero.

Sequential Lists
Commands that are separated by a <semicolon> ( ';' ) shall be executed sequentially.

The format for executing commands sequentially shall be:

command1 [; command2] ...

Each command shall be expanded and executed in the order specified.

Exit Status
The exit status of a sequential list shall be the exit status of the last command in the list.

AND Lists
The control operator "&&" denotes an AND list. The format shall be:

command1 [ && command2] ...

First command1 shall be executed. If its exit status is zero, command2 shall be executed, and so on, until a command has a non-zero exit status or there are no more commands left to execute. The commands are expanded only if they are executed.

Exit Status
The exit status of an AND list shall be the exit status of the last command that is executed in the list.

OR Lists
The control operator "||" denotes an OR List. The format shall be:

command1 [ || command2] ...

First, command1 shall be executed. If its exit status is non-zero, command2 shall be executed, and so on, until a command has a zero exit status or there are no more commands left to execute.

Exit Status
The exit status of an OR list shall be the exit status of the last command that is executed in the list.

2.9.4 Compound Commands
The shell has several programming constructs that are "compound commands", which provide control flow for commands. Each of these compound commands has a reserved word or control operator at the beginning, and a corresponding terminator reserved word or operator at the end. In addition, each can be followed by redirections on the same line as the terminator. Each redirection shall apply to all the commands within the compound command that do not explicitly override that redirection.

Grouping Commands
The format for grouping commands is as follows:

( compound-list )
Execute compound-list in a subshell environment; see Shell Execution Environment. Variable assignments and built-in commands that affect the environment shall not remain in effect after the list finishes.
If a character sequence beginning with "((" would be parsed by the shell as an arithmetic expansion if preceded by a '$', shells which implement an extension whereby "((expression))" is evaluated as an arithmetic expression may treat the "((" as introducing as an arithmetic evaluation instead of a grouping command. A conforming application shall ensure that it separates the two leading '(' characters with white space to prevent the shell from performing an arithmetic evaluation.

{ compound-list ; }
Execute compound-list in the current process environment. The semicolon shown here is an example of a control operator delimiting the } reserved word. Other delimiters are possible, as shown in Shell Grammar; a <newline> is frequently used.
Exit Status
The exit status of a grouping command shall be the exit status of compound-list.

The for Loop
The for loop shall execute a sequence of commands for each member in a list of items. The for loop requires that the reserved words do and done be used to delimit the sequence of commands.

The format for the for loop is as follows:

for name [ in [word ... ]]
do
    compound-list
done

First, the list of words following in shall be expanded to generate a list of items. Then, the variable name shall be set to each item, in turn, and the compound-list executed each time. If no items result from the expansion, the compound-list shall not be executed. Omitting:

in word...
shall be equivalent to:

in "$@"

Exit Status
The exit status of a for command shall be the exit status of the last command that executes. If there are no items, the exit status shall be zero.

Case Conditional Construct
The conditional construct case shall execute the compound-list corresponding to the first one of several patterns (see Pattern Matching Notation) that is matched by the string resulting from the tilde expansion, parameter expansion, command substitution, arithmetic expansion, and quote removal of the given word. The reserved word in shall denote the beginning of the patterns to be matched. Multiple patterns with the same compound-list shall be delimited by the '|' symbol. The control operator ')' terminates a list of patterns corresponding to a given action. The compound-list for each list of patterns, with the possible exception of the last, shall be terminated with ";;". The case construct terminates with the reserved word esac (case reversed).
The format for the case construct is as follows:

case word in
    [(] pattern1 ) compound-list ;;
    [[(] pattern[ | pattern] ... ) compound-list ;;] ...
    [[(] pattern[ | pattern] ... ) compound-list]
esac

The ";;" is optional for the last compound-list.

In order from the beginning to the end of the case statement, each pattern that labels a compound-list shall be subjected to tilde expansion, parameter expansion, command substitution, and arithmetic expansion, and the result of these expansions shall be compared against the expansion of word, according to the rules described in Pattern Matching Notation (which also describes the effect of quoting parts of the pattern). After the first match, no more patterns shall be expanded, and the compound-list shall be executed. The order of expansion and comparison of multiple patterns that label a compound-list statement is unspecified.

Exit Status
The exit status of case shall be zero if no patterns are matched. Otherwise, the exit status shall be the exit status of the last command executed in the compound-list.

The if Conditional Construct
The if command shall execute a compound-list and use its exit status to determine whether to execute another compound-list.

The format for the if construct is as follows:

if compound-list
then
    compound-list
[elif compound-list
then
    compound-list] ...
[else
    compound-list]
fi

The if compound-list shall be executed; if its exit status is zero, the then compound-list shall be executed and the command shall complete. Otherwise, each elif compound-list shall be executed, in turn, and if its exit status is zero, the then compound-list shall be executed and the command shall complete. Otherwise, the else compound-list shall be executed.

Exit Status
The exit status of the if command shall be the exit status of the then or else compound-list that was executed, or zero, if none was executed.

The while Loop
The while loop shall continuously execute one compound-list as long as another compound-list has a zero exit status.

The format of the while loop is as follows:

while compound-list-1
do
    compound-list-2
done

The compound-list-1 shall be executed, and if it has a non-zero exit status, the while command shall complete. Otherwise, the compound-list-2 shall be executed, and the process shall repeat.

Exit Status
The exit status of the while loop shall be the exit status of the last compound-list-2 executed, or zero if none was executed.

The until Loop
The until loop shall continuously execute one compound-list as long as another compound-list has a non-zero exit status.

The format of the until loop is as follows:

until compound-list-1
do
    compound-list-2
done

The compound-list-1 shall be executed, and if it has a zero exit status, the until command completes. Otherwise, the compound-list-2 shall be executed, and the process repeats.

Exit Status
The exit status of the until loop shall be the exit status of the last compound-list-2 executed, or zero if none was executed.

2.9.5 Function Definition Command
A function is a user-defined name that is used as a simple command to call a compound command with new positional parameters. A function is defined with a "function definition command".

The format of a function definition command is as follows:

fname ( ) compound-command [io-redirect ...]
The function is named fname; the application shall ensure that it is a name (see XBD Name) and that it is not the name of a special built-in utility. An implementation may allow other characters in a function name as an extension. The implementation shall maintain separate name spaces for functions and variables.

The argument compound-command represents a compound command, as described in Compound Commands.

When the function is declared, none of the expansions in wordexp shall be performed on the text in compound-command or io-redirect; all expansions shall be performed as normal each time the function is called. Similarly, the optional io-redirect redirections and any variable assignments within compound-command shall be performed during the execution of the function itself, not the function definition. See Consequences of Shell Errors for the consequences of failures of these operations on interactive and non-interactive shells.

When a function is executed, it shall have the syntax-error properties described for special built-in utilities in the first item in the enumerated list at the beginning of Special Built-In Utilities.

The compound-command shall be executed whenever the function name is specified as the name of a simple command (see Command Search and Execution). The operands to the command temporarily shall become the positional parameters during the execution of the compound-command; the special parameter '#' also shall be changed to reflect the number of operands. The special parameter 0 shall be unchanged. When the function completes, the values of the positional parameters and the special parameter '#' shall be restored to the values they had before the function was executed. If the special built-in return (see return) is executed in the compound-command, the function completes and execution shall resume with the next command after the function call.

Exit Status
The exit status of a function definition shall be zero if the function was declared successfully; otherwise, it shall be greater than zero. The exit status of a function invocation shall be the exit status of the last command executed by the function.

2.10. Shell Grammar
The following grammar defines the Shell Command Language. This formal syntax shall take precedence over the preceding text syntax description.

2.10.1 Shell Grammar Lexical Conventions
The input language to the shell must be first recognized at the character level. The resulting tokens shall be classified by their immediate context according to the following rules (applied in order). These rules shall be used to determine what a "token" is that is subject to parsing at the token level. The rules for token recognition in Token Recognition shall apply.

If the token is an operator, the token identifier for that operator shall result.

If the string consists solely of digits and the delimiter character is one of '<' or '>', the token identifier IO_NUMBER shall be returned.

Otherwise, the token identifier TOKEN results.

Further distinction on TOKEN is context-dependent. It may be that the same TOKEN yields WORD, a NAME, an ASSIGNMENT_WORD, or one of the reserved words below, dependent upon the context. Some of the productions in the grammar below are annotated with a rule number from the following list. When a TOKEN is seen where one of those annotated productions could be used to reduce the symbol, the applicable rule shall be applied to convert the token identifier type of the TOKEN to a token identifier acceptable at that point in the grammar. The reduction shall then proceed based upon the token identifier type yielded by the rule applied. When more than one rule applies, the highest numbered rule shall apply (which in turn may refer to another rule). (Note that except in rule 7, the presence of an '=' in the token has no effect.)

The WORD tokens shall have the word expansion rules applied to them immediately before the associated command is executed, not at the time the command is parsed.

2.10.2 Shell Grammar Rules
[Command Name]

When the TOKEN is exactly a reserved word, the token identifier for that reserved word shall result. Otherwise, the token WORD shall be returned. Also, if the parser is in any state where only a reserved word could be the next correct token, proceed as above.

Note:
Because at this point <quotation-mark> characters are retained in the token, quoted strings cannot be recognized as reserved words. This rule also implies that reserved words are not recognized except in certain positions in the input, such as after a <newline> or <semicolon>; the grammar presumes that if the reserved word is intended, it is properly delimited by the user, and does not attempt to reflect that requirement directly. Also note that line joining is done before tokenization, as described in Escape Character (Backslash), so escaped <newline> characters are already removed at this point.
Rule 1 is not directly referenced in the grammar, but is referred to by other rules, or applies globally.

[Redirection to or from filename]

The expansions specified in Redirection shall occur. As specified there, exactly one field can result (or the result is unspecified), and there are additional requirements on pathname expansion.

[Redirection from here-document]

Quote removal shall be applied to the word to determine the delimiter that is used to find the end of the here-document that begins after the next <newline>.

[Case statement termination]

When the TOKEN is exactly the reserved word esac, the token identifier for esac shall result. Otherwise, the token WORD shall be returned.

[ NAME in for]

When the TOKEN meets the requirements for a name (see XBD Name ), the token identifier NAME shall result. Otherwise, the token WORD shall be returned.

[Third word of for and case]

[ case only]

When the TOKEN is exactly the reserved word in, the token identifier for in shall result. Otherwise, the token WORD shall be returned.

[ for only]

When the TOKEN is exactly the reserved word in or do, the token identifier for in or do shall result, respectively. Otherwise, the token WORD shall be returned.

(For a. and b.: As indicated in the grammar, a linebreak precedes the tokens in and do. If <newline> characters are present at the indicated location, it is the token after them that is treated in this fashion.)

[Assignment preceding command name]

[When the first word]

If the TOKEN does not contain the character '=', rule 1 is applied. Otherwise, 7b shall be applied.

[Not the first word]

If the TOKEN contains an unquoted (as determined while applying rule 4 from Token Recognition) <equals-sign> character that is not part of an embedded parameter expansion, command substitution, or arithmetic expansion construct (as determined while applying rule 5 from Token Recognition):

If the TOKEN begins with '=', then rule 1 shall be applied.

If all the characters in the TOKEN preceding the first such <equals-sign> form a valid name (see XBD Name), the token ASSIGNMENT_WORD shall be returned.

Otherwise, it is unspecified whether rule 1 is applied or ASSIGNMENT_WORD is returned.

Otherwise, rule 1 shall be applied.

Assignment to the name within a returned ASSIGNMENT_WORD token shall occur as specified in Simple Commands.

[ NAME in function]

When the TOKEN is exactly a reserved word, the token identifier for that reserved word shall result. Otherwise, when the TOKEN meets the requirements for a name, the token identifier NAME shall result. Otherwise, rule 7 applies.

[Body of function]

Word expansion and assignment shall never occur, even when required by the rules above, when this rule is being parsed. Each TOKEN that might either be expanded or have assignment applied to it shall instead be returned as a single WORD consisting only of characters that are exactly the token described in Token Recognition.


/* -------------------------------------------------------
   The grammar symbols
   ------------------------------------------------------- */
%token  WORD
%token  ASSIGNMENT_WORD
%token  NAME
%token  NEWLINE
%token  IO_NUMBER


/* The following are the operators (see XBD Operator)
   containing more than one character. */



%token  AND_IF    OR_IF    DSEMI
/*      '&&'      '||'     ';;'    */


%token  DLESS  DGREAT  LESSAND  GREATAND  LESSGREAT  DLESSDASH
/*      '<<'   '>>'    '<&'     '>&'      '<>'       '<<-'   */


%token  CLOBBER
/*      '>|'   */


/* The following are the reserved words. */


%token  If    Then    Else    Elif    Fi    Do    Done
/*      'if'  'then'  'else'  'elif'  'fi'  'do'  'done'   */


%token  Case    Esac    While    Until    For
/*      'case'  'esac'  'while'  'until'  'for'   */


/* These are reserved words, not operator tokens, and are
   recognized when reserved words are recognized. */


%token  Lbrace    Rbrace    Bang
/*      '{'       '}'       '!'   */


%token  In
/*      'in'   */


/* -------------------------------------------------------
   The Grammar
   ------------------------------------------------------- */
%start program
%%
program          : linebreak complete_commands linebreak
                 | linebreak
                 ;
complete_commands: complete_commands newline_list complete_command
                 |                                complete_command
                 ;
complete_command : list separator_op
                 | list
                 ;
list             : list separator_op and_or
                 |                   and_or
                 ;
and_or           :                         pipeline
                 | and_or AND_IF linebreak pipeline
                 | and_or OR_IF  linebreak pipeline
                 ;
pipeline         :      pipe_sequence
                 | Bang pipe_sequence
                 ;
pipe_sequence    :                             command
                 | pipe_sequence '|' linebreak command
                 ;
command          : simple_command
                 | compound_command
                 | compound_command redirect_list
                 | function_definition
                 ;
compound_command : brace_group
                 | subshell
                 | for_clause
                 | case_clause
                 | if_clause
                 | while_clause
                 | until_clause
                 ;
subshell         : '(' compound_list ')'
                 ;
compound_list    : linebreak term
                 | linebreak term separator
                 ;
term             : term separator and_or
                 |                and_or
                 ;
for_clause       : For name                                      do_group
                 | For name                       sequential_sep do_group
                 | For name linebreak in          sequential_sep do_group
                 | For name linebreak in wordlist sequential_sep do_group
                 ;
name             : NAME                     /* Apply rule 5 */
                 ;
in               : In                       /* Apply rule 6 */
                 ;
wordlist         : wordlist WORD
                 |          WORD
                 ;
case_clause      : Case WORD linebreak in linebreak case_list    Esac
                 | Case WORD linebreak in linebreak case_list_ns Esac
                 | Case WORD linebreak in linebreak              Esac
                 ;
case_list_ns     : case_list case_item_ns
                 |           case_item_ns
                 ;
case_list        : case_list case_item
                 |           case_item
                 ;
case_item_ns     :     pattern ')' linebreak
                 |     pattern ')' compound_list
                 | '(' pattern ')' linebreak
                 | '(' pattern ')' compound_list
                 ;
case_item        :     pattern ')' linebreak     DSEMI linebreak
                 |     pattern ')' compound_list DSEMI linebreak
                 | '(' pattern ')' linebreak     DSEMI linebreak
                 | '(' pattern ')' compound_list DSEMI linebreak
                 ;
pattern          :             WORD         /* Apply rule 4 */
                 | pattern '|' WORD         /* Do not apply rule 4 */
                 ;
if_clause        : If compound_list Then compound_list else_part Fi
                 | If compound_list Then compound_list           Fi
                 ;
else_part        : Elif compound_list Then compound_list
                 | Elif compound_list Then compound_list else_part
                 | Else compound_list
                 ;
while_clause     : While compound_list do_group
                 ;
until_clause     : Until compound_list do_group
                 ;
function_definition : fname '(' ')' linebreak function_body
                 ;
function_body    : compound_command                /* Apply rule 9 */
                 | compound_command redirect_list  /* Apply rule 9 */
                 ;
fname            : NAME                            /* Apply rule 8 */
                 ;
brace_group      : Lbrace compound_list Rbrace
                 ;
do_group         : Do compound_list Done           /* Apply rule 6 */
                 ;
simple_command   : cmd_prefix cmd_word cmd_suffix
                 | cmd_prefix cmd_word
                 | cmd_prefix
                 | cmd_name cmd_suffix
                 | cmd_name
                 ;
cmd_name         : WORD                   /* Apply rule 7a */
                 ;
cmd_word         : WORD                   /* Apply rule 7b */
                 ;
cmd_prefix       :            io_redirect
                 | cmd_prefix io_redirect
                 |            ASSIGNMENT_WORD
                 | cmd_prefix ASSIGNMENT_WORD
                 ;
cmd_suffix       :            io_redirect
                 | cmd_suffix io_redirect
                 |            WORD
                 | cmd_suffix WORD
                 ;
redirect_list    :               io_redirect
                 | redirect_list io_redirect
                 ;
io_redirect      :           io_file
                 | IO_NUMBER io_file
                 |           io_here
                 | IO_NUMBER io_here
                 ;
io_file          : '<'       filename
                 | LESSAND   filename
                 | '>'       filename
                 | GREATAND  filename
                 | DGREAT    filename
                 | LESSGREAT filename
                 | CLOBBER   filename
                 ;
filename         : WORD                      /* Apply rule 2 */
                 ;
io_here          : DLESS     here_end
                 | DLESSDASH here_end
                 ;
here_end         : WORD                      /* Apply rule 3 */
                 ;
newline_list     :              NEWLINE
                 | newline_list NEWLINE
                 ;
linebreak        : newline_list
                 | /* empty */
                 ;
separator_op     : '&'
                 | ';'
                 ;
separator        : separator_op linebreak
                 | newline_list
                 ;
sequential_sep   : ';' linebreak
                 | newline_list
                 ;

2.11. Signals and Error Handling
If job control is disabled (see the description of set -m) when the shell executes an asynchronous list, the commands in the list shall inherit from the shell a signal action of ignored (SIG_IGN) for the SIGINT and SIGQUIT signals. In all other cases, commands executed by the shell shall inherit the same signal actions as those inherited by the shell from its parent unless a signal action is modified by the trap special built-in (see trap)

When a signal for which a trap has been set is received while the shell is waiting for the completion of a utility executing a foreground command, the trap associated with that signal shall not be executed until after the foreground command has completed. When the shell is waiting, by means of the wait utility, for asynchronous commands to complete, the reception of a signal for which a trap has been set shall cause the wait utility to return immediately with an exit status >128, immediately after which the trap associated with that signal shall be taken.

If multiple signals are pending for the shell for which there are associated trap actions, the order of execution of trap actions is unspecified.

2.12. Shell Execution Environment
A shell execution environment consists of the following:

Open files inherited upon invocation of the shell, plus open files controlled by exec

Working directory as set by cd

File creation mask set by umask

[XSI] [Option Start] File size limit as set by ulimit [Option End]

Current traps set by trap

Shell parameters that are set by variable assignment (see the set special built-in) or from the System Interfaces volume of POSIX.1-2008 environment inherited by the shell when it begins (see the export special built-in)

Shell functions; see Function Definition Command

Options turned on at invocation or by set

Process IDs of the last commands in asynchronous lists known to this shell environment; see Asynchronous Lists

Shell aliases; see Alias Substitution

Utilities other than the special built-ins (see Special Built-In Utilities) shall be invoked in a separate environment that consists of the following. The initial value of these objects shall be the same as that for the parent shell, except as noted below.

Open files inherited on invocation of the shell, open files controlled by the exec special built-in plus any modifications, and additions specified by any redirections to the utility

Current working directory

File creation mask

If the utility is a shell script, traps caught by the shell shall be set to the default values and traps ignored by the shell shall be set to be ignored by the utility; if the utility is not a shell script, the trap actions (default or ignore) shall be mapped into the appropriate signal handling actions for the utility

Variables with the export attribute, along with those explicitly exported for the duration of the command, shall be passed to the utility environment variables

The environment of the shell process shall not be changed by the utility unless explicitly specified by the utility description (for example, cd and umask).

A subshell environment shall be created as a duplicate of the shell environment, except that signal traps that are not being ignored shall be set to the default action. Changes made to the subshell environment shall not affect the shell environment. Command substitution, commands that are grouped with parentheses, and asynchronous lists shall be executed in a subshell environment. Additionally, each command of a multi-command pipeline is in a subshell environment; as an extension, however, any or all commands in a pipeline may be executed in the current environment. All other commands shall be executed in the current shell environment.

2.13. Pattern Matching Notation
The pattern matching notation described in this section is used to specify patterns for matching strings in the shell. Historically, pattern matching notation is related to, but slightly different from, the regular expression notation described in XBD Regular Expressions. For this reason, the description of the rules for this pattern matching notation are based on the description of regular expression notation, modified to account for the differences.

2.13.1 Patterns Matching a Single Character
The following patterns matching a single character shall match a single character: ordinary characters, special pattern characters, and pattern bracket expressions. The pattern bracket expression also shall match a single collating element. A <backslash> character shall escape the following character. The escaping <backslash> shall be discarded. If a pattern ends with an unescaped <backslash>, it is unspecified whether the pattern does not match anything or the pattern is treated as invalid.

An ordinary character is a pattern that shall match itself. It can be any character in the supported character set except for NUL, those special shell characters in Quoting that require quoting, and the following three special pattern characters. Matching shall be based on the bit pattern used for encoding the character, not on the graphic representation of the character. If any character (ordinary, shell special, or pattern special) is quoted, that pattern shall match the character itself. The shell special characters always require quoting.

When unquoted and outside a bracket expression, the following three characters shall have special meaning in the specification of patterns:

?
A <question-mark> is a pattern that shall match any character.
*
An <asterisk> is a pattern that shall match multiple characters, as described in Patterns Matching Multiple Characters.
[
If an open bracket introduces a bracket expression as in XBD RE Bracket Expression, except that the <exclamation-mark> character ( '!' ) shall replace the <circumflex> character ( '^' ) in its role in a non-matching list in the regular expression notation, it shall introduce a pattern bracket expression. A bracket expression starting with an unquoted <circumflex> character produces unspecified results. Otherwise, '[' shall match the character itself.
When pattern matching is used where shell quote removal is not performed (such as in the argument to the find - name primary when find is being called using one of the exec functions as defined in the System Interfaces volume of POSIX.1-2008, or in the pattern argument to the fnmatch() function), special characters can be escaped to remove their special meaning by preceding them with a <backslash> character. This escaping <backslash> is discarded. The sequence "\\" represents one literal <backslash>. All of the requirements and effects of quoting on ordinary, shell special, and special pattern characters shall apply to escaping in this context.

2.13.2 Patterns Matching Multiple Characters
The following rules are used to construct patterns matching multiple characters from patterns matching a single character:

The <asterisk> ( '*' ) is a pattern that shall match any string, including the null string.

The concatenation of patterns matching a single character is a valid pattern that shall match the concatenation of the single characters or collating elements matched by each of the concatenated patterns.

The concatenation of one or more patterns matching a single character with one or more <asterisk> characters is a valid pattern. In such patterns, each <asterisk> shall match a string of zero or more characters, matching the greatest possible number of characters that still allows the remainder of the pattern to match the string.

2.13.3 Patterns Used for Filename Expansion
The rules described so far in Patterns Matching a Single Character and Patterns Matching Multiple Characters are qualified by the following rules that apply when pattern matching notation is used for filename expansion:

The <slash> character in a pathname shall be explicitly matched by using one or more <slash> characters in the pattern; it shall neither be matched by the <asterisk> or <question-mark> special characters nor by a bracket expression. <slash> characters in the pattern shall be identified before bracket expressions; thus, a <slash> cannot be included in a pattern bracket expression used for filename expansion. If a <slash> character is found following an unescaped <left-square-bracket> character before a corresponding <right-square-bracket> is found, the open bracket shall be treated as an ordinary character. For example, the pattern "a[b/c]d" does not match such pathnames as abd or a/d. It only matches a pathname of literally a[b/c]d.

If a filename begins with a <period> ( '.' ), the <period> shall be explicitly matched by using a <period> as the first character of the pattern or immediately following a <slash> character. The leading <period> shall not be matched by:

The <asterisk> or <question-mark> special characters

A bracket expression containing a non-matching list, such as "[!a]", a range expression, such as "[%-0]", or a character class expression, such as "[[:punct:]]"

It is unspecified whether an explicit <period> in a bracket expression matching list, such as "[.abc]", can match a leading <period> in a filename.

Specified patterns shall be matched against existing filenames and pathnames, as appropriate. Each component that contains a pattern character shall require read permission in the directory containing that component. Any component, except the last, that does not contain a pattern character shall require search permission. For example, given the pattern:

/foo/bar/x*/bam

search permission is needed for directories / and foo, search and read permissions are needed for directory bar, and search permission is needed for each x* directory. If the pattern matches any existing filenames or pathnames, the pattern shall be replaced with those filenames and pathnames, sorted according to the collating sequence in effect in the current locale. If this collating sequence does not have a total ordering of all characters (see XBD LC_COLLATE), any filenames or pathnames that collate equally should be further compared byte-by-byte using the collating sequence for the POSIX locale.

Note:
A future version of this standard may require the byte-by-byte further comparison described above.
If the pattern contains an open bracket ( '[' ) that does not introduce a bracket expression as in XBD RE Bracket Expression, it is unspecified whether other unquoted pattern matching characters within the same slash-delimited component of the pattern retain their special meanings or are treated as ordinary characters. For example, the pattern "a*[/b*" may match all filenames beginning with 'b' in the directory "a*[" or it may match all filenames beginning with 'b' in all directories with names beginning with 'a' and ending with '['.

If the pattern does not match any existing filenames or pathnames, the pattern string shall be left unchanged.

2.14. Special Built-In Utilities
The following "special built-in" utilities shall be supported in the shell command language. The output of each command, if any, shall be written to standard output, subject to the normal redirection and piping possible with all commands.

The term "built-in" implies that the shell can execute the utility directly and does not need to search for it. An implementation may choose to make any utility a built-in; however, the special built-in utilities described here differ from regular built-in utilities in two respects:

An error in a special built-in utility may cause a shell executing that utility to abort, while an error in a regular built-in utility shall not cause a shell executing that utility to abort. (See Consequences of Shell Errors for the consequences of errors on interactive and non-interactive shells.) If a special built-in utility encountering an error does not abort the shell, its exit value shall be non-zero.

As described in Simple Commands, variable assignments preceding the invocation of a special built-in utility remain in effect after the built-in completes; this shall not be the case with a regular built-in or other utility.

The special built-in utilities in this section need not be provided in a manner accessible via the exec family of functions defined in the System Interfaces volume of POSIX.1-2008.

Some of the special built-ins are described as conforming to XBD Utility Syntax Guidelines. For those that are not, the requirement in Utility Description Defaults that "--" be recognized as a first argument to be discarded does not apply and a conforming application shall not use that argument.

<<< Previous	Home	Next >>>
 

return to top of page
UNIX  is a registered Trademark of The Open Group.
POSIX  is a registered Trademark of The IEEE.
Copyright  2001-2016 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT ]
NAME
break - exit from for, while, or until loop
SYNOPSIS
break [n]

DESCRIPTION
If n is specified, the break utility shall exit from the nth enclosing for, while, or until loop. If n is not specified, break shall behave as if n was specified as 1. Execution shall continue with the command immediately following the exited loop. The value of n is a positive decimal integer. If n is greater than the number of enclosing loops, the outermost enclosing loop shall be exited. If there is no enclosing loop, the behavior is unspecified.

A loop shall enclose a break or continue command if the loop lexically encloses the command. A loop lexically encloses a break or continue command if the command is:

Executing in the same execution environment (see Shell Execution Environment) as the compound-list of the loop's do-group (see Shell Grammar Rules), and

Contained in a compound-list associated with the loop (either in the compound-list of the loop's do-group or, if the loop is a while or until loop, in the compound-list following the while or until reserved word), and

Not in the body of a function whose function definition command (see Function Definition Command) is contained in a compound-list associated with the loop.

If n is greater than the number of lexically enclosing loops and there is a non-lexically enclosing loop in progress in the same execution environment as the break or continue command, it is unspecified whether that loop encloses the command.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
Successful completion.
>0
The n value was not an unsigned decimal integer greater than or equal to 1.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
for i in *
do
    if test -d "$i"
    then break
    fi
done

The results of running the following example are unspecified: there are two loops in progress when the break command is executed, and they are in the same execution environment, but neither loop is lexically enclosing the break command. (There are no loops lexically enclosing the continue commands, either.)

foo() {
    for j in 1 2; do
        echo 'break 2' >/tmp/do_break
        echo "  sourcing /tmp/do_break ($j)..."
        # the behavior of the break from running the following command
        # results in unspecified behavior:
        . /tmp/do_break


        do_continue() { continue 2; }
        echo "  running do_continue ($j)..."
        # the behavior of the continue in the following function call
        # results in unspecified behavior (if execution reaches this
        # point):
        do_continue


        trap 'continue 2' USR1
        echo "  sending SIGUSR1 to self ($j)..."
        # the behavior of the continue in the trap invoked from the
        # following signal results in unspecified behavior (if
        # execution reaches this point):
        kill -s USR1 $$
        sleep 1
    done
}
for i in 1 2; do
    echo "running foo ($i)..."
    foo
done

RATIONALE
In early proposals, consideration was given to expanding the syntax of break and continue to refer to a label associated with the appropriate loop as a preferable alternative to the n method. However, this volume of POSIX.1-2008 does reserve the name space of command names ending with a <colon>. It is anticipated that a future implementation could take advantage of this and provide something like:

outofloop: for i in a b c d e
do
    for j in 0 1 2 3 4 5 6 7 8 9
    do
        if test -r "${i}${j}"
        then break outofloop
        fi
    done
done

and that this might be standardized after implementation experience is achieved.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0046 [842] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
colon - null utility
SYNOPSIS
: [argument...]

DESCRIPTION
This utility shall only expand command arguments. It is used when a command is needed, as in the then condition of an if command, but nothing is to be done by the command.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
Zero.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
: ${X=abc}
if     false
then   :
else   echo $X
fi
abc

As with any of the special built-ins, the null utility can also have variable assignments and redirections associated with it, such as:

x=y : > z

which sets variable x to the value y (so that it persists after the null utility completes) and creates or truncates file z.

RATIONALE
None.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

End of informative text.
<<< Previous	Home	Next >>>
NAME
continue - continue for, while, or until loop
SYNOPSIS
continue [n]

DESCRIPTION
If n is specified, the continue utility shall return to the top of the nth enclosing for, while, or until loop. If n is not specified, continue shall behave as if n was specified as 1. Returning to the top of the loop involves repeating the condition list of a while or until loop or performing the next assignment of a for loop, and re-executing the loop if appropriate.

The value of n is a positive decimal integer. If n is greater than the number of enclosing loops, the outermost enclosing loop shall be used. If there is no enclosing loop, the behavior is unspecified.

The meaning of "enclosing" shall be as specified in the description of the break utility.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
Successful completion.
>0
The n value was not an unsigned decimal integer greater than or equal to 1.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
for i in *
do
    if test -d "$i"
    then continue
    fi
    printf '"%s" is not a directory.\n' "$i"
done

RATIONALE
None.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
The example is changed to use the printf utility rather than echo.

POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0046 [842] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
dot - execute commands in the current environment
SYNOPSIS
. file

DESCRIPTION
The shell shall execute commands from the file in the current environment.

If file does not contain a <slash>, the shell shall use the search path specified by PATH to find the directory containing file. Unlike normal command search, however, the file searched for by the dot utility need not be executable. If no readable file is found, a non-interactive shell shall abort; an interactive shell shall write a diagnostic message to standard error, but this condition shall not be considered a syntax error.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
See the DESCRIPTION.

ENVIRONMENT VARIABLES
See the DESCRIPTION.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
If no readable file was found or if the commands in the file could not be parsed, and the shell is interactive (and therefore does not abort; see Consequences of Shell Errors), the exit status shall be non-zero. Otherwise, return the value of the last command executed, or a zero exit status if no command is executed.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
cat foobar
foo=hello bar=world
. ./foobar
echo $foo $bar
hello world

RATIONALE
Some older implementations searched the current directory for the file, even if the value of PATH disallowed it. This behavior was omitted from this volume of POSIX.1-2008 due to concerns about introducing the susceptibility to trojan horses that the user might be trying to avoid by leaving dot out of PATH.

The KornShell version of dot takes optional arguments that are set to the positional parameters. This is a valid extension that allows a dot script to behave identically to a function.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities, return

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-164 is applied.

POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0038 [114] and XCU/TC1-2008/0039 [214] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
eval - construct command by concatenating arguments
SYNOPSIS
eval [argument...]

DESCRIPTION
The eval utility shall construct a command by concatenating arguments together, separating each with a <space> character. The constructed command shall be read and executed by the shell.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
If there are no arguments, or only null arguments, eval shall return a zero exit status; otherwise, it shall return the exit status of the command defined by the string of concatenated arguments separated by <space> characters, or a non-zero exit status if the concatenation could not be parsed as a command and the shell is interactive (and therefore did not abort).

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
Since eval is not required to recognize the "--" end of options delimiter, in cases where the argument(s) to eval might begin with '-' it is recommended that the first argument is prefixed by a string that will not alter the commands to be executed, such as a <space> character:

eval " $commands"

or:

eval " $(some_command)"

EXAMPLES
foo=10 x=foo
y='$'$x
echo $y
$foo
eval y='$'$x
echo $y
10

RATIONALE
This standard allows, but does not require, eval to recognize "--". Although this means applications cannot use "--" to protect against options supported as an extension (or errors reported for unsupported options), the nature of the eval utility is such that other means can be used to provide this protection (see APPLICATION USAGE above).

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0040 [114], XCU/TC1-2008/0041 [163], and XCU/TC1-2008/0042 [163] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
exec - execute commands and open, close, or copy file descriptors
SYNOPSIS
exec [command [argument...]]

DESCRIPTION
The exec utility shall open, close, and/or copy file descriptors as specified by any redirections as part of the command.

If exec is specified without command or arguments, and any file descriptors with numbers greater than 2 are opened with associated redirection statements, it is unspecified whether those file descriptors remain open when the shell invokes another utility. Scripts concerned that child shells could misuse open file descriptors can always close them explicitly, as shown in one of the following examples.

If exec is specified with command, it shall replace the shell with command without creating a new process. If arguments are specified, they shall be arguments to command. Redirection affects the current shell execution environment.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
If command is specified, exec shall not return to the shell; rather, the exit status of the process shall be the exit status of the program implementing command, which overlaid the shell. If command is not found, the exit status shall be 127. If command is found, but it is not an executable utility, the exit status shall be 126. If a redirection error occurs (see Consequences of Shell Errors), the shell shall exit with a value in the range 1-125. Otherwise, exec shall return a zero exit status.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
Open readfile as file descriptor 3 for reading:

exec 3< readfile

Open writefile as file descriptor 4 for writing:

exec 4> writefile

Make file descriptor 5 a copy of file descriptor 0:

exec 5<&0

Close file descriptor 3:

exec 3<&-

Cat the file maggie by replacing the current shell with the cat utility:

exec cat maggie

RATIONALE
Most historical implementations were not conformant in that:

foo=bar exec cmd

did not pass foo to cmd.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

End of informative text.
<<< Previous	Home	Next >>>
NAME
exit - cause the shell to exit
SYNOPSIS
exit [n]

DESCRIPTION
The exit utility shall cause the shell to exit from its current execution environment with the exit status specified by the unsigned decimal integer n. If the current execution environment is a subshell environment, the shell shall exit from the subshell environment with the specified exit status and continue in the environment from which that subshell environment was invoked; otherwise, the shell utility shall terminate with the specified exit status. If n is specified, but its value is not between 0 and 255 inclusively, the exit status is undefined.

A trap on EXIT shall be executed before the shell terminates, except when the exit utility is invoked in that trap itself, in which case the shell shall exit immediately.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
The exit status shall be n, if specified, except that the behavior is unspecified if n is not an unsigned decimal integer or is greater than 255. Otherwise, the value shall be the exit value of the last command executed, or zero if no command was executed. When exit is executed in a trap action, the last command is considered to be the command that executed immediately preceding the trap action.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
Exit with a true value:

exit 0

Exit with a false value:

exit 1

Propagate error handling from within a subshell:

(
    command1 || exit 1
    command2 || exit 1
    exec command3
) > outputfile || exit 1
echo "outputfile created successfully"

RATIONALE
As explained in other sections, certain exit status values have been reserved for special uses and should be used by applications only for those purposes:

 126
A file to be executed was found, but it was not an executable utility.
 127
A utility to be executed was not found.
>128
A command was interrupted by a signal.
The behavior of exit when given an invalid argument or unknown option is unspecified, because of differing practices in the various historical implementations. A value larger than 255 might be truncated by the shell, and be unavailable even to a parent process that uses waitid() to get the full exit value. It is recommended that implementations that detect any usage error should cause a non-zero exit status (or, if the shell is interactive and the error does not cause the shell to abort, store a non-zero value in "$?" ), but even this was not done historically in all shells.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0047 [717], XCU/TC2-2008/0048 [960], XCU/TC2-2008/0049 [717], and XCU/TC2-2008/0050 [960] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
export - set the export attribute for variables
SYNOPSIS
export name[=word]...
 
export -p

DESCRIPTION
The shell shall give the export attribute to the variables corresponding to the specified names, which shall cause them to be in the environment of subsequently executed commands. If the name of a variable is followed by = word, then the value of that variable shall be set to word.

The export special built-in shall support XBD Utility Syntax Guidelines.

When -p is specified, export shall write to the standard output the names and values of all exported variables, in the following format:

"export %s=%s\n", <name>, <value>

if name is set, and:

"export %s\n", <name>

if name is unset.

The shell shall format the output, including the proper use of quoting, so that it is suitable for reinput to the shell as commands that achieve the same exporting results, except:

Read-only variables with values cannot be reset.

Variables that were unset at the time they were output need not be reset to the unset state if a value is assigned to the variable between the time the state was saved and the time at which the saved output is reinput to the shell.

When no arguments are given, the results are unspecified.

OPTIONS
See the DESCRIPTION.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
See the DESCRIPTION.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
All name operands were successfully exported.
>0
At least one name could not be exported, or the -p option was specified and an error occurred.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
Note that, unless X was previously marked readonly, the value of "$?" after:

export X=$(false)

will be 0 (because export successfully set X to the empty string) and that execution continues, even if set -e is in effect. In order to detect command substitution failures, a user must separate the assignment from the export, as in:

X=$(false)
export X

EXAMPLES
Export PWD and HOME variables:

export PWD HOME

Set and export the PATH variable:

export PATH=/local/bin:$PATH

Save and restore all exported variables:

export -p > temp-file
unset a lot of variables
... processing
. temp-file

RATIONALE
Some historical shells use the no-argument case as the functional equivalent of what is required here with -p. This feature was left unspecified because it is not historical practice in all shells, and some scripts may rely on the now-unspecified results on their implementations. Attempts to specify the -p output as the default case were unsuccessful in achieving consensus. The -p option was added to allow portable access to the values that can be saved and then later restored using; for example, a dot script.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

XBD Utility Syntax Guidelines

CHANGE HISTORY
Issue 6
IEEE PASC Interpretation 1003.2 #203 is applied, clarifying the format when a variable is unset.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/6 is applied, adding the following text to the end of the first paragraph of the DESCRIPTION: "If the name of a variable is followed by = word, then the value of that variable shall be set to word.". The reason for this change is that the SYNOPSIS for export includes:

export name[=word]...

but the meaning of the optional "= word" is never explained in the text.

Issue 7
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0043 [352] is applied.

POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0051 [654] and XCU/TC2-2008/0052 [960] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
readonly - set the readonly attribute for variables
SYNOPSIS
readonly name[=word]...
 
readonly -p

DESCRIPTION
The variables whose names are specified shall be given the readonly attribute. The values of variables with the readonly attribute cannot be changed by subsequent assignment, nor can those variables be unset by the unset utility. If the name of a variable is followed by = word, then the value of that variable shall be set to word.

The readonly special built-in shall support XBD Utility Syntax Guidelines.

When -p is specified, readonly writes to the standard output the names and values of all read-only variables, in the following format:

"readonly %s=%s\n", <name>, <value>

if name is set, and

"readonly %s\n", <name>

if name is unset.

The shell shall format the output, including the proper use of quoting, so that it is suitable for reinput to the shell as commands that achieve the same value and readonly attribute-setting results in a shell execution environment in which:

Variables with values at the time they were output do not have the readonly attribute set.

Variables that were unset at the time they were output do not have a value at the time at which the saved output is reinput to the shell.

When no arguments are given, the results are unspecified.

OPTIONS
See the DESCRIPTION.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
See the DESCRIPTION.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
All name operands were successfully marked readonly.
>0
At least one name could not be marked readonly, or the -p option was specified and an error occurred.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
readonly HOME PWD

RATIONALE
Some historical shells preserve the readonly attribute across separate invocations. This volume of POSIX.1-2008 allows this behavior, but does not require it.

The -p option allows portable access to the values that can be saved and then later restored using, for example, a dot script. Also see the RATIONALE for export for a description of the no-argument and -p output cases and a related example.

Read-only functions were considered, but they were omitted as not being historical practice or particularly useful. Furthermore, functions must not be read-only across invocations to preclude "spoofing" (spoofing is the term for the practice of creating a program that acts like a well-known utility with the intent of subverting the real intent of the user) of administrative or security-relevant (or security-conscious) shell scripts.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

XBD Utility Syntax Guidelines

CHANGE HISTORY
Issue 6
IEEE PASC Interpretation 1003.2 #203 is applied, clarifying the format when a variable is unset.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/7 is applied, adding the following text to the end of the first paragraph of the DESCRIPTION: "If the name of a variable is followed by = word, then the value of that variable shall be set to word.". The reason for this change is that the SYNOPSIS for readonly includes:
readonly name[=word]...

but the meaning of the optional "= word" is never explained in the text.

Issue 7
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0052 [960] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
return - return from a function or dot script
SYNOPSIS
return [n]

DESCRIPTION
The return utility shall cause the shell to stop executing the current function or dot script. If the shell is not currently executing a function or dot script, the results are unspecified.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
The value of the special parameter '?' shall be set to n, an unsigned decimal integer, or to the exit status of the last command executed if n is not specified. If n is not an unsigned decimal integer, or is greater than 255, the results are unspecified. When return is executed in a trap action, the last command is considered to be the command that executed immediately preceding the trap action.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
None.

RATIONALE
The behavior of return when not in a function or dot script differs between the System V shell and the KornShell. In the System V shell this is an error, whereas in the KornShell, the effect is the same as exit.

The results of returning a number greater than 255 are undefined because of differing practices in the various historical implementations. Some shells AND out all but the low-order 8 bits; others allow larger values, but not of unlimited size.

See the discussion of appropriate exit status values under exit.

FUTURE DIRECTIONS
None.

SEE ALSO
Function Definition Command, Special Built-In Utilities, dot

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0044 [214] and XCU/TC1-2008/0045 [214] are applied.

POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0052 [960] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
set - set or unset options and positional parameters
SYNOPSIS
set [-abCefhmnuvx] [-o option] [argument...]
 
set [+abCefhmnuvx] [+o option] [argument...]
 
set -- [argument...]
 
set -o
 
set +o

DESCRIPTION
If no options or arguments are specified, set shall write the names and values of all shell variables in the collation sequence of the current locale. Each name shall start on a separate line, using the format:

"%s=%s\n", <name>, <value>

The value string shall be written with appropriate quoting; see the description of shell quoting in Quoting. The output shall be suitable for reinput to the shell, setting or resetting, as far as possible, the variables that are currently set; read-only variables cannot be reset.

When options are specified, they shall set or unset attributes of the shell, as described below. When arguments are specified, they cause positional parameters to be set or unset, as described below. Setting or unsetting attributes and positional parameters are not necessarily related actions, but they can be combined in a single invocation of set.

The set special built-in shall support XBD Utility Syntax Guidelines except that options can be specified with either a leading <hyphen-minus> (meaning enable the option) or <plus-sign> (meaning disable it) unless otherwise specified.

Implementations shall support the options in the following list in both their <hyphen-minus> and <plus-sign> forms. These options can also be specified as options to sh.

-a
When this option is on, the export attribute shall be set for each variable to which an assignment is performed; see XBD Variable Assignment. If the assignment precedes a utility name in a command, the export attribute shall not persist in the current execution environment after the utility completes, with the exception that preceding one of the special built-in utilities causes the export attribute to persist after the built-in has completed. If the assignment does not precede a utility name in the command, or if the assignment is a result of the operation of the getopts or read utilities, the export attribute shall persist until the variable is unset.
-b
This option shall be supported if the implementation supports the User Portability Utilities option. It shall cause the shell to notify the user asynchronously of background job completions. The following message is written to standard error:
"[%d]%c %s%s\n", <job-number>, <current>, <status>, <job-name>

where the fields shall be as follows:

<current>
The character '+' identifies the job that would be used as a default for the fg or bg utilities; this job can also be specified using the job_id "%+" or "%%". The character '-' identifies the job that would become the default if the current default job were to exit; this job can also be specified using the job_id "%-". For other jobs, this field is a <space>. At most one job can be identified with '+' and at most one job can be identified with '-'. If there is any suspended job, then the current job shall be a suspended job. If there are at least two suspended jobs, then the previous job also shall be a suspended job.
<job-number>
A number that can be used to identify the process group to the wait, fg, bg, and kill utilities. Using these utilities, the job can be identified by prefixing the job number with '%'.
<status>
Unspecified.
<job-name>
Unspecified.
When the shell notifies the user a job has been completed, it may remove the job's process ID from the list of those known in the current shell execution environment; see Asynchronous Lists. Asynchronous notification shall not be enabled by default.

-C
(Uppercase C.) Prevent existing files from being overwritten by the shell's '>' redirection operator (see Redirecting Output); the ">|" redirection operator shall override this noclobber option for an individual file.
-e
When this option is on, when any command fails (for any of the reasons listed in Consequences of Shell Errors or by returning an exit status greater than zero), the shell immediately shall exit, as if by executing the exit special built-in utility with no arguments, with the following exceptions:
The failure of any individual command in a multi-command pipeline shall not cause the shell to exit. Only the failure of the pipeline itself shall be considered.

The -e setting shall be ignored when executing the compound list following the while, until, if, or elif reserved word, a pipeline beginning with the ! reserved word, or any command of an AND-OR list other than the last.

If the exit status of a compound command other than a subshell command was the result of a failure while -e was being ignored, then -e shall not apply to this command.

This requirement applies to the shell environment and each subshell environment separately. For example, in:

set -e; (false; echo one) | cat; echo two

the false command causes the subshell to exit without executing echo one; however, echo two is executed because the exit status of the pipeline (false; echo one) | cat is zero.

-f
The shell shall disable pathname expansion.
-h
Locate and remember utilities invoked by functions as those functions are defined (the utilities are normally located when the function is executed).
-m
This option shall be supported if the implementation supports the User Portability Utilities option. All jobs shall be run in their own process groups. Immediately before the shell issues a prompt after completion of the background job, a message reporting the exit status of the background job shall be written to standard error. If a foreground job stops, the shell shall write a message to standard error to that effect, formatted as described by the jobs utility. In addition, if a job changes status other than exiting (for example, if it stops for input or output or is stopped by a SIGSTOP signal), the shell shall write a similar message immediately prior to writing the next prompt. This option is enabled by default for interactive shells.
-n
The shell shall read commands but does not execute them; this can be used to check for shell script syntax errors. An interactive shell may ignore this option.
-o
Write the current settings of the options to standard output in an unspecified format.
+o
Write the current option settings to standard output in a format that is suitable for reinput to the shell as commands that achieve the same options settings.
-o  option
This option is supported if the system supports the User Portability Utilities option. It shall set various options, many of which shall be equivalent to the single option letters. The following values of option shall be supported:
allexport
Equivalent to -a.
errexit
Equivalent to -e.
ignoreeof
Prevent an interactive shell from exiting on end-of-file. This setting prevents accidental logouts when <control>-D is entered. A user shall explicitly exit to leave the interactive shell.
monitor
Equivalent to -m. This option is supported if the system supports the User Portability Utilities option.
noclobber
Equivalent to -C (uppercase C).
noglob
Equivalent to -f.
noexec
Equivalent to -n.
nolog
Prevent the entry of function definitions into the command history; see Command History List.
notify
Equivalent to -b.
nounset
Equivalent to -u.
verbose
Equivalent to -v.
vi
Allow shell command line editing using the built-in vi editor. Enabling vi mode shall disable any other command line editing mode provided as an implementation extension.
It need not be possible to set vi mode on for certain block-mode terminals.

xtrace
Equivalent to -x.
-u
When the shell tries to expand an unset parameter other than the '@' and '*' special parameters, it shall write a message to standard error and the expansion shall fail with the consequences specified in Consequences of Shell Errors.
-v
The shell shall write its input to standard error as it is read.
-x
The shell shall write to standard error a trace for each command after it expands the command and before it executes it. It is unspecified whether the command that turns tracing off is traced.
The default for all these options shall be off (unset) unless stated otherwise in the description of the option or unless the shell was invoked with them on; see sh.

The remaining arguments shall be assigned in order to the positional parameters. The special parameter '#' shall be set to reflect the number of positional parameters. All positional parameters shall be unset before any new values are assigned.

If the first argument is '-', the results are unspecified.

The special argument "--" immediately following the set command name can be used to delimit the arguments if the first argument begins with '+' or '-', or to prevent inadvertent listing of all shell variables when there are no arguments. The command set -- without argument shall unset all positional parameters and set the special parameter '#' to zero.

OPTIONS
See the DESCRIPTION.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
See the DESCRIPTION.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
Successful completion.
>0
An invalid option was specified, or an error occurred.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
Application writers should avoid relying on set -e within functions. For example, in the following script:

set -e
start() {
    some_server
    echo some_server started successfully
}
start || echo >&2 some_server failed

the -e setting is ignored within the function body (because the function is a command in an AND-OR list other than the last). Therefore, if some_server fails, the function carries on to echo "some_server started successfully", and the exit status of the function is zero (which means "some_server failed" is not output).

EXAMPLES
Write out all variables and their values:

set

Set $1, $2, and $3 and set "$#" to 3:

set c a b

Turn on the -x and -v options:

set -xv

Unset all positional parameters:

set --

Set $1 to the value of x, even if it begins with '-' or '+' :

set -- "$x"

Set the positional parameters to the expansion of x, even if x expands with a leading '-' or '+' :

set -- $x

RATIONALE
The set -- form is listed specifically in the SYNOPSIS even though this usage is implied by the Utility Syntax Guidelines. The explanation of this feature removes any ambiguity about whether the set -- form might be misinterpreted as being equivalent to set without any options or arguments. The functionality of this form has been adopted from the KornShell. In System V, set -- only unsets parameters if there is at least one argument; the only way to unset all parameters is to use shift. Using the KornShell version should not affect System V scripts because there should be no reason to issue it without arguments deliberately; if it were issued as, for example:

set -- "$@"

and there were in fact no arguments resulting from "$@", unsetting the parameters would have no result.

The set + form in early proposals was omitted as being an unnecessary duplication of set alone and not widespread historical practice.

The noclobber option was changed to allow set -C as well as the set -o noclobber option. The single-letter version was added so that the historical "$-" paradigm would not be broken; see Special Parameters.

The description of the -e option is intended to match the behavior of the 1988 version of the KornShell.

The -h flag is related to command name hashing. See hash.

The following set flags were omitted intentionally with the following rationale:

-k
The -k flag was originally added by the author of the Bourne shell to make it easier for users of pre-release versions of the shell. In early versions of the Bourne shell the construct set name= value had to be used to assign values to shell variables. The problem with -k is that the behavior affects parsing, virtually precluding writing any compilers. To explain the behavior of -k, it is necessary to describe the parsing algorithm, which is implementation-defined. For example:
set -k; echo name=value
and:

set -k
echo name=value
behave differently. The interaction with functions is even more complex. What is more, the -k flag is never needed, since the command line could have been reordered.

-t
The -t flag is hard to specify and almost never used. The only known use could be done with here-documents. Moreover, the behavior with ksh and sh differs. The reference page says that it exits after reading and executing one command. What is one command? If the input is date; date, sh executes both date commands while ksh does only the first.
Consideration was given to rewriting set to simplify its confusing syntax. A specific suggestion was that the unset utility should be used to unset options instead of using the non- getopt() -able + option syntax. However, the conclusion was reached that the historical practice of using + option was satisfactory and that there was no compelling reason to modify such widespread historical practice.

The -o option was adopted from the KornShell to address user needs. In addition to its generally friendly interface, -o is needed to provide the vi command line editing mode, for which historical practice yields no single-letter option name. (Although it might have been possible to invent such a letter, it was recognized that other editing modes would be developed and -o provides ample name space for describing such extensions.)

Historical implementations are inconsistent in the format used for -o option status reporting. The +o format without an option-argument was added to allow portable access to the options that can be saved and then later restored using, for instance, a dot script.

Historically, sh did trace the command set +x, but ksh did not.

The ignoreeof setting prevents accidental logouts when the end-of-file character (typically <control>-D) is entered. A user shall explicitly exit to leave the interactive shell.

The set -m option was added to apply only to the UPE because it applies primarily to interactive use, not shell script applications.

The ability to do asynchronous notification became available in the 1988 version of the KornShell. To have it occur, the user had to issue the command:

trap "jobs -n" CLD

The C shell provides two different levels of an asynchronous notification capability. The environment variable notify is analogous to what is done in set -b or set -o notify. When set, it notifies the user immediately of background job completions. When unset, this capability is turned off.

The other notification ability comes through the built-in utility notify. The syntax is:

notify [%job ... ]
By issuing notify with no operands, it causes the C shell to notify the user asynchronously when the state of the current job changes. If given operands, notify asynchronously informs the user of changes in the states of the specified jobs.

To add asynchronous notification to the POSIX shell, neither the KornShell extensions to trap, nor the C shell notify environment variable seemed appropriate (notify is not a proper POSIX environment variable name).

The set -b option was selected as a compromise.

The notify built-in was considered to have more functionality than was required for simple asynchronous notification.

Historically, some shells applied the -u option to all parameters including $@ and $*. The standard developers felt that this was a misfeature since it is normal and common for $@ and $* to be used in shell scripts regardless of whether they were passed any arguments. Treating these uses as an error when no arguments are passed reduces the value of -u for its intended purpose of finding spelling mistakes in variable names and uses of unset positional parameters.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities, hash

XBD Variable Assignment, Utility Syntax Guidelines

CHANGE HISTORY
Issue 6
The obsolescent set command name followed by '-' has been removed.

The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:

The nolog option is added to set -o.

IEEE PASC Interpretation 1003.2 #167 is applied, clarifying that the options default also takes into account the description of the option.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/8 is applied, changing the square brackets in the example in RATIONALE to be in bold, which is the typeface used for optional items.

Issue 7
Austin Group Interpretation 1003.1-2001 #027 is applied, clarifying the behavior if the first argument is '-'.

SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

XSI shading is removed from the -h functionality.

POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0046 [52], XCU/TC1-2008/0047 [155,280], XCU/TC1-2008/0048 [52], XCU/TC1-2008/0049 [52], and XCU/TC1-2008/0050 [155,430] are applied.

POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0053 [584], XCU/TC2-2008/0054 [717], XCU/TC2-2008/0055 [717], and XCU/TC2-2008/0056 [960] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
shift - shift positional parameters
SYNOPSIS
shift [n]

DESCRIPTION
The positional parameters shall be shifted. Positional parameter 1 shall be assigned the value of parameter (1+n), parameter 2 shall be assigned the value of parameter (2+n), and so on. The parameters represented by the numbers "$#" down to "$#-n+1" shall be unset, and the parameter '#' is updated to reflect the new number of positional parameters.

The value n shall be an unsigned decimal integer less than or equal to the value of the special parameter '#'. If n is not given, it shall be assumed to be 1. If n is 0, the positional and special parameters are not changed.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
If the n operand is invalid or is greater than "$#", this may be considered a syntax error and a non-interactive shell may exit; if the shell does not exit in this case, a non-zero exit status shall be returned. Otherwise, zero shall be returned.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
$ set a b c d e
$ shift 2
$ echo $*
c d e

RATIONALE
None.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0051 [459] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
times - write process times
SYNOPSIS
times

DESCRIPTION
The times utility shall write the accumulated user and system times for the shell and for all of its child processes, in the following POSIX locale format:

"%dm%fs %dm%fs\n%dm%fs %dm%fs\n", <shell user minutes>,
    <shell user seconds>, <shell system minutes>,
    <shell system seconds>, <children user minutes>,
    <children user seconds>, <children system minutes>,
    <children system seconds>

The four pairs of times shall correspond to the members of the <sys/times.h> tms structure (defined in XBD Headers) as returned by times(): tms_utime, tms_stime, tms_cutime, and tms_cstime, respectively.

OPTIONS
None.

OPERANDS
None.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
See the DESCRIPTION.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
$ times
0m0.43s 0m1.11s
8m44.18s 1m43.23s

RATIONALE
The times special built-in from the Single UNIX Specification is now required for all conforming shells.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

XBD <sys/times.h>

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/9 is applied, changing text in the DESCRIPTION from: "Write the accumulated user and system times for the shell and for all of its child processes ..." to: "The times utility shall write the accumulated user and system times for the shell and for all of its child processes ...".

Issue 7
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0056 [960] is applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
trap - trap signals
SYNOPSIS
trap n [condition...]trap [action condition...]

DESCRIPTION
If the first operand is an unsigned decimal integer, the shell shall treat all operands as conditions, and shall reset each condition to the default value. Otherwise, if there are operands, the first is treated as an action and the remaining as conditions.

If action is '-', the shell shall reset each condition to the default value. If action is null ( "" ), the shell shall ignore each specified condition if it arises. Otherwise, the argument action shall be read and executed by the shell when one of the corresponding conditions arises. The action of trap shall override a previous action (either default action or one explicitly set). The value of "$?" after the trap action completes shall be the value it had before trap was invoked.

The condition can be EXIT, 0 (equivalent to EXIT), or a signal specified using a symbolic name, without the SIG prefix, as listed in the tables of signal names in the <signal.h> header defined in XBD Headers; for example, HUP, INT, QUIT, TERM. Implementations may permit names with the SIG prefix or ignore case in signal names as an extension. Setting a trap for SIGKILL or SIGSTOP produces undefined results.

The environment in which the shell executes a trap on EXIT shall be identical to the environment immediately after the last command executed before the trap on EXIT was taken.

Each time trap is invoked, the action argument shall be processed in a manner equivalent to:

eval action
Signals that were ignored on entry to a non-interactive shell cannot be trapped or reset, although no error need be reported when attempting to do so. An interactive shell may reset or catch signals ignored on entry. Traps shall remain in place for a given shell until explicitly changed with another trap command.

When a subshell is entered, traps that are not being ignored shall be set to the default actions, except in the case of a command substitution containing only a single trap command, when the traps need not be altered. Implementations may check for this case using only lexical analysis; for example, if `trap` and $( trap -- ) do not alter the traps in the subshell, cases such as assigning var=trap and then using $($var) may still alter them. This does not imply that the trap command cannot be used within the subshell to set new traps.

The trap command with no operands shall write to standard output a list of commands associated with each condition. If the command is executed in a subshell, the implementation does not perform the optional check described above for a command substitution containing only a single trap command, and no trap commands with operands have been executed since entry to the subshell, the list shall contain the commands that were associated with each condition immediately before the subshell environment was entered. Otherwise, the list shall contain the commands currently associated with each condition. The format shall be:

"trap -- %s %s ...\n", <action>, <condition> ...

The shell shall format the output, including the proper use of quoting, so that it is suitable for reinput to the shell as commands that achieve the same trapping results. For example:

save_traps=$(trap)
...
eval "$save_traps"

[XSI] [Option Start] XSI-conformant systems also allow numeric signal numbers for the conditions corresponding to the following signal names:

1
SIGHUP
2
SIGINT
3
SIGQUIT
6
SIGABRT
9
SIGKILL
14
SIGALRM
15
SIGTERM
[Option End]
The trap special built-in shall conform to XBD Utility Syntax Guidelines.

OPTIONS
None.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
See the DESCRIPTION.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
If the trap name [XSI] [Option Start]  or number [Option End] is invalid, a non-zero exit status shall be returned; otherwise, zero shall be returned. For both interactive and non-interactive shells, invalid signal names [XSI] [Option Start]  or numbers [Option End] shall not be considered a syntax error and do not cause the shell to abort.

CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
Write out a list of all traps and actions:

trap

Set a trap so the logout utility in the directory referred to by the HOME environment variable executes when the shell terminates:

trap '"$HOME"/logout' EXIT

or:

trap '"$HOME"/logout' 0

Unset traps on INT, QUIT, TERM, and EXIT:

trap - INT QUIT TERM EXIT

RATIONALE
Implementations may permit lowercase signal names as an extension. Implementations may also accept the names with the SIG prefix; no known historical shell does so. The trap and kill utilities in this volume of POSIX.1-2008 are now consistent in their omission of the SIG prefix for signal names. Some kill implementations do not allow the prefix, and kill -l lists the signals without prefixes.

Trapping SIGKILL or SIGSTOP is syntactically accepted by some historical implementations, but it has no effect. Portable POSIX applications cannot attempt to trap these signals.

The output format is not historical practice. Since the output of historical trap commands is not portable (because numeric signal values are not portable) and had to change to become so, an opportunity was taken to format the output in a way that a shell script could use to save and then later reuse a trap if it wanted.

The KornShell uses an ERR trap that is triggered whenever set -e would cause an exit. This is allowable as an extension, but was not mandated, as other shells have not used it.

The text about the environment for the EXIT trap invalidates the behavior of some historical versions of interactive shells which, for example, close the standard input before executing a trap on 0. For example, in some historical interactive shell sessions the following trap on 0 would always print "--" :

trap 'read foo; echo "-$foo-"' 0

The command:

trap 'eval " $cmd"' 0

causes the contents of the shell variable cmd to be executed as a command when the shell exits. Using:

trap '$cmd' 0

does not work correctly if cmd contains any special characters such as quoting or redirections. Using:

trap " $cmd" 0

also works (the leading <space> character protects against unlikely cases where cmd is a decimal integer or begins with '-' ), but it expands the cmd variable when the trap command is executed, not when the exit action is executed.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

XBD Utility Syntax Guidelines, <signal.h>

CHANGE HISTORY
Issue 6
XSI-conforming implementations provide the mapping of signal names to numbers given above (previously this had been marked obsolescent). Other implementations need not provide this optional mapping.

IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

Austin Group Interpretation 1003.1-2001 #116 is applied.

POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0052 [53,268,440], XCU/TC1-2008/0053 [53,268,440], XCU/TC1-2008/0054 [163], XCU/TC1-2008/0055 [163], and XCU/TC1-2008/0056 [163] are applied.

End of informative text.
<<< Previous	Home	Next >>>
NAME
unset - unset values and attributes of variables and functions
SYNOPSIS
unset [-fv] name...

DESCRIPTION
Each variable or function specified by name shall be unset.

If -v is specified, name refers to a variable name and the shell shall unset it and remove it from the environment. Read-only variables cannot be unset.

If -f is specified, name refers to a function and the shell shall unset the function definition.

If neither -f nor -v is specified, name refers to a variable; if a variable by that name does not exist, it is unspecified whether a function by that name, if any, shall be unset.

Unsetting a variable or function that was not previously set shall not be considered an error and does not cause the shell to abort.

The unset special built-in shall support XBD Utility Syntax Guidelines.

Note that:

VARIABLE=

is not equivalent to an unset of VARIABLE; in the example, VARIABLE is set to "". Also, the variables that can be unset should not be misinterpreted to include the special parameters (see Special Parameters).

OPTIONS
See the DESCRIPTION.

OPERANDS
See the DESCRIPTION.

STDIN
Not used.

INPUT FILES
None.

ENVIRONMENT VARIABLES
None.

ASYNCHRONOUS EVENTS
Default.

STDOUT
Not used.

STDERR
The standard error shall be used only for diagnostic messages.

OUTPUT FILES
None.

EXTENDED DESCRIPTION
None.

EXIT STATUS
 0
All name operands were successfully unset.
>0
At least one name could not be unset.
CONSEQUENCES OF ERRORS
Default.

The following sections are informative.
APPLICATION USAGE
None.

EXAMPLES
Unset VISUAL variable:

unset -v VISUAL

Unset the functions foo and bar:

unset -f foo bar

RATIONALE
Consideration was given to omitting the -f option in favor of an unfunction utility, but the standard developers decided to retain historical practice.

The -v option was introduced because System V historically used one name space for both variables and functions. When unset is used without options, System V historically unset either a function or a variable, and there was no confusion about which one was intended. A portable POSIX application can use unset without an option to unset a variable, but not a function; the -f option must be used.

FUTURE DIRECTIONS
None.

SEE ALSO
Special Built-In Utilities

XBD Utility Syntax Guidelines

CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as described in the Utility Description Defaults (Utility Description Defaults). No change in behavior is intended.

Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.

End of informative text.
<<< Previous	Home	Next >>>





